# main.py
# aiogram 3.x bot for Blackberry clan onboarding
# Adds: internal ClanID, DM review, factions, DOB. Reports/CSV.
# Removal checklist updated: items 1 (DB) and 3 (Discord) are MANUAL via "Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾".
# Only item 2 (remove from Telegram clan chat) is automatic.
import asyncio
import logging
from datetime import datetime, timedelta, date
from enum import Enum
from typing import Optional, Tuple, List

import aiosqlite
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart, or_f, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    Message,
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    CallbackQuery,
    ChatInviteLink,
    FSInputFile,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder

# ======= CONFIG =======
BOT_TOKEN = ""                     # â†� token from @BotFather (required)
CHANNEL_USERNAME = "@SquadBlackBerry"
CLAN_CHAT_ID = 0                   # -100...
MODERATION_CHAT_ID = 0             # optional: join notifications

ADMIN_IDS = set()                  # {111, 222}
MODERATOR_IDS = set()              # {333}

DB_PATH = "blackberry_bot.db"

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set in code (fill BOT_TOKEN at the top of main.py)")

# ======= DB LAYER =======
CREATE_USERS_SQL = """
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    clan_id INTEGER,
    phone TEXT,
    nickname TEXT,
    discord TEXT,
    steamid TEXT,
    age INTEGER,
    birth_date TEXT,
    timezone TEXT,
    tg_link TEXT,
    faction TEXT,
    status TEXT,
    created_at TEXT,
    applied_at TEXT,
    approved_at TEXT,
    joined_at TEXT
);
"""
CREATE_USERS_ARCHIVE_SQL = """
CREATE TABLE IF NOT EXISTS users_archive AS
SELECT user_id, clan_id, phone, nickname, discord, steamid, age, birth_date, timezone, tg_link,
       faction, status, created_at, applied_at, approved_at, joined_at,
       '' AS archived_at
FROM users WHERE 0;
"""
CREATE_REMOVE_TABLE_SQL = """
CREATE TABLE IF NOT EXISTS removal_checklist (
    user_id INTEGER PRIMARY KEY,
    db_done INTEGER DEFAULT 0,
    tg_done INTEGER DEFAULT 0,
    discord_done INTEGER DEFAULT 0
);
"""

class Status(str, Enum):
    NEW = "new"
    PENDING_CHANNEL = "pending_channel"
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    JOINED = "joined"
    REMOVED = "removed"

FACTIONS = {
    "cran": "Cranberry",
    "blue": "Blueberry",
    "water": "Watermelon",
    "recruit": "Ğ ĞµĞºÑ€ÑƒÑ‚",
    "reserve": "Ğ ĞµĞ·ĞµÑ€Ğ²",
    "command": "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ",
}

def faction_tuple_list() -> Tuple[Tuple[str, str], ...]:
    return (
        ("cran", "Cranberry"),
        ("blue", "Blueberry"),
        ("water", "Watermelon"),
        ("recruit", "Ğ ĞµĞºÑ€ÑƒÑ‚"),
        ("reserve", "Ğ ĞµĞ·ĞµÑ€Ğ²"),
        ("command", "ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ"),
    )

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(CREATE_USERS_SQL)
        await db.execute(CREATE_USERS_ARCHIVE_SQL)
        await db.execute(CREATE_REMOVE_TABLE_SQL)
        # Migrations
        for alter in [
            "ALTER TABLE users ADD COLUMN applied_at TEXT",
            "ALTER TABLE users ADD COLUMN birth_date TEXT",
            "ALTER TABLE users ADD COLUMN faction TEXT",
            "ALTER TABLE users ADD COLUMN clan_id INTEGER",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE users_archive ADD COLUMN archived_at TEXT",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE removal_checklist ADD COLUMN db_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN tg_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN discord_done INTEGER DEFAULT 0",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        await db.commit()
    await ensure_clan_ids()

async def ensure_clan_ids():
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) FROM users")
        (max_clan_id,) = await cur.fetchone()
        cur = await db.execute("SELECT user_id FROM users WHERE clan_id IS NULL ORDER BY rowid")
        rows = await cur.fetchall()
        next_id = max_clan_id + 1
        changed = False
        for (uid,) in rows:
            await db.execute("UPDATE users SET clan_id=? WHERE user_id=?", (next_id, uid))
            next_id += 1
            changed = True
        if changed:
            await db.commit()

async def next_clan_id(db: aiosqlite.Connection) -> int:
    cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) + 1 FROM users")
    (nid,) = await cur.fetchone()
    return int(nid)

async def upsert_user(user_id: int, **fields):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id, clan_id FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if row:
            cols = ", ".join([f"{k}=?" for k in fields.keys()])
            vals = list(fields.values()) + [user_id]
            await db.execute(f"UPDATE users SET {cols} WHERE user_id=?", vals)
        else:
            cid = await next_clan_id(db)
            keys = ["user_id", "clan_id", *fields.keys()]
            placeholders = ",".join(["?"] * len(keys))
            vals = [user_id, cid, *fields.values()]
            await db.execute(
                f"INSERT INTO users ({','.join(keys)}) VALUES ({placeholders})",
                vals,
            )
        await db.commit()

async def get_user(user_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def get_user_by_username(username: str) -> Optional[dict]:
    uname = username.lstrip("@")
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE (tg_link LIKE ?) OR (LOWER(nickname)=LOWER(?)) LIMIT 1",
            (f"%t.me/{uname}%", uname,)
        )
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def search_users_by_nickname(q: str, limit: int = 10) -> List[dict]:
    q = q.strip()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE nickname LIKE ? ORDER BY created_at DESC LIMIT ?",
            (f"%{q}%", limit)
        )
        rows = await cur.fetchall()
        columns = [col[0] for col in cur.description]
        return [dict(zip(columns, r)) for r in rows]

# ======= FSM =======
class RegStates(StatesGroup):
    waiting_phone = State()
    waiting_nickname = State()
    waiting_discord = State()
    waiting_steam = State()
    waiting_birthdate = State()
    waiting_tz = State()
    waiting_tg_link = State()

# ======= BOT SETUP =======
logging.basicConfig(level=logging.INFO)
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher()

def phone_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="ğŸ“± Ğ�Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ¼ĞµÑ€", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="Ğ�Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑ�Ñ� Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼",
    )

def subscription_check_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="ğŸ”” ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸Ñ�ĞºÑƒ", callback_data="check_sub")
    return kb.as_markup()

def apply_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="ğŸ“¨ Ğ�Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ñ�Ğ²ĞºÑƒ", callback_data="send_apply")
    return kb.as_markup()

def profile_admin_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="ğŸ�¯ Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ñ�", callback_data=f"profile_choosefac:{user_id}")
    kb.button(text="ğŸ—‘ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ°", callback_data=f"remove:init:{user_id}")
    kb.row()
    kb.button(text="ğŸ”„ Ğ�Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data=f"profile_refresh:{user_id}")
    return kb.as_markup()

def faction_choose_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("cran","Cranberry"),("blue","Blueberry"),("water","Watermelon")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("recruit","Ğ ĞµĞºÑ€ÑƒÑ‚"),("reserve","Ğ ĞµĞ·ĞµÑ€Ğ²"),("command","ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    kb.button(text="â¬…ï¸� Ğ�Ğ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ�", callback_data=f"profile_back:{user_id}")
    return kb.as_markup()

def approve_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ… ĞŸÑ€Ğ¸Ğ½Ñ�Ñ‚ÑŒ", callback_data=f"approve:{user_id}")
    kb.button(text="â�Œ Ğ�Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ñ‚ÑŒ", callback_data=f"reject:{user_id}")
    return kb.as_markup()

def pad_clan_id(v: Optional[int]) -> str:
    if not v:
        return "â€”"
    return f"{int(v):04d}"

def format_profile(user: dict, title: str = "ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ°") -> str:
    lines = [f"<b>{title}</b>"]
    fields = [
        ("ClanID", pad_clan_id(user.get("clan_id"))),
        ("Telegram ID", user.get("user_id")),
        ("Ğ�Ğ¸Ğº", user.get("nickname")),
        ("Discord", user.get("discord")),
        ("SteamID", user.get("steamid")),
        ("Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ�", user.get("birth_date")),
        ("Ğ’Ğ¾Ğ·Ñ€Ğ°Ñ�Ñ‚", user.get("age")),
        ("Ğ§Ğ°Ñ�Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ñ�Ñ�", user.get("timezone")),
        ("Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ TG", user.get("tg_link")),
        ("Ğ¤Ñ€Ğ°ĞºÑ†Ğ¸Ñ�", user.get("faction")),
        ("Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ�", user.get("status")),
        ("Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½", user.get("created_at")),
        ("Ğ—Ğ°Ñ�Ğ²ĞºĞ°", user.get("applied_at")),
        ("Ğ�Ğ´Ğ¾Ğ±Ñ€ĞµĞ½", user.get("approved_at")),
        ("Ğ’Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ»", user.get("joined_at")),
    ]
    for k, v in fields:
        if v not in (None, "", "None"):
            lines.append(f"{k}: {v}")
    return "\n".join(lines)

# ======= HELPERS =======
async def is_subscribed(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        return member.status in ("member", "administrator", "creator")
    except Exception as e:
        logging.exception("Failed to check subscription: %r", e)
        return False

def reviewer_ids() -> List[int]:
    return sorted(set(ADMIN_IDS) | set(MODERATOR_IDS))

async def send_application_to_all(text: str, user_id: int):
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, text, reply_markup=approve_kb(user_id))
        except Exception as e:
            logging.warning("Cannot DM reviewer %s: %r", rid, e)

async def notify_review_outcome(user_id: int, outcome: str):
    label = "âœ… Ğ�Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ¾" if outcome == "approved" else "â�Œ Ğ�Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾"
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, f"{label}: Ğ·Ğ°Ñ�Ğ²ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ� <code>{user_id}</code> ÑƒĞ¶Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ°.")
        except Exception:
            pass

async def send_to_moderation(text: str, reply_markup: Optional[InlineKeyboardMarkup] = None):
    if MODERATION_CHAT_ID:
        try:
            await bot.send_message(MODERATION_CHAT_ID, text, reply_markup=reply_markup)
        except Exception:
            pass

async def create_invite_link() -> Optional[ChatInviteLink]:
    try:
        link = await bot.create_chat_invite_link(
            chat_id=CLAN_CHAT_ID,
            name=f"Onboarding {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            creates_join_request=False,
            expire_date=None,
            member_limit=1,
        )
        return link
    except Exception as e:
        logging.exception("Cannot create invite link: %r", e)
        return None

# ======= Removal checklist (manual for items 1 and 3) =======
async def ensure_removal_record(user_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id) VALUES(?) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        await db.commit()

def removal_kb(user_id: int, done_db: bool, done_tg: bool, done_discord: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text=("âœ… 1. Ğ˜Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ¾" if done_db else "1. Ğ�Ñ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹"), callback_data=f"remove:db:{user_id}")
    kb.button(text=("âœ… 2. Ğ˜Ğ· ĞºĞ»Ğ°Ğ½-Ñ‡Ğ°Ñ‚Ğ°" if done_tg else "2. Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ· ĞºĞ»Ğ°Ğ½-Ñ‡Ğ°Ñ‚Ğ°"), callback_data=f"remove:tg:{user_id}")
    kb.row()
    kb.button(text=("âœ… 3. Ğ˜Ğ· Discord Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ¾" if done_discord else "3. Ğ�Ñ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· Discord"), callback_data=f"remove:disc:{user_id}")
    kb.row()
    if done_db and done_tg and done_discord:
        kb.button(text="ğŸ§¹ Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ â€” Ñ�Ñ‚ĞµÑ€ĞµÑ‚ÑŒ Ğ¸Ğ· Ğ±Ğ°Ğ·Ñ‹", callback_data=f"remove:final:{user_id}")
        kb.row()
    kb.button(text="â¬…ï¸� Ğ�Ğ°Ğ·Ğ°Ğ´ Ğº Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ�", callback_data=f"profile_back:{user_id}")
    return kb.as_markup()

async def removal_state(user_id: int) -> tuple[bool, bool, bool]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT db_done, tg_done, discord_done FROM removal_checklist WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
    if row:
        return bool(row[0]), bool(row[1]), bool(row[2])
    return False, False, False

def removal_text(user: Optional[dict], done_db: bool, done_tg: bool, done_discord: bool) -> str:
    title = "<b>Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ° â€” Ñ‡ĞµĞº-Ğ»Ğ¸Ñ�Ñ‚</b>"
    if user:
        header = f"ClanID: <code>{pad_clan_id(user.get('clan_id'))}</code> | ID: <code>{user.get('user_id')}</code> | Ğ�Ğ¸Ğº: {user.get('nickname') or '-'}"
    else:
        header = f"ID: <code>{user}</code>"
    def mark(b): return "âœ…" if b else "â˜�"
    lines = [
        title,
        header,
        "",
        f"{mark(done_db)} 1) ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ: Ğ¸Ğ³Ñ€Ğ¾Ğº ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ‘Ğ” (Ğ¾Ñ‚Ğ¼ĞµÑ‡Ğ°ĞµÑ‚Ñ�Ñ� Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ� ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ Â«Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ (Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°)Â»).",
        f"{mark(done_tg)} 2) Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ· ĞºĞ»Ğ°Ğ½-Ñ‡Ğ°Ñ‚Ğ° Telegram (Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ñ�ĞµÑ‚ Ğ±Ğ¾Ñ‚ Ğ¿Ğ¾ ĞºĞ½Ğ¾Ğ¿ĞºĞµ).",
        f"{mark(done_discord)} 3) ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ: Ğ¸Ğ³Ñ€Ğ¾Ğº ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¸Ğ· Discord (Ğ¾Ñ‚Ğ¼ĞµÑ‡Ğ°ĞµÑ‚Ñ�Ñ� Ğ²Ñ€ÑƒÑ‡Ğ½ÑƒÑ� ĞºĞ½Ğ¾Ğ¿ĞºĞ¾Ğ¹ Â«Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ (Discord)Â»).",
    ]
    return "\n".join(lines)

# ======= HANDLERS =======
@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if user and user.get("status") in (Status.APPROVED, Status.JOINED):
        await message.answer("Ğ’Ñ‹ ÑƒĞ¶Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸Ñ�Ñ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹. Ğ˜Ñ�Ğ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ /profile, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ñ�Ğ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.")
        return

    await upsert_user(
        message.from_user.id,
        status=Status.NEW.value,
        created_at=datetime.utcnow().isoformat(),
    )
    await ensure_clan_ids()
    await message.answer(
        "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ¯ Ğ±Ğ¾Ñ‚ ĞºĞ»Ğ°Ğ½Ğ° Blackberry. Ğ”Ğ»Ñ� Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ€ĞµĞ³Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ñ‚ĞµÑ�ÑŒ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:",
        reply_markup=phone_kb(),
    )
    await state.set_state(RegStates.waiting_phone)

@dp.message(RegStates.waiting_phone, F.contact)
async def got_phone(message: Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("Ğ�Ñ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¸Ğº (Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¸Ğ¼Ñ�):", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_nickname)

@dp.message(RegStates.waiting_phone)
async def need_phone(message: Message):
    await message.answer("ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹Ñ�Ñ‚Ğ°, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ¸ Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ñ‚ĞµÑ�ÑŒ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°.", reply_markup=phone_kb())

@dp.message(RegStates.waiting_nickname)
async def got_nick(message: Message, state: FSMContext):
    await state.update_data(nickname=message.text.strip())
    await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Discord:")
    await state.set_state(RegStates.waiting_discord)

@dp.message(RegStates.waiting_discord)
async def got_discord(message: Message, state: FSMContext):
    await state.update_data(discord=message.text.strip())
    await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ SteamID:")
    await state.set_state(RegStates.waiting_steam)

@dp.message(RegStates.waiting_steam)
async def got_steam(message: Message, state: FSMContext):
    await state.update_data(steamid=message.text.strip())
    await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ� (Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“):")
    await state.set_state(RegStates.waiting_birthdate)

@dp.message(RegStates.waiting_birthdate)
async def got_birthdate(message: Message, state: FSMContext):
    text = message.text.strip()
    try:
        birth_date = datetime.strptime(text, "%d.%m.%Y").date()
        if birth_date > date.today():
            raise ValueError("future")
    except Exception:
        await message.answer("â�Œ Ğ�ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚. Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ´Ğ°Ñ‚Ñƒ Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ� ĞºĞ°Ğº Ğ”Ğ”.ĞœĞœ.Ğ“Ğ“Ğ“Ğ“ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 15.08.1995).")
        return

    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))

    await state.update_data(birth_date=birth_date.isoformat(), age=age)
    await message.answer(f"âœ… ĞŸÑ€Ğ¸Ğ½Ñ�Ñ‚Ğ¾. Ğ’Ğ°Ñˆ Ğ²Ğ¾Ğ·Ñ€Ğ°Ñ�Ñ‚: {age}.\nĞ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‡Ğ°Ñ�Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ñ�Ñ� (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, GMT+3 Ğ¸Ğ»Ğ¸ Europe/Moscow):")
    await state.set_state(RegStates.waiting_tz)

@dp.message(RegStates.waiting_tz)
async def got_tz(message: Message, state: FSMContext):
    await state.update_data(timezone=message.text.strip())
    await message.answer("Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ�Ñ�Ñ‹Ğ»ĞºÑƒ Ğ½Ğ° Ğ²Ğ°Ñˆ Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Telegram (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, https://t.me/username):")
    await state.set_state(RegStates.waiting_tg_link)

@dp.message(RegStates.waiting_tg_link)
async def got_tg_link(message: Message, state: FSMContext):
    data = await state.update_data(tg_link=message.text.strip())
    data = await state.get_data()

    await upsert_user(
        message.from_user.id,
        phone=data.get("phone"),
        nickname=data.get("nickname"),
        discord=data.get("discord"),
        steamid=data.get("steamid"),
        age=data.get("age"),
        birth_date=data.get("birth_date"),
        timezone=data.get("timezone"),
        tg_link=data.get("tg_link"),
        status=Status.PENDING_CHANNEL.value,
    )
    await ensure_clan_ids()

    preview = (
        f"<b>ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ</b>\n"
        f"Ğ�Ğ¸Ğº: {data.get('nickname')}\n"
        f"Discord: {data.get('discord')}\n"
        f"SteamID: {data.get('steamid')}\n"
        f"Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ�: {data.get('birth_date')}\n"
        f"Ğ’Ğ¾Ğ·Ñ€Ğ°Ñ�Ñ‚ (Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ): {data.get('age')}\n"
        f"Ğ§Ğ°Ñ�Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ñ�Ñ�: {data.get('timezone')}\n"
        f"Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ TG: {data.get('tg_link')}\n\n"
        f"ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑˆĞ¸Ñ‚ĞµÑ�ÑŒ Ğ½Ğ° ĞºĞ°Ğ½Ğ°Ğ» Ğ½Ğ¾Ğ²Ğ¾Ñ�Ñ‚ĞµĞ¹: {CHANNEL_USERNAME}"
    )

    await message.answer(preview)
    await message.answer(
        "ĞŸĞ¾Ñ�Ğ»Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸Ñ�ĞºĞ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ:",
        reply_markup=subscription_check_kb(),
    )
    await state.clear()

# Subscription
@dp.callback_query(F.data == "check_sub")
async def on_check_sub(call: CallbackQuery):
    uid = call.from_user.id
    if await is_subscribed(uid):
        await upsert_user(uid, status=Status.PENDING_REVIEW.value)
        await call.message.edit_text(
            "ĞŸĞ¾Ğ´Ğ¿Ğ¸Ñ�ĞºĞ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ°. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ğ·Ğ°Ñ�Ğ²ĞºÑƒ Ğ½Ğ° Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ.",
            reply_markup=apply_kb(),
        )
    else:
        await call.answer("Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑˆĞ¸Ñ‚ĞµÑ�ÑŒ Ğ½Ğ° ĞºĞ°Ğ½Ğ°Ğ» @SquadBlackBerry", show_alert=True)

# Send application to ALL reviewers in DMs
@dp.callback_query(F.data == "send_apply")
async def on_send_apply(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not user or user.get("status") != Status.PENDING_REVIEW.value:
        await call.answer("Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸Ñ�ĞºÑƒ.", show_alert=True)
        return

    await upsert_user(uid, applied_at=datetime.utcnow().isoformat())
    user = await get_user(uid)
    clan_id = pad_clan_id(user.get("clan_id"))

    text = (
        f"<b>Ğ�Ğ¾Ğ²Ğ°Ñ� Ğ·Ğ°Ñ�Ğ²ĞºĞ° Ğ² ĞºĞ»Ğ°Ğ½</b>\n"
        f"ClanID: <code>{clan_id}</code>\n"
        f"Telegram ID: <code>{uid}</code>\n"
        f"Ğ�Ğ¸Ğº: {user.get('nickname')}\n"
        f"Discord: {user.get('discord')}\n"
        f"SteamID: {user.get('steamid')}\n"
        f"Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ�: {user.get('birth_date') or '-'}\n"
        f"Ğ’Ğ¾Ğ·Ñ€Ğ°Ñ�Ñ‚: {user.get('age') or '-'}\n"
        f"Ğ§Ğ°Ñ�Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ñ�Ñ�: {user.get('timezone')}\n"
        f"Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ TG: {user.get('tg_link')}\n"
        f"Ğ¤Ñ€Ğ°ĞºÑ†Ğ¸Ñ�: {user.get('faction') or 'â€” (Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ°)'}\n"
    )
    await send_application_to_all(text, uid)
    await call.message.edit_text("Ğ—Ğ°Ñ�Ğ²ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼ Ğ¸ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼. Ğ�Ğ¶Ğ¸Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ�.")

# ======= Moderation/Profile flow =======
@dp.message(Command("player"))
async def cmd_player(message: Message, command: Command):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹.")
        return
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
    "Ğ˜Ñ�Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:
"
    "<code>/player &lt;user_id&gt;</code> â€” Ğ¿Ğ¾ Telegram ID
"
    "<code>/player @username</code> â€” Ğ¿Ğ¾ username
"
    "<code>/player Ñ‡Ğ°Ñ�Ñ‚ÑŒ_Ğ½Ğ¸ĞºĞ°</code> â€” Ğ¿Ğ¾ Ñ„Ñ€Ğ°Ğ³Ğ¼ĞµĞ½Ñ‚Ñƒ Ğ½Ğ¸ĞºĞ°
"
    "<code>/player #&lt;ClanID&gt;</code> â€” Ğ¿Ğ¾ ClanID"
)
    return

        return
    query = args[1].strip()

    target_user: Optional[dict] = None
    if query.isdigit():
        target_user = await get_user(int(query))
    if not target_user and query.startswith("@"):
        target_user = await get_user_by_username(query)
    if not target_user:
        matches = await search_users_by_nickname(query, limit=10)
        if len(matches) == 1:
            target_user = matches[0]
        elif len(matches) > 1:
            lines = ["Ğ�Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ğ½ĞµÑ�ĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹:"]
            for u in matches:
                lines.append(f"â€¢ {u.get('nickname') or '-'} â€” ClanID: {pad_clan_id(u.get('clan_id'))} â€” ID: <code>{u['user_id']}</code> â€” Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ñ�: {u.get('faction') or '-'}")
            lines.append("\nĞ£Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ñ‚Ğµ: /player &lt;ID&gt;")
            await message.answer("\n".join(lines))
            return

    if not target_user:
        await message.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.")
        return

    await message.answer(format_profile(target_user), reply_markup=profile_admin_kb(target_user["user_id"]))

@dp.callback_query(F.data.startswith("profile_refresh:"))
async def on_profile_refresh(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer("ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½.")

@dp.callback_query(F.data.startswith("profile_choosefac:"))
async def on_profile_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.", show_alert=True)
        return
    text = format_profile(user, title="Ğ’Ñ‹Ğ±Ğ¾Ñ€ Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸")
    try:
        await call.message.edit_text(text + "\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ñ�:", reply_markup=faction_choose_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("profile_back:"))
async def on_profile_back(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("facset:"))
async def on_profile_set_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    try:
        _, uid_str, code = call.data.split(":")
        target_id = int(uid_str)
        title = {"cran":"Cranberry","blue":"Blueberry","water":"Watermelon","recruit":"Ğ ĞµĞºÑ€ÑƒÑ‚","reserve":"Ğ ĞµĞ·ĞµÑ€Ğ²","command":"ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ"}.get(code)
        if not title:
            raise ValueError("unknown faction code")
    except Exception:
        await call.answer("Ğ�ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ.", show_alert=True)
        return
    await upsert_user(target_id, faction=title)
    user = await get_user(target_id)
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer(f"Ğ¤Ñ€Ğ°ĞºÑ†Ğ¸Ñ� ÑƒÑ�Ñ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°: {title}")

# ======= Removal flow (manual items 1 & 3) =======
@dp.callback_query(F.data.startswith("remove:init:"))
async def on_remove_init(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    await ensure_removal_record(target_id)
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:dbdone:"))
async def on_remove_dbdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, db_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET db_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("Ğ�Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ¾ ĞºĞ°Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ (Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°).")

@dp.callback_query(F.data.startswith("remove:tg:"))
async def on_remove_tg(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    try:
        await bot.ban_chat_member(CLAN_CHAT_ID, target_id)
        await bot.unban_chat_member(CLAN_CHAT_ID, target_id)
        ok = True
    except Exception as e:
        logging.warning("Failed to remove from chat: %r", e)
        ok = False
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, tg_done) VALUES(?,?) ON CONFLICT(user_id) DO UPDATE SET tg_done=?", (target_id, 1 if ok else 0, 1 if ok else 0))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("Ğ£Ğ´Ğ°Ğ»Ñ‘Ğ½ Ğ¸Ğ· ĞºĞ»Ğ°Ğ½-Ñ‡Ğ°Ñ‚Ğ°." if ok else "Ğ�Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾Ñ�ÑŒ ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ· ĞºĞ»Ğ°Ğ½-Ñ‡Ğ°Ñ‚Ğ°.")

@dp.callback_query(F.data.startswith("remove:discdone:"))
async def on_remove_discdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, discord_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET discord_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("Ğ�Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ğ¾ ĞºĞ°Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾ (Discord).")

# ======= Approve/Reject (DM) =======
@dp.callback_query(F.data.startswith("approve:"))
async def on_approve(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ğ´Ğ¾Ğ±Ñ€Ñ�Ñ‚ÑŒ Ğ·Ğ°Ñ�Ğ²ĞºĞ¸.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("Ğ—Ğ°Ñ�Ğ²ĞºĞ° ÑƒĞ¶Ğµ Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ° Ñ€Ğ°Ğ½ĞµĞµ.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("Ğ—Ğ°Ñ�Ğ²ĞºĞ° ÑƒĞ¶Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ° Ñ€Ğ°Ğ½ĞµĞµ.", show_alert=True)
        return

    faction = user.get("faction") or "Ğ ĞµĞºÑ€ÑƒÑ‚"
    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat(), faction=faction)

    link = await create_invite_link()
    if not link:
        await call.answer("Ğ�Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾Ñ�ÑŒ Ñ�Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ�Ñ�Ñ‹Ğ»ĞºÑƒ-Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ±Ğ¾Ñ‚Ğ° Ğ² Ñ‡Ğ°Ñ‚Ğµ ĞºĞ»Ğ°Ğ½Ğ°.", show_alert=True)
        return

    await bot.send_message(
        target_id,
        f"Ğ’Ğ°ÑˆĞ° Ğ·Ğ°Ñ�Ğ²ĞºĞ° Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ°!\nĞ¤Ñ€Ğ°ĞºÑ†Ğ¸Ñ�: {faction}\nĞ¡Ñ�Ñ‹Ğ»ĞºĞ° Ğ´Ğ»Ñ� Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ñ� Ğ² Ñ‡Ğ°Ñ‚ ĞºĞ»Ğ°Ğ½Ğ°: {link.invite_link}",
    )

    try:
        await call.message.edit_text(call.message.text + "\n\nâœ… Ğ�Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ¾")
    except Exception:
        pass
    await call.answer("Ğ�Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ¾ âœ…")
    await notify_review_outcome(target_id, "approved")

@dp.callback_query(F.data.startswith("reject:"))
async def on_reject(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ñ�Ñ‚ÑŒ Ğ·Ğ°Ñ�Ğ²ĞºĞ¸.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒĞ¶Ğµ Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½/Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ».", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("Ğ—Ğ°Ñ�Ğ²ĞºĞ° ÑƒĞ¶Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ° Ñ€Ğ°Ğ½ĞµĞµ.", show_alert=True)
        return

    await upsert_user(target_id, status=Status.REJECTED.value)
    await bot.send_message(target_id, "Ğš Ñ�Ğ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ�, Ğ²Ğ°ÑˆĞ° Ğ·Ğ°Ñ�Ğ²ĞºĞ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ°. Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.")

    try:
        await call.message.edit_text(call.message.text + "\n\nâ�Œ Ğ�Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾")
    except Exception:
        pass
    await call.answer("Ğ�Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¾ â�Œ")
    await notify_review_outcome(target_id, "rejected")

# ======= Profile & Join Announce =======
@dp.message(or_f(F.text == "/profile", F.text == "profile"))
async def cmd_profile(message: Message):
    user = await get_user(message.from_user.id)
    if not user:
        await message.answer("ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Ğ�Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /start")
        return
    lines = ["<b>Ğ’Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ</b>"]
    for key in ("clan_id", "user_id", "nickname", "discord", "steamid", "birth_date", "age", "timezone", "tg_link", "faction", "status", "created_at", "applied_at", "approved_at", "joined_at"):
        val = user.get(key)
        if key == "clan_id":
            val = pad_clan_id(val)
        if val:
            lines.append(f"{key}: {val}")
    await message.answer("\n".join(lines))

@dp.message(F.chat.id == CLAN_CHAT_ID, F.new_chat_members)
async def on_user_joined_clan(message: Message):
    for member in message.new_chat_members:
        uid = member.id
        user = await get_user(uid)
        if user and user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
            now_iso = datetime.utcnow().isoformat()
            first_join = not user.get("joined_at")
            if first_join:
                await upsert_user(uid, status=Status.JOINED.value, joined_at=now_iso)
                user = await get_user(uid)
            nickname = user.get("nickname") or member.full_name
            await bot.send_message(CLAN_CHAT_ID, f"<b>{nickname}</b> Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ» Ğ² Ğ½Ğ°Ñˆ ĞºĞ»Ğ°Ğ½!")
            clanid = pad_clan_id(user.get("clan_id"))
            join_text = (
                f"<b>Ğ£Ñ‡Ğ°Ñ�Ñ‚Ğ½Ğ¸Ğº Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ» Ğ² ĞºĞ»Ğ°Ğ½</b>\n"
                f"ClanID: <code>{clanid}</code>\n"
                f"Telegram ID: <code>{uid}</code>\n"
                f"Ğ�Ğ¸Ğº: {nickname}\n"
                f"Discord: {user.get('discord') or '-'}\n"
                f"SteamID: {user.get('steamid') or '-'}\n"
                f"Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ�: {user.get('birth_date') or '-'}\n"
                f"Ğ’Ğ¾Ğ·Ñ€Ğ°Ñ�Ñ‚: {user.get('age') or '-'}\n"
                f"Ğ¤Ñ€Ğ°ĞºÑ†Ğ¸Ñ�: {user.get('faction') or '-'}\n"
                f"Ğ§Ğ°Ñ�Ğ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾Ñ�Ñ�: {user.get('timezone') or '-'}\n"
                f"Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ TG: {user.get('tg_link') or '-'}\n"
                f"Ğ”Ğ°Ñ‚Ğ° Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ñ�: {user.get('joined_at') or now_iso}"
            )
            await send_to_moderation(join_text)

@dp.message(F.new_chat_members)
async def on_user_joined_any(message: Message):
    if message.chat.id != CLAN_CHAT_ID:
        return
    await on_user_joined_clan(message)

# ======= Help & Stats =======
@dp.message(or_f(F.text == "/help", F.text == "help"))
async def cmd_help(message: Message):
    await message.answer(
        """ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:
/start â€” Ñ€ĞµĞ³Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ†Ğ¸Ñ�
/profile â€” Ğ²Ğ°Ñˆ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ
/player <user_id | @username | Ñ‡Ğ°Ñ�Ñ‚ÑŒ Ğ½Ğ¸ĞºĞ°> â€” Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¸Ğ³Ñ€Ğ¾ĞºĞ° (Ğ´Ğ»Ñ� Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ², Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸/ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ�)
/stats â€” Ğ°Ğ³Ñ€ĞµĞ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ñ‹ (Ğ´Ğ»Ñ� Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²)
"""
    )

async def get_stats(start: Optional[datetime], end: Optional[datetime]) -> str:
    params_created: list = []
    params_applied: list = []
    params_approved: list = []
    params_joined: list = []
    def range_cond(col: str, params_list: list):
        c = []
        if start:
            c.append(f"date({col}) >= date(?)")
            params_list.append(start.isoformat())
        if end:
            c.append(f"date({col}) <= date(?)")
            params_list.append(end.isoformat())
        return (" AND ".join(c)) if c else "1=1"
    cond_created = range_cond("created_at", params_created)
    cond_applied = range_cond("applied_at", params_applied)
    cond_approved = range_cond("approved_at", params_approved)
    cond_joined = range_cond("joined_at", params_joined)
    async with aiosqlite.connect(DB_PATH) as db:
        new_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE {cond_created}", params_created)).fetchone())[0]
        applied_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE applied_at IS NOT NULL AND {cond_applied}", params_applied)).fetchone())[0]
        approved_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE approved_at IS NOT NULL AND {cond_approved}", params_approved)).fetchone())[0]
        joined_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone())[0]
        total = (await (await db.execute("SELECT COUNT(1) FROM users")).fetchone())[0]
        pending = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.PENDING_REVIEW.value,))).fetchone())[0]
        approved_not_joined = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.APPROVED.value,))).fetchone())[0]
        joined_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.JOINED.value,))).fetchone())[0]
        rejected_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.REJECTED.value,))).fetchone())[0]
        avg_age_row = await (await db.execute(f"SELECT AVG(age) FROM users WHERE age IS NOT NULL AND joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone()
        avg_age = round(avg_age_row[0], 1) if avg_age_row and avg_age_row[0] is not None else None
        tz_rows = await (await db.execute(
            f"SELECT timezone, COUNT(1) c FROM users WHERE joined_at IS NOT NULL AND timezone IS NOT NULL AND {cond_joined} GROUP BY timezone ORDER BY c DESC LIMIT 5",
            params_joined,
        )).fetchall()
    lines = ["<b>Ğ�Ğ³Ñ€ĞµĞ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ñ‹</b>"]
    if start or end:
        lines.append(f"ĞŸĞµÑ€Ğ¸Ğ¾Ğ´: {start.date() if start else 'â€”'} â€” {end.date() if end else 'â€”'}")
    lines += [
        f"Ğ�Ğ¾Ğ²Ñ‹Ñ… Ñ�Ñ‚Ğ°Ñ€Ñ‚Ğ¾Ğ² /start: <b>{new_cnt}</b>",
        f"Ğ—Ğ°Ñ�Ğ²Ğ¾Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: <b>{applied_cnt}</b>",
        f"Ğ�Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ¾: <b>{approved_cnt}</b>",
        f"Ğ’Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ»Ğ¾: <b>{joined_cnt}</b>",
        "",
        "<b>Ğ’Ğ¾Ñ€Ğ¾Ğ½ĞºĞ° (Ğ²Ñ�ĞµĞ³Ğ¾):</b>",
        f"Ğ’Ñ�ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {total}",
        f"Ğ�Ğ° Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸: {pending}",
        f"Ğ�Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ñ‹ (Ğ½Ğµ Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ»Ğ¸): {approved_not_joined}",
        f"Ğ’Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ»Ğ¸: {joined_total}",
        f"Ğ�Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ñ‹: {rejected_total}",
    ]
    if avg_age is not None:
        lines.append(f"Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ²Ğ¾Ğ·Ñ€Ğ°Ñ�Ñ‚ (Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ²ÑˆĞ¸Ğµ Ğ² Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´): {avg_age}")
    if tz_rows:
        lines.append("Ğ¢Ğ¾Ğ¿ Ğ¿Ğ¾ Ñ‡Ğ°Ñ�Ğ¾Ğ²Ñ‹Ğ¼ Ğ¿Ğ¾Ñ�Ñ�Ğ°Ğ¼ (Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ²ÑˆĞ¸Ğµ):")
        for tz, c in tz_rows:
            lines.append(f"â€¢ {tz}: {c}")
    return "\n".join(lines)

def period_bounds(key: str):
    now = datetime.utcnow()
    if key == "today":
        start = datetime(now.year, now.month, now.day)
        end = now
    elif key == "7d":
        end = now
        start = now - timedelta(days=7)
    elif key == "30d":
        end = now
        start = now - timedelta(days=30)
    else:
        start = None
        end = None
    return start, end

def stats_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½Ñ�", callback_data="stats:today")
    kb.button(text="7 Ğ´Ğ½ĞµĞ¹", callback_data="stats:7d")
    kb.button(text="30 Ğ´Ğ½ĞµĞ¹", callback_data="stats:30d")
    kb.button(text="Ğ—Ğ° Ğ²Ñ�Ñ‘ Ğ²Ñ€ĞµĞ¼Ñ�", callback_data="stats:all")
    kb.button(text="CSV (Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ²ÑˆĞ¸Ğµ 30Ğ´)", callback_data="export:joined:30d")
    kb.button(text="CSV (Ğ²Ñ�Ğµ Ğ·Ğ° 30Ğ´)", callback_data="export:all:30d")
    return kb.as_markup()

@dp.message(F.text == "/stats")
async def cmd_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹.")
        return
    await message.answer("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´ Ğ´Ğ»Ñ� Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ğ°:", reply_markup=stats_kb())

@dp.callback_query(F.data.startswith("stats:"))
async def on_stats(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹", show_alert=True)
        return
    key = call.data.split(":")[1]
    start, end = period_bounds(key)
    text = await get_stats(start, end)
    await call.message.edit_text(text, reply_markup=stats_kb())

async def export_csv(kind: str, start: Optional[datetime], end: Optional[datetime]) -> str:
    cond_col = {"joined": "joined_at", "all": "created_at"}[kind]
    params = []
    where = []
    if start:
        where.append(f"date({cond_col}) >= date(?)")
        params.append(start.isoformat())
    if end:
        where.append(f"date({cond_col}) <= date(?)")
        params.append(end.isoformat())
    if kind == "joined":
        where.append("joined_at IS NOT NULL")
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT clan_id, user_id, nickname, discord, steamid, age, birth_date, timezone, tg_link, phone, faction, status, created_at, applied_at, approved_at, joined_at FROM users WHERE {where}".format(where=where_sql),
            params,
        )
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
    fname = f"bb_report_{kind}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
    import csv
    with open(fname, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(cols)
        writer.writerows(rows)
    return fname

@dp.callback_query(F.data.startswith("export:"))
async def on_export(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹", show_alert=True)
        return
    _, kind, key = call.data.split(":")
    start, end = period_bounds(key)
    path = await export_csv(kind, start, end)
    await bot.send_document(call.from_user.id, FSInputFile(path))
    await call.answer("CSV Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ñ�Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ�.")

# ======= Players list (admins/mods) =======
PAGE_SIZE = 10

def players_nav_kb(filter_type: str, filter_value: str, page: int, has_prev: bool, has_next: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    if has_prev:
        kb.button(text="â—€ï¸� Ğ�Ğ°Ğ·Ğ°Ğ´", callback_data=f"players:{filter_type}:{filter_value}:{page-1}")
    if has_next:
        kb.button(text="Ğ”Ğ°Ğ»ĞµĞµ â–¶ï¸�", callback_data=f"players:{filter_type}:{filter_value}:{page+1}")
    kb.row()
    kb.button(text=("â€¢ Ğ’Ñ�Ğµ" if filter_type=="all" else "Ğ’Ñ�Ğµ"), callback_data="players:all::1")
    kb.button(text=("â€¢ Ğ’Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ»Ğ¸" if filter_type=="joined" else "Ğ’Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ»Ğ¸"), callback_data="players:joined::1")
    kb.button(text=("â€¢ Ğ¤Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸" if filter_type=="faction" else "Ğ¤Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸"), callback_data=f"players:choose_faction::{page}")
    return kb.as_markup()

def players_factions_kb(page: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("cran","Cranberry"),("blue","Blueberry"),("water","Watermelon")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("recruit","Ğ ĞµĞºÑ€ÑƒÑ‚"),("reserve","Ğ ĞµĞ·ĞµÑ€Ğ²"),("command","ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    kb.button(text="â¬…ï¸� Ğ�Ğ°Ğ·Ğ°Ğ´ (Ğ²Ñ�Ğµ)", callback_data="players:all::1")
    return kb.as_markup()

async def fetch_players(filter_type: str, filter_value: str, page: int):
    offset = (page-1)*PAGE_SIZE
    where = []
    params = []
    where.append("(status IS NULL OR status != ?)")
    params.append("removed")
    if filter_type == "joined":
        where.append("status = ?")
        params.append("joined")
    elif filter_type == "faction" and filter_value:
        where.append("faction = ?")
        params.append(filter_value)
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(f"SELECT COUNT(1) FROM users WHERE {where_sql}", params)
        total = (await cur.fetchone())[0]
        cur = await db.execute(
            f"""SELECT clan_id, user_id, nickname, faction, status
                FROM users
                WHERE {where_sql}
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?""",
            params + [PAGE_SIZE, offset]
        )
        rows = await cur.fetchall()
    has_next = (offset + PAGE_SIZE) < total
    has_prev = page > 1
    return rows, has_prev, has_next, total

def format_players_list(rows, page: int, total: int, filter_type: str, filter_value: str) -> str:
    title_map = {
        "all": "Ğ¡Ğ¿Ğ¸Ñ�Ğ¾Ğº Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ² (Ğ²Ñ�Ğµ, ĞºÑ€Ğ¾Ğ¼Ğµ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½Ğ½Ñ‹Ñ…)",
        "joined": "Ğ¡Ğ¿Ğ¸Ñ�Ğ¾Ğº Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ² (Ğ²Ñ�Ñ‚ÑƒĞ¿Ğ¸Ğ²ÑˆĞ¸Ğµ)",
        "faction": f"Ğ¡Ğ¿Ğ¸Ñ�Ğ¾Ğº Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ² (Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ñ�: {filter_value})" if filter_value else "Ğ¡Ğ¿Ğ¸Ñ�Ğ¾Ğº Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ² (Ğ¿Ğ¾ Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸)"
    }
    lines = [f"<b>{title_map.get(filter_type, 'Ğ¡Ğ¿Ğ¸Ñ�Ğ¾Ğº Ğ¸Ğ³Ñ€Ğ¾ĞºĞ¾Ğ²')}</b>"]
    lines.append(f"Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° {page} â€¢ Ğ²Ñ�ĞµĞ³Ğ¾ Ğ·Ğ°Ğ¿Ğ¸Ñ�ĞµĞ¹: {total}")
    if not rows:
        lines.append("â€” Ğ¿ÑƒÑ�Ñ‚Ğ¾ â€”")
    else:
        for idx, (clan_id, user_id, nickname, faction, status) in enumerate(rows, 1):
            cid = f"{int(clan_id):04d}" if clan_id else "â€”"
            nick = nickname or "-"
            fac = faction or "-"
            st = status or "-"
            lines.append(f"{idx:>2}. {cid} â€” {nick} ({fac}) â€” {st} â€” ID: <code>{user_id}</code>")
    lines.append("\nĞ�Ñ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ: /player &lt;ID&gt;")
    return "\n".join(lines)

@dp.message(Command("players"))
async def cmd_players(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹.")
        return
    filter_type = "all"
    filter_value = ""
    page = 1
    rows, has_prev, has_next, total = await fetch_players(filter_type, filter_value, page)
    text = format_players_list(rows, page, total, filter_type, filter_value)
    await message.answer(text, reply_markup=players_nav_kb(filter_type, filter_value, page, has_prev, has_next))

@dp.callback_query(F.data.startswith("players:choose_faction"))
async def on_players_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹", show_alert=True)
        return
    await call.message.edit_text("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ„Ñ€Ğ°ĞºÑ†Ğ¸Ñ�:", reply_markup=players_factions_kb(1))
    await call.answer()

@dp.callback_query(F.data.startswith("players:"))
async def on_players_list(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹/Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸Ñ�Ñ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñ‹", show_alert=True)
        return
    try:
        _, ftype, fvalue, page_str = call.data.split(":", 3)
        page = int(page_str or "1")
        ftype = ftype or "all"
        fvalue = fvalue or ""
    except Exception:
        await call.answer("Ğ�ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹.", show_alert=True)
        return
    rows, has_prev, has_next, total = await fetch_players(ftype, fvalue, page)
    text = format_players_list(rows, page, total, ftype, fvalue)
    try:
        await call.message.edit_text(text, reply_markup=players_nav_kb(ftype, fvalue, page, has_prev, has_next))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:final:"))
async def on_remove_final(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Ğ�ĞµĞ´Ğ¾Ñ�Ñ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ².", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    # check all steps complete
    done_db, done_tg, done_disc = await removal_state(target_id)
    if not (done_db and done_tg and done_disc):
        await call.answer("Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ Ğ²Ñ�Ğµ Ñ‚Ñ€Ğ¸ ÑˆĞ°Ğ³Ğ° Ñ‡ĞµĞº-Ğ»Ğ¸Ñ�Ñ‚Ğ°.", show_alert=True)
        return
    # hard delete from users and archive
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM users WHERE user_id=?", (target_id,))
        await db.execute("DELETE FROM users_archive WHERE user_id=?", (target_id,))
        await db.execute("DELETE FROM removal_checklist WHERE user_id=?", (target_id,))
        await db.commit()
    await call.answer("Ğ˜Ğ³Ñ€Ğ¾Ğº Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ�Ñ‚ÑŒÑ� ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¸Ğ· Ğ±Ğ°Ğ·Ñ‹ Ğ±Ğ¾Ñ‚Ğ°.", show_alert=True)
    try:
        await call.message.edit_text("<b>Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾.</b> Ğ˜Ğ³Ñ€Ğ¾Ğº Ñ�Ñ‚ĞµÑ€Ñ‘Ğ½ Ğ¸Ğ· Ğ±Ğ°Ğ·Ñ‹.")
    except Exception:
        pass

async def main():
    await init_db()
    logging.info("DB initialized at %s", DB_PATH)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
