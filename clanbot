"""
Aiogram 3.x Telegram bot for clan 'Blackberry' (updated)
–ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏:
- –î–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ–ª—è `name` –∏ `age` –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: —Å–±–æ—Ä –Ω–æ–º–µ—Ä–∞ (—á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É), –∏–º–µ–Ω–∏ (—Ç–µ–∫—Å—Ç), –≤–æ–∑—Ä–∞—Å—Ç–∞ (—á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –∏–ª–∏ —Ä—É—á–Ω–æ–π –≤–≤–æ–¥), –Ω–∏–∫–∞, Discord, SteamID, —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞
- –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –≤—Å–µ –ø–æ–¥–ø–∏—Å–∏ –∫–Ω–æ–ø–æ–∫ ‚Äî –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ
- –í—Å—è –æ—Å–Ω–æ–≤–Ω–∞—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –∏ —á–∞—Å—Ç—å –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏ (–≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é, –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—Å–∫–æ–µ –º–µ–Ω—é, –ø—Ä–æ—Å–º–æ—Ç—Ä —É—á–∞—Å—Ç–Ω–∏–∫–∞, –ø—Ä–∏–Ω—è—Ç–∏–µ –∑–∞—è–≤–æ–∫ –∏ —Ç.–¥.)
- –¢–∞–±–ª–∏—Ü–∞ –ë–î —Ä–∞—Å—à–∏—Ä–µ–Ω–∞, –¥–æ–±–∞–≤–ª–µ–Ω—ã –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ ALTER TABLE –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞—Ç—ã –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è, —É—á—ë—Ç —Ä–µ–∑–µ—Ä–≤–∞, —Ñ—Ä–∞–∫—Ü–∏–π –∏ —Ä–æ–ª–µ–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω
- –û–ø—Ä–æ—Å—ã –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ‚Äî –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –ª–æ–≥–∏–∫–µ, –∫–Ω–æ–ø–∫–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º

–í–ê–ñ–ù–û: –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–æ–ª—è (BOT_TOKEN, ADMIN_IDS, CHANNEL_USERNAMES, CLAN_CHAT_INVITE_LINK) –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º.

–ó–∞–ø—É—Å–∫: python blackberry_bot.py
–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: aiogram aiosqlite APScheduler pytz
"""

import asyncio
import logging
import aiosqlite
from datetime import datetime, date, timedelta
from typing import List, Optional

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command, Text
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import ChatMemberUpdated

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
import pytz

# --------------------------- CONFIG ---------------------------
BOT_TOKEN = "REPLACE_WITH_YOUR_BOT_TOKEN"
ADMIN_IDS: List[int] = [123456789]
MODERATOR_IDS: List[int] = []
CHANNEL_USERNAMES = ["@blackberry_diary", "@blackberry_info", "@blackberry_news"]
CLAN_CHAT_INVITE_LINK = "https://t.me/+example_invite_link"
CLAN_CHAT_ID: Optional[int] = None
DB_PATH = "blackberry_bot.db"
MSK_TZ = pytz.timezone("Europe/Moscow")
# --------------------------------------------------------------

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# --------------------------- FSM -------------------------------
class Registration(StatesGroup):
    await_contact = State()
    ask_name = State()
    ask_age_buttons = State()
    ask_age_manual = State()
    ask_nick = State()
    ask_discord = State()
    ask_steam = State()
    ask_timezone = State()

class AttendanceReason(StatesGroup):
    waiting_reason = State()

class ModeratorFlow(StatesGroup):
    awaiting_member_for_action = State()

# --------------------------- DB helpers ------------------------
async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
        CREATE TABLE IF NOT EXISTS members (
            tg_id INTEGER PRIMARY KEY,
            phone TEXT,
            name TEXT,
            age INTEGER,
            nick TEXT,
            discord TEXT,
            steamid TEXT,
            timezone TEXT,
            factions TEXT,
            roles TEXT,
            is_reserve INTEGER DEFAULT 0,
            join_date TEXT
        )
        """)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS approvals (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER,
            requested_at TEXT,
            status TEXT,
            reviewer_id INTEGER,
            comment TEXT
        )
        """)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS attendance (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER,
            date TEXT,
            answer TEXT,
            reason TEXT
        )
        """)
        await db.commit()
        # backward-compatible: try adding columns if missing
        try:
            await db.execute("ALTER TABLE members ADD COLUMN name TEXT")
            await db.execute("ALTER TABLE members ADD COLUMN age INTEGER")
            await db.commit()
        except Exception:
            # columns probably already exist
            pass

async def save_member(tg_id: int, phone: str, name: str, age: Optional[int], nick: str, discord: str, steamid: str, timezone: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO members (tg_id, phone, name, age, nick, discord, steamid, timezone, factions, roles, join_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (tg_id, phone, name, age, nick, discord, steamid, timezone, '', '', None))
        await db.commit()

async def set_member_join_date(tg_id: int, join_date: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE members SET join_date = ? WHERE tg_id = ?", (join_date, tg_id))
        await db.commit()

async def member_exists(tg_id: int) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT 1 FROM members WHERE tg_id = ?", (tg_id,))
        r = await cur.fetchone()
        return r is not None

async def list_members() -> List[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT tg_id, name, nick, factions, roles, is_reserve, join_date FROM members")
        rows = await cur.fetchall()
        return [dict(tg_id=row[0], name=row[1], nick=row[2], factions=row[3], roles=row[4], is_reserve=row[5], join_date=row[6]) for row in rows]

async def get_member(tg_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM members WHERE tg_id = ?", (tg_id,))
        r = await cur.fetchone()
        if not r:
            return None
        cols = [c[0] for c in cur.description]
        return dict(zip(cols, r))

async def update_member_fields(tg_id:int, **fields):
    if not fields:
        return
    keys = ", ".join([f"{k} = ?" for k in fields.keys()])
    vals = list(fields.values())
    vals.append(tg_id)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(f"UPDATE members SET {keys} WHERE tg_id = ?", vals)
        await db.commit()

async def add_approval_request(tg_id:int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO approvals (tg_id, requested_at, status) VALUES (?, ?, 'pending')", (tg_id, datetime.utcnow().isoformat()))
        await db.commit()

async def get_pending_approvals() -> List[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT a.tg_id, m.nick, m.name FROM approvals a LEFT JOIN members m ON a.tg_id = m.tg_id WHERE a.status = 'pending'")
        rows = await cur.fetchall()
        return [{'tg_id': r[0], 'nick': r[1], 'name': r[2]} for r in rows]

async def set_approval_status(tg_id:int, status:str, reviewer_id:int, comment:Optional[str]=None):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE approvals SET status = ?, reviewer_id = ?, comment = ? WHERE tg_id = ? AND status = 'pending'", (status, reviewer_id, comment, tg_id))
        await db.commit()

async def record_attendance(tg_id:int, for_date: date, answer: str, reason: Optional[str]=None):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO attendance (tg_id, date, answer, reason) VALUES (?, ?, ?, ?)", (tg_id, for_date.isoformat(), answer, reason))
        await db.commit()

async def attendance_stats_for_user(tg_id:int, since: date):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT date, answer FROM attendance WHERE tg_id = ? AND date >= ?", (tg_id, since.isoformat()))
        rows = await cur.fetchall()
        return rows

async def attendance_summary_for_date(the_date: date):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT answer, COUNT(*) FROM attendance WHERE date = ? GROUP BY answer", (the_date.isoformat(),))
        rows = await cur.fetchall()
        return {r[0]: r[1] for r in rows}

async def unanswered_members_for_date(the_date: date):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT tg_id, nick FROM members WHERE tg_id NOT IN (SELECT tg_id FROM attendance WHERE date = ?)", (the_date.isoformat(),))
        rows = await cur.fetchall()
        return [{'tg_id': r[0], 'nick': r[1]} for r in rows]

async def consecutive_nonanswers(days:int=3):
    today = date.today()
    dates = [(today - timedelta(days=i)).isoformat() for i in range(days)]
    async with aiosqlite.connect(DB_PATH) as db:
        placeholders = ','.join('?' for _ in dates)
        cur = await db.execute(f"SELECT tg_id, nick FROM members WHERE tg_id NOT IN (SELECT tg_id FROM attendance WHERE date IN ({placeholders}))", dates)
        rows = await cur.fetchall()
        return [{'tg_id': r[0], 'nick': r[1]} for r in rows]

# --------------------------- Util -------------------------------
def is_admin(user_id:int) -> bool:
    return user_id in ADMIN_IDS

def is_moderator(user_id:int) -> bool:
    return user_id in MODERATOR_IDS or is_admin(user_id)

# --------------------------- Handlers ---------------------------
@dp.message(Command(commands=["start"]))
async def cmd_start(message: types.Message, state: FSMContext):
    kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞", request_contact=True)]], resize_keyboard=True)
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–ª–∞–Ω Blackberry! –ß—Ç–æ–±—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞.", reply_markup=kb)
    await state.set_state(Registration.await_contact)

@dp.message(Registration.await_contact, F.contact)
async def contact_received(message: types.Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –ø–æ–ª–Ω–æ–µ –∏–º—è:", reply_markup=ReplyKeyboardRemove())
    await state.set_state(Registration.ask_name)

@dp.message(Registration.await_contact)
async def ask_contact_again(message: types.Message):
    kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞", request_contact=True)]], resize_keyboard=True)
    await message.answer("–ù–∞–º –Ω—É–∂–µ–Ω –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ ‚Äî –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –∫–æ–Ω—Ç–∞–∫—Ç–æ–º.", reply_markup=kb)

@dp.message(Registration.ask_name)
async def name_received(message: types.Message, state: FSMContext):
    name = message.text.strip()
    await state.update_data(name=name)
    # Send age selection keyboard (13..60)
    inline_keyboard = []
    row = []
    for age_val in range(13, 61):
        row.append(InlineKeyboardButton(text=str(age_val), callback_data=f"age:{age_val}"))
        if len(row) == 6:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.append([InlineKeyboardButton(text="–í–≤–µ—Å—Ç–∏ –≤—Ä—É—á–Ω—É—é", callback_data="age:manual")])
    kb = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à –≤–æ–∑—Ä–∞—Å—Ç (–Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É) –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –≤—Ä—É—á–Ω—É—é:", reply_markup=kb)
    await state.set_state(Registration.ask_age_buttons)

@dp.callback_query(Text(startswith="age:"))
async def cb_age_select(callback: types.CallbackQuery, state: FSMContext):
    data = callback.data.split(":",1)[1]
    if data == 'manual':
        await callback.message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–∑—Ä–∞—Å—Ç —Ü–∏—Ñ—Ä–∞–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 25)")
        await state.set_state(Registration.ask_age_manual)
        await callback.answer()
        return
    try:
        age = int(data)
    except Exception:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç.", show_alert=True)
        return
    await state.update_data(age=age)
    await callback.message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫ (–∏–º—è –≤ –∫–ª–∞–Ω–µ):")
    await state.set_state(Registration.ask_nick)
    await callback.answer()

@dp.message(Registration.ask_age_manual)
async def age_manual_received(message: types.Message, state: FSMContext):
    txt = message.text.strip()
    try:
        age = int(txt)
    except ValueError:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–æ–∑—Ä–∞—Å—Ç —Ü–∏—Ñ—Ä–∞–º–∏.")
        return
    await state.update_data(age=age)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫ (–∏–º—è –≤ –∫–ª–∞–Ω–µ):")
    await state.set_state(Registration.ask_nick)

@dp.message(Registration.ask_nick)
async def nick_received(message: types.Message, state: FSMContext):
    nick = message.text.strip()
    await state.update_data(nick=nick)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Discord (–Ω–∞–ø—Ä–∏–º–µ—Ä: –Ω–∏–∫#1234):")
    await state.set_state(Registration.ask_discord)

@dp.message(Registration.ask_discord)
async def discord_received(message: types.Message, state: FSMContext):
    discord = message.text.strip()
    await state.update_data(discord=discord)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à SteamID (–∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –ø—Ä–æ—Ñ–∏–ª—å):")
    await state.set_state(Registration.ask_steam)

@dp.message(Registration.ask_steam)
async def steam_received(message: types.Message, state: FSMContext):
    steam = message.text.strip()
    await state.update_data(steamid=steam)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä: Europe/Moscow –∏–ª–∏ UTC+3):")
    await state.set_state(Registration.ask_timezone)

@dp.message(Registration.ask_timezone)
async def timezone_received(message: types.Message, state: FSMContext):
    tz = message.text.strip()
    data = await state.get_data()
    phone = data.get('phone')
    name = data.get('name')
    age = data.get('age')
    nick = data.get('nick')
    discord = data.get('discord')
    steamid = data.get('steamid')
    tg_id = message.from_user.id

    # Save member provisional data
    await save_member(tg_id, phone, name, age, nick, discord, steamid, tz)

    # Send links to publics and buttons to recheck subscription
    text = "–°–ø–∞—Å–∏–±–æ! –ß—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à–∏ –ø–∞–±–ª–∏–∫–∏: 
"
    for ch in CHANNEL_USERNAMES:
        text += f"{ch}
"
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data=f"checksub:{tg_id}"), InlineKeyboardButton(text="–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É", callback_data=f"request_review:{tg_id}")]
    ])
    await message.answer(text, reply_markup=kb)

    # Add approval request and initial check
    await add_approval_request(tg_id)

    await message.answer("–ú—ã —É–≤–µ–¥–æ–º–∏–ª–∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–∞—à–µ–π –∑–∞—è–≤–∫–∏. –û–∂–∏–¥–∞–π—Ç–µ –æ–¥–æ–±—Ä–µ–Ω–∏—è.")
    await state.clear()

@dp.callback_query(Text(startswith="checksub:"))
async def cb_check_subscription(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    ok = await check_subscriptions(tg_id)
    if ok:
        await callback.answer("–ü–æ–¥–ø–∏—Å–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ.")
    else:
        await callback.answer("–ù–µ –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–µ –ø–∞–±–ª–∏–∫–∏.")

@dp.callback_query(Text(startswith="request_review:"))
async def cb_request_review(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    mem = await get_member(tg_id)
    nick = mem.get('nick') if mem else str(tg_id)
    subs_ok = await check_subscriptions(tg_id)
    await notify_reviewers_of_request(tg_id, nick, subs_ok)
    await callback.answer("–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º.")

async def check_subscriptions(tg_id: int) -> bool:
    ok = True
    for ch in CHANNEL_USERNAMES:
        try:
            member = await bot.get_chat_member(ch, tg_id)
            status = member.status
            if status in ("left", "kicked"):
                ok = False
        except Exception as e:
            logger.warning(f"Failed to verify subscription for {ch}: {e}")
            ok = False
    return ok

async def notify_reviewers_of_request(tg_id:int, nick:str, subs_ok:bool):
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–û–¥–æ–±—Ä–∏—Ç—å", callback_data=f"approve:{tg_id}"), InlineKeyboardButton(text="–û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject:{tg_id}")]
    ])
    text = f"–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞: {nick} (ID {tg_id})
–ü–æ–¥–ø–∏—Å–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ: {subs_ok}
–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –æ–¥–æ–±—Ä–µ–Ω–∏—è/–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è."
    recipients = set(ADMIN_IDS + MODERATOR_IDS)
    for r in recipients:
        try:
            await bot.send_message(r, text, reply_markup=inline)
        except Exception as e:
            logger.exception(f"Failed to notify reviewer {r}: {e}")

# Callback handlers for approval
@dp.callback_query(Text(startswith="approve:"))
async def cb_approve(callback: types.CallbackQuery):
    user = callback.from_user
    if not is_moderator(user.id):
        await callback.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    await set_approval_status(tg_id, 'approved', user.id)
    try:
        await bot.send_message(tg_id, f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞! –°—Å—ã–ª–∫–∞ –Ω–∞ —á–∞—Ç: {CLAN_CHAT_INVITE_LINK}")
    except Exception as e:
        logger.warning(f"Could not send invite to {tg_id}: {e}")
    await callback.message.edit_text(callback.message.text + f"
–û–¥–æ–±—Ä–µ–Ω–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º {user.full_name}")
    await callback.answer("–ó–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞.")

@dp.callback_query(Text(startswith="reject:"))
async def cb_reject(callback: types.CallbackQuery):
    user = callback.from_user
    if not is_moderator(user.id):
        await callback.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω—ã –º–æ–≥—É—Ç –æ—Ç–∫–ª–æ–Ω—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    await set_approval_status(tg_id, 'rejected', user.id)
    await bot.send_message(tg_id, "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞. –î–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏–π —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–µ–π.")
    await callback.message.edit_text(callback.message.text + f"
–û—Ç–∫–ª–æ–Ω–µ–Ω–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º {user.full_name}")
    await callback.answer("–ó–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")

# Detect when member joins the clan chat and announce
@dp.chat_member()
async def chat_member_update(event: ChatMemberUpdated):
    try:
        if CLAN_CHAT_ID and event.chat.id != CLAN_CHAT_ID:
            return
        old = event.old_chat_member
        new = event.new_chat_member
        user = event.from_user
        if old.status in ("left", "kicked") and new.status in ("member", "administrator", "creator"):
            info = await get_member(user.id)
            nick = info['nick'] if info else user.full_name
            await event.bot.send_message(event.chat.id, f"{nick} –≤—Å—Ç—É–ø–∏–ª –≤ –Ω–∞—à –∫–ª–∞–Ω!")
            await set_member_join_date(user.id, datetime.utcnow().isoformat())
    except Exception as e:
        logger.exception(f"chat_member_update error: {e}")

# --------------------------- Menu and moderator flows --------------
@dp.message(Command(commands=["menu"]))
async def cmd_menu(message: types.Message):
    user_id = message.from_user.id
    kb = InlineKeyboardMarkup(inline_keyboard=[])
    # Common user buttons
    kb.inline_keyboard.append([InlineKeyboardButton(text="–ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å", callback_data=f"profile:{user_id}"), InlineKeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data=f"checksub:{user_id}")])
    kb.inline_keyboard.append([InlineKeyboardButton(text="–ü–æ–≤—Ç–æ—Ä–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É", callback_data=f"request_review:{user_id}")])
    # Moderator-specific
    if is_moderator(user_id):
        kb.inline_keyboard.append([InlineKeyboardButton(text="üõ† –û–¥–æ–±—Ä–∏—Ç—å –∑–∞—è–≤–∫–∏", callback_data="approve_requests")])
        kb.inline_keyboard.append([InlineKeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤", callback_data="list_members_cb")])
    # Admin-specific
    if is_admin(user_id):
        kb.inline_keyboard.append([InlineKeyboardButton(text="‚≠ê –î–æ–±–∞–≤–∏—Ç—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞", callback_data="promote_member")])
    await message.answer("–ú–µ–Ω—é:", reply_markup=kb)

@dp.callback_query(Text(equals="approve_requests"))
async def cb_approve_requests(callback: types.CallbackQuery):
    if not is_moderator(callback.from_user.id):
        await callback.answer("–î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º.", show_alert=True)
        return
    pending = await get_pending_approvals()
    if not pending:
        await callback.answer("–ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –∑–∞—è–≤–æ–∫.")
        return
    for p in pending:
        tg_id = p['tg_id']
        nick = p.get('nick') or p.get('name') or str(tg_id)
        inline = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="–û–¥–æ–±—Ä–∏—Ç—å", callback_data=f"approve:{tg_id}"), InlineKeyboardButton(text="–û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject:{tg_id}")]
        ])
        await callback.message.answer(f"–ó–∞—è–≤–∫–∞: {nick} (ID {tg_id})", reply_markup=inline)
    await callback.answer()

@dp.callback_query(Text(equals="list_members_cb"))
async def cb_list_members(callback: types.CallbackQuery):
    if not is_moderator(callback.from_user.id):
        await callback.answer("–î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º.", show_alert=True)
        return
    rows = await list_members()
    if not rows:
        await callback.message.answer("–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.")
        return
    # build inline keyboard with small pages (here simply list up to 50)
    kb_lines = []
    for r in rows:
        label = f"{r['nick'] or '–±–µ–∑ –Ω–∏–∫–∞'} ({r['tg_id']})"
        kb_lines.append([InlineKeyboardButton(text=label, callback_data=f"view_member:{r['tg_id']}")])
    kb = InlineKeyboardMarkup(inline_keyboard=kb_lines)
    await callback.message.answer("–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ (–Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞):", reply_markup=kb)
    await callback.answer()

@dp.callback_query(Text(startswith="view_member:"))
async def cb_view_member(callback: types.CallbackQuery):
    if not is_moderator(callback.from_user.id):
        await callback.answer("–î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    member = await get_member(tg_id)
    if not member:
        await callback.answer("–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    text = f"–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–µ:
ID: {member.get('tg_id')}
–ò–º—è: {member.get('name')}
–í–æ–∑—Ä–∞—Å—Ç: {member.get('age')}
–ù–∏–∫: {member.get('nick')}
Discord: {member.get('discord')}
SteamID: {member.get('steamid')}
–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {member.get('timezone')}
–§—Ä–∞–∫—Ü–∏–∏: {member.get('factions')}
–î–æ–ª–∂–Ω–æ—Å—Ç–∏: {member.get('roles')}
–†–µ–∑–µ—Ä–≤: {member.get('is_reserve')}
–î–∞—Ç–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {member.get('join_date')}"
    # action buttons
    actions = []
    actions.append(InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å —Ñ—Ä–∞–∫—Ü–∏—é", callback_data=f"add_faction_to:{tg_id}"))
    actions.append(InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ", callback_data=f"add_division_to:{tg_id}"))
    actions.append(InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å –≤ —Ä–µ–∑–µ—Ä–≤", callback_data=f"to_reserve_cb:{tg_id}"))
    actions.append(InlineKeyboardButton(text="–£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞", callback_data=f"remove_member_cb:{tg_id}"))
    row_actions = [actions[i:i+2] for i in range(0, len(actions), 2)]
    kb = InlineKeyboardMarkup(inline_keyboard=row_actions)
    # admin extra
    if is_admin(callback.from_user.id):
        kb.inline_keyboard.append([InlineKeyboardButton(text="–ù–∞–∑–Ω–∞—á–∏—Ç—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º", callback_data=f"promote_to_mod:{tg_id}"), InlineKeyboardButton(text="–°–Ω—è—Ç—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞", callback_data=f"demote_from_mod:{tg_id}")])
    await callback.message.answer(text, reply_markup=kb)
    await callback.answer()

# Add faction flow
@dp.callback_query(Text(startswith="add_faction_to:"))
async def cb_add_faction_to(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    factions = ["Blueberry", "Cranberry", "Watermelon", "–†–µ–∫—Ä—É—Ç", "–†–µ–∑–µ—Ä–≤"]
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=f, callback_data=f"set_faction:{tg_id}:{f}") for f in factions[:3]]])
    kb.inline_keyboard.append([InlineKeyboardButton(text=factions[3], callback_data=f"set_faction:{tg_id}:{factions[3]}"), InlineKeyboardButton(text=factions[4], callback_data=f"set_faction:{tg_id}:{factions[4]}")])
    await callback.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ—Ä–∞–∫—Ü–∏—é:", reply_markup=kb)
    await callback.answer()

@dp.callback_query(Text(startswith="set_faction:"))
async def cb_set_faction(callback: types.CallbackQuery):
    _, rest = callback.data.split(':',1)
    tg_id_str, faction = rest.split(':',1)
    tg_id = int(tg_id_str)
    mem = await get_member(tg_id)
    if not mem:
        await callback.answer("–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    factions = mem.get('factions') or ''
    if faction in (f.strip() for f in (factions or '').split(',')):
        await callback.answer("–§—Ä–∞–∫—Ü–∏—è —É–∂–µ —É–∫–∞–∑–∞–Ω–∞.")
        return
    new = (factions + ',' + faction).strip(',') if factions else faction
    await update_member_fields(tg_id, factions=new)
    await callback.answer(f"–§—Ä–∞–∫—Ü–∏—è '{faction}' –¥–æ–±–∞–≤–ª–µ–Ω–∞.")

# Add division flow (roles)
@dp.callback_query(Text(startswith="add_division_to:"))
async def cb_add_division_to(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    roles = ["–ö–æ–º–∞–Ω–¥–∏—Ä —Ñ—Ä–∞–∫—Ü–∏–∏", "–û—Ñ–∏—Ü–µ—Ä", "–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞", "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞", "HR"]
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=r, callback_data=f"set_role:{tg_id}:{r}")] for r in roles])
    await callback.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ–ª–∂–Ω–æ—Å—Ç—å (–Ω–∞–∂–∞—Ç–∏–µ –¥–æ–±–∞–≤–∏—Ç –¥–æ–ª–∂–Ω–æ—Å—Ç—å):", reply_markup=kb)
    await callback.answer()

@dp.callback_query(Text(startswith="set_role:"))
async def cb_set_role(callback: types.CallbackQuery):
    _, rest = callback.data.split(':',1)
    tg_id_str, role = rest.split(':',1)
    tg_id = int(tg_id_str)
    mem = await get_member(tg_id)
    if not mem:
        await callback.answer("–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    roles = mem.get('roles') or ''
    if role in (r.strip() for r in (roles or '').split(',')):
        await callback.answer("–î–æ–ª–∂–Ω–æ—Å—Ç—å —É–∂–µ —É–∫–∞–∑–∞–Ω–∞.")
        return
    new = (roles + ',' + role).strip(',') if roles else role
    await update_member_fields(tg_id, roles=new)
    await callback.answer(f"–î–æ–ª–∂–Ω–æ—Å—Ç—å '{role}' –¥–æ–±–∞–≤–ª–µ–Ω–∞.")

# To reserve
@dp.callback_query(Text(startswith="to_reserve_cb:"))
async def cb_to_reserve(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    await update_member_fields(tg_id, is_reserve=1)
    await callback.answer("–£—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Ä–µ–∑–µ—Ä–≤.")

# Remove member
@dp.callback_query(Text(startswith="remove_member_cb:"))
async def cb_remove_member(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM members WHERE tg_id = ?", (tg_id,))
        await db.commit()
    await callback.answer("–£—á–∞—Å—Ç–Ω–∏–∫ —É–¥–∞–ª—ë–Ω –∏–∑ –±–∞–∑—ã.")

# Promote/demote moderator
@dp.callback_query(Text(startswith="promote_to_mod:"))
async def cb_promote_to_mod(callback: types.CallbackQuery):
    if not is_admin(callback.from_user.id):
        await callback.answer("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –Ω–∞–∑–Ω–∞—á–∞—Ç—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    if tg_id not in MODERATOR_IDS:
        MODERATOR_IDS.append(tg_id)
    await callback.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∑–Ω–∞—á–µ–Ω –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º.")

@dp.callback_query(Text(startswith="demote_from_mod:"))
async def cb_demote_from_mod(callback: types.CallbackQuery):
    if not is_admin(callback.from_user.id):
        await callback.answer("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç —Å–Ω–∏–º–∞—Ç—å –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    if tg_id in MODERATOR_IDS:
        MODERATOR_IDS.remove(tg_id)
    await callback.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ª–∏—à—ë–Ω —Å—Ç–∞—Ç—É—Å–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞.")

# --------------------------- Moderator/Admin commands (backwards compatible) ------------------
@dp.message(Command(commands=["list_members"]))
async def cmd_list_members(message: types.Message):
    if not is_moderator(message.from_user.id):
        await message.reply("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.")
        return
    rows = await list_members()
    if not rows:
        await message.reply("–ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.")
        return
    text = "–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:
"
    for r in rows:
        text += f"ID: {r['tg_id']} ‚Äî {r['nick']} ‚Äî —Ñ—Ä–∞–∫—Ü–∏–∏:{r['factions']} ‚Äî –¥–æ–ª–∂–Ω–æ—Å—Ç–∏:{r['roles']} ‚Äî —Ä–µ–∑–µ—Ä–≤:{r['is_reserve']} ‚Äî joined:{r['join_date']}
"
    await message.reply(text)

# --------------------------- Attendance survey ----------------------
async def send_daily_survey():
    logger.info("–û—Ç–ø—Ä–∞–≤–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –æ–ø—Ä–æ—Å–∞ –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º")
    rows = await list_members()
    for r in rows:
        tg_id = r['tg_id']
        text = "–ë—É–¥–µ—à—å –ª–∏ —Ç—ã —Å–µ–≥–æ–¥–Ω—è –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?"
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="–î–∞", callback_data=f"att:{date.today().isoformat()}:yes")],
            [InlineKeyboardButton(text="–ù–µ—Ç", callback_data=f"att:{date.today().isoformat()}:no")],
            [InlineKeyboardButton(text="–û–ø–æ–∑–¥–∞—é", callback_data=f"att:{date.today().isoformat()}:late")]
        ])
        try:
            await bot.send_message(tg_id, text, reply_markup=kb)
        except Exception as e:
            logger.warning(f"Could not send survey to {tg_id}: {e}")

@dp.callback_query(Text(startswith="att:"))
async def cb_attendance(callback: types.CallbackQuery, state: FSMContext):
    _, for_date, answer = callback.data.split(":", 2)
    tg_id = callback.from_user.id
    if answer == 'no':
        await callback.message.answer("–ü–æ—á–µ–º—É —Ç–µ–±—è –Ω–µ –±—É–¥–µ—Ç –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?")
        await state.set_state(AttendanceReason.waiting_reason)
        await state.update_data(pending_att_date=for_date)
        await callback.answer()
    else:
        await record_attendance(tg_id, date.fromisoformat(for_date), answer)
        await callback.answer("–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –°–ø–∞—Å–∏–±–æ!")

@dp.message(AttendanceReason.waiting_reason)
async def reason_received(message: types.Message, state: FSMContext):
    data = await state.get_data()
    for_date = data.get('pending_att_date')
    reason = message.text.strip()
    await record_attendance(message.from_user.id, date.fromisoformat(for_date), 'no', reason)
    await message.answer("–°–ø–∞—Å–∏–±–æ, –ø—Ä–∏—á–∏–Ω–∞ –∑–∞–ø–∏—Å–∞–Ω–∞.")
    await state.clear()

async def send_daily_stats():
    the_date = date.today()
    summary = await attendance_summary_for_date(the_date)
    yes = summary.get('yes', 0)
    no = summary.get('no', 0)
    late = summary.get('late', 0)
    unanswered = await unanswered_members_for_date(the_date)
    text = f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –∑–∞ {the_date.isoformat()}:
–ü—Ä–∏–¥—É—Ç: {yes}
–ù–µ –ø—Ä–∏–¥—É—Ç: {no}
–û–ø–æ–∑–¥–∞—é—Ç: {late}
–ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏: {len(unanswered)}
"
    if unanswered:
        text += "–°–ø–∏—Å–æ–∫ –Ω–µ–æ—Ç–≤–µ—Ç–∏–≤—à–∏—Ö:
"
        for u in unanswered:
            text += f"{u['nick']} ‚Äî ID:{u['tg_id']}
"
    for admin in ADMIN_IDS:
        try:
            await bot.send_message(admin, text)
        except Exception as e:
            logger.warning(f"Failed sending stats to admin {admin}: {e}")

async def check_three_day_nonanswers():
    arr = await consecutive_nonanswers(3)
    if not arr:
        return
    text = "–í–Ω–∏–º–∞–Ω–∏–µ: —Å–ª–µ–¥—É—é—â–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –æ—Ç–≤–µ—á–∞–ª–∏ –Ω–∞ –æ–ø—Ä–æ—Å—ã –≤ —Ç–µ—á–µ–Ω–∏–µ 3-—Ö –¥–Ω–µ–π:
"
    for u in arr:
        text += f"{u['nick']} ‚Äî ID:{u['tg_id']}
"
    recipients = set(ADMIN_IDS + MODERATOR_IDS)
    for r in recipients:
        try:
            await bot.send_message(r, text)
        except Exception as e:
            logger.warning(f"Failed notify nonanswer to {r}: {e}")

# --------------------------- Scheduler setup -----------------------
scheduler = AsyncIOScheduler(timezone=MSK_TZ)

async def start_scheduler():
    scheduler.add_job(lambda: asyncio.create_task(send_daily_survey()), CronTrigger(hour=15, minute=0))
    scheduler.add_job(lambda: asyncio.create_task(send_daily_stats()), CronTrigger(hour=19, minute=0))
    scheduler.add_job(lambda: asyncio.create_task(check_three_day_nonanswers()), CronTrigger(hour=20, minute=0))
    scheduler.start()

# --------------------------- Startup / Shutdown --------------------
async def on_startup():
    await init_db()
    await start_scheduler()
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω, –ë–î –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã.")

async def on_shutdown():
    await bot.session.close()

# --------------------------- Running ------------------------------
if __name__ == '__main__':
    try:
        loop = asyncio.get_event_loop()
        loop.create_task(on_startup())
        dp.run_polling(bot)
    except (KeyboardInterrupt, SystemExit):
        logger.info("Shutting down...")
        loop.run_until_complete(on_shutdown())
