import asyncio
import logging
import sqlite3
from datetime import datetime, date
import calendar

from aiogram import Bot, Dispatcher, F, Router
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    BotCommand,
)
from aiogram.filters import CommandStart, Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties

# üîë –í–°–¢–ê–í–¨ –°–Æ–î–ê –°–í–û–ô –¢–û–ö–ï–ù
BOT_TOKEN = "8424176794:AAEKOjZWHoL7pU_-kZBJZJ34VqGyGdTHc5g"


# ===================== –ë–ê–ó–ê –î–ê–ù–ù–´–• =====================

# –ë–∞–∑–∞ –±—É–¥–µ—Ç –ª–µ–∂–∞—Ç—å —Ä—è–¥–æ–º —Å —Ñ–∞–π–ª–æ–º: planner.db
conn = sqlite3.connect("planner.db", check_same_thread=False)
conn.row_factory = sqlite3.Row
cur = conn.cursor()


def init_db():
    """–°–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—ã, –µ—Å–ª–∏ –∏—Ö –µ—â—ë –Ω–µ—Ç."""
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id INTEGER UNIQUE NOT NULL,
            username TEXT,
            name TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            title TEXT NOT NULL,
            task_date TEXT NOT NULL,   -- —Ñ–æ—Ä–º–∞—Ç YYYY-MM-DD
            task_time TEXT NOT NULL,   -- —Ñ–æ—Ä–º–∞—Ç HH:MM
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )
        """
    )
    conn.commit()


def get_user_by_telegram_id(telegram_id: int) -> sqlite3.Row | None:
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ telegram_id."""
    cur.execute("SELECT * FROM users WHERE telegram_id = ?", (telegram_id,))
    return cur.fetchone()


def get_or_create_user(telegram_id: int, username: str | None, name: str | None) -> int:
    cur.execute("SELECT id, username, name FROM users WHERE telegram_id = ?", (telegram_id,))
    row = cur.fetchone()
    if row:
        # –æ–±–Ω–æ–≤–∏–º —Ç–æ–ª—å–∫–æ —Ç–µ –ø–æ–ª—è, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–¥–∞–Ω—ã (—á—Ç–æ–±—ã –Ω–µ –∑–∞—Ç–∏—Ä–∞—Ç—å name = NULL –∏ —Ç.–ø.)
        fields = []
        params: list = []
        if username is not None:
            fields.append("username = ?")
            params.append(username)
        if name is not None:
            fields.append("name = ?")
            params.append(name)
        if fields:
            params.append(row["id"])
            cur.execute(f"UPDATE users SET {', '.join(fields)} WHERE id = ?", params)
            conn.commit()
        return row["id"]

    cur.execute(
        "INSERT INTO users (telegram_id, username, name, created_at) "
        "VALUES (?, ?, ?, ?)",
        (telegram_id, username, name, datetime.utcnow().isoformat()),
    )
    conn.commit()
    return cur.lastrowid


def create_task(user_id: int, title: str, task_date: str, task_time: str) -> int:
    cur.execute(
        "INSERT INTO tasks (user_id, title, task_date, task_time) "
        "VALUES (?, ?, ?, ?)",
        (user_id, title, task_date, task_time),
    )
    conn.commit()
    return cur.lastrowid


def get_tasks_for_date(user_id: int, task_date: str) -> list[sqlite3.Row]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –¥–∞—Ç—É."""
    cur.execute(
        "SELECT id, title, task_date, task_time FROM tasks WHERE user_id = ? AND task_date = ? ORDER BY task_time",
        (user_id, task_date),
    )
    return cur.fetchall()


# ===================== FSM –°–û–°–¢–û–Ø–ù–ò–Ø =====================

class Form(StatesGroup):
    waiting_for_name = State()
    waiting_for_task_title = State()


class Settings(StatesGroup):
    waiting_for_new_name = State()


router = Router()


# ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =====================

def get_month_name_ru(month: int) -> str:
    months = [
        "",
        "—è–Ω–≤–∞—Ä—è",
        "—Ñ–µ–≤—Ä–∞–ª—è",
        "–º–∞—Ä—Ç–∞",
        "–∞–ø—Ä–µ–ª—è",
        "–º–∞—è",
        "–∏—é–Ω—è",
        "–∏—é–ª—è",
        "–∞–≤–≥—É—Å—Ç–∞",
        "—Å–µ–Ω—Ç—è–±—Ä—è",
        "–æ–∫—Ç—è–±—Ä—è",
        "–Ω–æ—è–±—Ä—è",
        "–¥–µ–∫–∞–±—Ä—è",
    ]
    return months[month]


def build_calendar(year: int, month: int) -> InlineKeyboardMarkup:
    """Inline-–∫–∞–ª–µ–Ω–¥–∞—Ä—å. callback_data: cal:ACTION:year:month:day"""
    cal = calendar.Calendar(firstweekday=0)

    month_name = get_month_name_ru(month)
    keyboard: list[list[InlineKeyboardButton]] = []

    # –®–∞–ø–∫–∞ —Å –º–µ—Å—è—Ü–µ–º –∏ —Å—Ç—Ä–µ–ª–∫–∞–º–∏
    keyboard.append(
        [
            InlineKeyboardButton(
                text="¬´",
                callback_data=f"cal:PREV:{year}:{month}:0",
            ),
            InlineKeyboardButton(
                text=f"{month_name} {year}",
                callback_data="cal:IGNORE:0:0:0",
            ),
            InlineKeyboardButton(
                text="¬ª",
                callback_data=f"cal:NEXT:{year}:{month}:0",
            ),
        ]
    )

    # –î–Ω–∏ –Ω–µ–¥–µ–ª–∏
    weekdays = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    keyboard.append(
        [
            InlineKeyboardButton(text=day, callback_data="cal:IGNORE:0:0:0")
            for day in weekdays
        ]
    )

    # –°–µ—Ç–∫–∞ –¥–Ω–µ–π
    for week in cal.monthdayscalendar(year, month):
        row: list[InlineKeyboardButton] = []
        for day_number in week:
            if day_number == 0:
                row.append(
                    InlineKeyboardButton(text=" ", callback_data="cal:IGNORE:0:0:0")
                )
            else:
                row.append(
                    InlineKeyboardButton(
                        text=str(day_number),
                        callback_data=f"cal:DAY:{year}:{month}:{day_number}",
                    )
                )
        keyboard.append(row)

    # –ù–∞–∑–∞–¥ (–º–æ–∂–Ω–æ –ø–æ—Ç–æ–º –ø–æ–≤–µ—Å–∏—Ç—å –¥—Ä—É–≥–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ)
    keyboard.append(
        [
            InlineKeyboardButton(
                text="‚¨Ö –ù–∞–∑–∞–¥",
                callback_data="cal:BACK:0:0:0",
            )
        ]
    )

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def build_hours_keyboard() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ —á–∞—Å–∞. callback_data: time:H:HH"""
    keyboard: list[list[InlineKeyboardButton]] = []
    row: list[InlineKeyboardButton] = []
    for hour in range(0, 24):
        text = f"{hour:02d}"
        row.append(InlineKeyboardButton(text=text, callback_data=f"time:H:{text}"))
        if len(row) == 6:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)

    keyboard.append(
        [
            InlineKeyboardButton(
                text="‚¨Ö –ù–∞–∑–∞–¥ –∫ –¥–∞—Ç–µ", callback_data="time:BACK_DATE"
            )
        ]
    )

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def build_minutes_keyboard() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ –º–∏–Ω—É—Ç. callback_data: time:M:MM"""
    minutes = ["00", "15", "30", "45"]
    keyboard: list[list[InlineKeyboardButton]] = [
        [
            InlineKeyboardButton(text=m, callback_data=f"time:M:{m}")
            for m in minutes
        ]
    ]
    keyboard.append(
        [
            InlineKeyboardButton(
                text="‚¨Ö –ù–∞–∑–∞–¥ –∫ —á–∞—Å–∞–º", callback_data="time:BACK_HOUR"
            )
        ]
    )
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def build_settings_keyboard() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∞–∫–∫–∞—É–Ω—Ç–∞."""
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–º—è", callback_data="settings:EDIT_NAME"
                )
            ]
        ]
    )


# ===================== –•–ï–ù–î–õ–ï–†–´ =====================

@router.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    """–°—Ç–∞—Ä—Ç: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑."""
    await state.clear()

    user_row = get_user_by_telegram_id(message.from_user.id)

    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω (–µ—Å—Ç—å –∏–º—è), –Ω–µ —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –∏–º—è –ø–æ–≤—Ç–æ—Ä–Ω–æ
    if user_row and user_row["name"]:
        user_id = user_row["id"]
        name = user_row["name"]
        await state.update_data(name=name, user_id=user_id)
        await state.set_state(Form.waiting_for_task_title)
        await message.answer(
            f"–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, {name}! ‚ú®

"
            f"–ö–∞–∫—É—é –∑–∞–¥–∞—á—É —Ö–æ—á–µ—à—å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å?

"
            f"–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏."
        )
        return

    # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â—ë –Ω–µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –∏–º—è
    await state.set_state(Form.waiting_for_name)
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! üëã

–Ø –±–æ—Ç-–ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫.
–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"
    )


@router.message(Command("settings"))
async def cmd_settings(message: Message, state: FSMContext):
    """–ö–æ–º–∞–Ω–¥–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∞–∫–∫–∞—É–Ω—Ç–∞."""
    # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—Å—Ç—å –≤ –±–∞–∑–µ
    get_or_create_user(
        telegram_id=message.from_user.id,
        username=message.from_user.username,
        name=None,
    )

    markup = build_settings_keyboard()
    await message.answer(
        "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞:

–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=markup,
    )


@router.message(Command("calendar"))
async def cmd_calendar(message: Message, state: FSMContext):
    """–ü–æ–∫–∞–∑–∞—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞–¥–∞—á –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—ã–ª –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏, –æ—á–∏—â–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–¥–∞—á–µ,
    # —á—Ç–æ–±—ã –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.
    data = await state.get_data()
    if data.get("task_title") or data.get("selected_date") or data.get("selected_hour"):
        await state.update_data(task_title=None, selected_date=None, selected_hour=None)

    now = datetime.now()
    markup = build_calendar(now.year, now.month)
    await message.answer(
        "üìÖ –ö–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞–¥–∞—á.

–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∑–∞–¥–∞—á–∏ –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å:",
        reply_markup=markup,
    )


@router.callback_query(F.data == "settings:EDIT_NAME")
async def settings_edit_name_callback(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫—É —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–º–µ–Ω–∏."""
    await state.set_state(Settings.waiting_for_new_name)
    await callback.message.edit_text(
        "–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∏–º—è, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–µ:",
        reply_markup=None,
    )
    await callback.answer()


@router.message(StateFilter(Settings.waiting_for_new_name))
async def process_new_name(message: Message, state: FSMContext):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    new_name = (message.text or "").strip()
    if not new_name:
        await message.answer("–ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ üôÇ")
        return

    get_or_create_user(
        telegram_id=message.from_user.id,
        username=message.from_user.username,
        name=new_name,
    )

    await state.clear()
    await message.answer(
        f"–ò–º—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ ‚úÖ
–¢–µ–ø–µ—Ä—å —è –±—É–¥—É –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ —Ç–µ–±–µ –∫–∞–∫ –∫ <b>{new_name}</b>."
    )


@router.message(StateFilter(Form.waiting_for_name))
async def process_name(message: Message, state: FSMContext):
    """–°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–º—è, —Å–æ–∑–¥–∞—ë–º/–æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –∑–∞–¥–∞—á—É."""
    name = (message.text or "").strip()
    if not name:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —Å–≤–æ—ë –∏–º—è —Ç–µ–∫—Å—Ç–æ–º üôÇ")
        return

    user_id = get_or_create_user(
        telegram_id=message.from_user.id,
        username=message.from_user.username,
        name=name,
    )

    await state.update_data(name=name, user_id=user_id)
    await state.set_state(Form.waiting_for_task_title)

    await message.answer(
        f"–ü—Ä–∏—è—Ç–Ω–æ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è, {name}! ‚ú®

"
        f"–ö–∞–∫—É—é –∑–∞–¥–∞—á—É —Ö–æ—á–µ—à—å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å?

"
        f"–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏."
    )


@router.message(StateFilter(Form.waiting_for_task_title))
async def process_task_title(message: Message, state: FSMContext):
    """–ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∞–ª–µ–Ω–¥–∞—Ä—å –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–∞—Ç—ã."""
    title = (message.text or "").strip()
    if not title:
        await message.answer("–û–ø–∏—à–∏ –∑–∞–¥–∞—á—É —Ç–µ–∫—Å—Ç–æ–º, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ üôÇ")
        return

    data = await state.get_data()
    user_id = data.get("user_id")
    if not user_id:
        # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π, –µ—Å–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–ª–æ—Å—å
        user_id = get_or_create_user(
            telegram_id=message.from_user.id,
            username=message.from_user.username,
            name=None,
        )
        await state.update_data(user_id=user_id)

    await state.update_data(task_title=title)

    now = datetime.now()
    markup = build_calendar(now.year, now.month)

    await message.answer(
        f"–ó–∞–¥–∞—á–∞: <b>{title}</b>

–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É:",
        reply_markup=markup,
    )


@router.callback_query(F.data.startswith("cal:"))
async def calendar_callback(callback: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä—è.
    cal:ACTION:year:month:day
    ACTION = IGNORE | BACK | PREV | NEXT | DAY
    """
    if not callback.data:
        await callback.answer()
        return

    parts = callback.data.split(":")
    if len(parts) != 5:
        await callback.answer()
        return

    _, action, year_str, month_str, day_str = parts

    try:
        year = int(year_str)
        month = int(month_str)
        day = int(day_str)
    except ValueError:
        now = datetime.now()
        year, month, day = now.year, now.month, 0

    if action == "IGNORE":
        await callback.answer()
        return

    if action == "BACK":
        await callback.message.edit_text("–ö–∞–ª–µ–Ω–¥–∞—Ä—å –∑–∞–∫—Ä—ã—Ç.", reply_markup=None)
        await callback.answer()
        return

    if action in ("PREV", "NEXT"):
        if action == "PREV":
            if month == 1:
                month = 12
                year -= 1
            else:
                month -= 1
        else:  # NEXT
            if month == 12:
                month = 1
                year += 1
            else:
                month += 1

        markup = build_calendar(year, month)
        month_name = get_month_name_ru(month)
        text = f"–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É ({month_name} {year}):"
        await callback.message.edit_text(text, reply_markup=markup)
        await callback.answer()
        return

    if action == "DAY":
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –¥–µ–Ω—å
        try:
            selected_date = date(year, month, day)
        except ValueError:
            await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞", show_alert=True)
            return

        date_str_db = selected_date.strftime("%Y-%m-%d")
        date_str_human = selected_date.strftime("%d.%m.%Y")

        data = await state.get_data()
        title = data.get("task_title")

        if title:
            # –†–µ–∂–∏–º —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞—Ç—É –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≤—ã–±–æ—Ä—É —á–∞—Å–∞
            await state.update_data(selected_date=date_str_db, selected_hour=None)

            text = (
                f"–ó–∞–¥–∞—á–∞: <b>{title}</b>
"
                f"–î–∞—Ç–∞: <b>{date_str_human}</b>

"
                f"–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —á–∞—Å:"
            )
            markup = build_hours_keyboard()
            await callback.message.edit_text(text, reply_markup=markup)
            await callback.answer()
            return
        else:
            # –†–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–¥–∞—á –∏–∑ /calendar
            user_id = get_or_create_user(
                telegram_id=callback.from_user.id,
                username=callback.from_user.username,
                name=None,
            )
            tasks = get_tasks_for_date(user_id, date_str_db)

            if tasks:
                lines = [f"üìÖ –ó–∞–¥–∞—á–∏ –Ω–∞ <b>{date_str_human}</b>:", ""]
                for idx, task in enumerate(tasks, start=1):
                    time_str = task["task_time"]
                    task_title = task["title"]
                    task_id = task["id"]
                    lines.append(f"{idx}. <b>{time_str}</b> ‚Äî {task_title} (ID: {task_id})")
                text = "
".join(lines)
            else:
                text = (
                    f"üìÖ –ù–∞ <b>{date_str_human}</b> –∑–∞–¥–∞—á –ø–æ–∫–∞ –Ω–µ—Ç.

"
                    f"–í—ã–±–µ—Ä–∏ –¥—Ä—É–≥—É—é –¥–∞—Ç—É:"
                )

            markup = build_calendar(year, month)
            await callback.message.edit_text(text, reply_markup=markup)
            await callback.answer()
            return

    await callback.answer()


@router.callback_query(F.data.startswith("time:"))
async def time_callback(callback: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏.
    time:H:HH | time:M:MM | time:BACK_DATE | time:BACK_HOUR | time:BACK
    """
    if not callback.data:
        await callback.answer()
        return

    parts = callback.data.split(":")
    if len(parts) < 2:
        await callback.answer()
        return

    _, action, *rest = parts

    # –ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É –¥–∞—Ç—ã
    if action in ("BACK", "BACK_DATE"):
        data = await state.get_data()
        selected_date = data.get("selected_date")
        if selected_date:
            d = datetime.strptime(selected_date, "%Y-%m-%d").date()
            year, month = d.year, d.month
        else:
            now = datetime.now()
            year, month = now.year, now.month

        markup = build_calendar(year, month)
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏ –¥–∞—Ç—É:", reply_markup=markup)
        await callback.answer()
        return

    # –ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É —á–∞—Å–∞
    if action == "BACK_HOUR":
        text = callback.message.text or ""
        if "–í—ã–±–µ—Ä–∏ –º–∏–Ω—É—Ç—ã:" in text:
            base_text = text.split("–í—ã–±–µ—Ä–∏ –º–∏–Ω—É—Ç—ã:")[0].rstrip()
            new_text = base_text + "

–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —á–∞—Å:"
        else:
            new_text = text
        markup = build_hours_keyboard()
        await callback.message.edit_text(new_text, reply_markup=markup)
        await callback.answer()
        return

    # –í—ã–±–æ—Ä —á–∞—Å–∞
    if action == "H" and rest:
        hour = rest[0]
        await state.update_data(selected_hour=hour)
        text = callback.message.text or ""
        if "–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —á–∞—Å:" in text:
            base_text = text.split("–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —á–∞—Å:")[0].rstrip()
        else:
            base_text = text
        new_text = base_text + "

–í—ã–±–µ—Ä–∏ –º–∏–Ω—É—Ç—ã:"
        markup = build_minutes_keyboard()
        await callback.message.edit_text(new_text, reply_markup=markup)
        await callback.answer("–ß–∞—Å –≤—ã–±—Ä–∞–Ω ‚úÖ")
        return

    # –í—ã–±–æ—Ä –º–∏–Ω—É—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏
    if action == "M" and rest:
        minute = rest[0]

        data = await state.get_data()
        user_id = data.get("user_id")
        title = data.get("task_title")
        date_str_db = data.get("selected_date")
        hour = data.get("selected_hour")

        if not hour:
            await callback.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —á–∞—Å", show_alert=True)
            return

        if not all([user_id, title, date_str_db]):
            await callback.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏, –ø–æ–ø—Ä–æ–±—É–π –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ /start", show_alert=True)
            return

        time_str = f"{hour}:{minute}"  # —Ñ–æ—Ä–º–∞—Ç HH:MM

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–¥–∞—á—É –≤ –ë–î
        task_id = create_task(user_id=user_id, title=title, task_date=date_str_db, task_time=time_str)

        nice_date = datetime.strptime(date_str_db, "%Y-%m-%d").strftime("%d.%m.%Y")

        text = (
            f"–ó–∞–¥–∞—á–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ ‚úÖ (ID: {task_id})

"
            f"<b>{title}</b>
"
            f"–î–∞—Ç–∞: <b>{nice_date}</b>
"
            f"–í—Ä–µ–º—è: <b>{time_str}</b>

"
            f"–ú–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É, —á—Ç–æ–±—ã –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –µ—â—ë –æ–¥–Ω—É,"
            f" –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å /start –¥–ª—è –Ω–æ–≤–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è."
        )
        await callback.message.edit_text(text, reply_markup=None)
        await callback.answer("–í—Ä–µ–º—è –≤—ã–±—Ä–∞–Ω–æ ‚úÖ")

        # –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏ –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —á—Ç–æ–±—ã –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∏–∑ /calendar
        # –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–¥–∞—á, –∞ –Ω–µ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Å—Ç–∞—Ä–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è.
        await state.clear()
        return

    await callback.answer()


# ===================== –ó–ê–ü–£–°–ö –ë–û–¢–ê =====================

async def main():
    logging.basicConfig(level=logging.INFO)

    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
    storage = MemoryStorage()
    dp = Dispatcher(storage=storage)
    dp.include_router(router)

    # –í—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ –º–µ–Ω—é Telegram —Å –∫–æ–º–∞–Ω–¥–∞–º–∏
    await bot.set_my_commands(
        [
            BotCommand(command="settings", description="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞"),
            BotCommand(command="calendar", description="–ö–∞–ª–µ–Ω–¥–∞—Ä—å"),
        ]
    )

    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)


if __name__ == "__main__":
    init_db()
    asyncio.run(main())
