# main.py
# aiogram 3.x bot for Blackberry clan onboarding
# Features:
# 1) Registration via phone share button
# 2) Sequential text prompts: nickname(real name), Discord, SteamID, age, timezone, personal TG link
# 3) Channel subscription check for @SquadBlackBerry
# 4) Submit application -> notify moderators with Approve/Reject buttons
# 5) After approval -> send clan chat invite link
# 6) After user joins clan chat -> announce to clan chat and store join date
# 7) SQLite storage

import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Optional

import aiosqlite
from aiogram import Bot, Dispatcher, F
from aiogram.filters import CommandStart, or_f
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    Message,
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    CallbackQuery,
    ChatInviteLink,
, FSInputFile)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types.chat import ChatType
import os
from dotenv import load_dotenv

load_dotenv()

# ======= CONFIG =======
BOT_TOKEN = os.getenv("8351592944:AAHXUVRpePbaBLmBkLkdicrQpeX-aulJoYY")
CHANNEL_USERNAME = os.getenv("@SquadBlackBerry")  # public channel username
CLAN_CHAT_ID = int(os.getenv("CLAN_CHAT_ID", "0"))  # numeric ID of the clan chat (supergroup)
MODERATION_CHAT_ID = int(os.getenv("MODERATION_CHAT_ID", "0"))  # chat where moderators receive requests

# Optional: per-user admin permissions (used for /start on moderators etc.)
ADMIN_IDS = set(map(int, os.getenv("403704696", "").split())) if os.getenv("ADMIN_IDS") else set()
MODERATOR_IDS = set(map(int, os.getenv("MODERATOR_IDS", "").split())) if os.getenv("MODERATOR_IDS") else set()

DB_PATH = os.getenv("DB_PATH", "blackberry_bot.db")

# Safety checks
if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set in environment")


# ======= DB LAYER =======
CREATE_USERS_SQL = """
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    nickname TEXT,
    discord TEXT,
    steamid TEXT,
    age INTEGER,
    timezone TEXT,
    tg_link TEXT,
    status TEXT,
    created_at TEXT,
    applied_at TEXT,
    approved_at TEXT,
    joined_at TEXT
);
"""

class Status(str, Enum):
    NEW = "new"  # created after /start
    PENDING_CHANNEL = "pending_channel"
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    JOINED = "joined"

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(CREATE_USERS_SQL)
        # Lightweight migration for older DBs
        try:
            await db.execute("ALTER TABLE users ADD COLUMN applied_at TEXT")
        except Exception:
            pass
        await db.commit()

async def upsert_user(user_id: int, **fields):
    # Read existing
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if row:
            # update
            cols = ", ".join([f"{k}=?" for k in fields.keys()])
            vals = list(fields.values()) + [user_id]
            await db.execute(f"UPDATE users SET {cols} WHERE user_id=?", vals)
        else:
            # insert
            keys = ["user_id", *fields.keys()]
            placeholders = ",".join(["?"] * len(keys))
            vals = [user_id, *fields.values()]
            await db.execute(
                f"INSERT INTO users ({','.join(keys)}) VALUES ({placeholders})",
                vals,
            )
        await db.commit()

async def get_user(user_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))


# ======= FSM =======
class RegStates(StatesGroup):
    waiting_phone = State()
    waiting_nickname = State()
    waiting_discord = State()
    waiting_steam = State()
    waiting_age = State()
    waiting_tz = State()
    waiting_tg_link = State()


# ======= BOT SETUP =======
logging.basicConfig(level=logging.INFO)
bot = Bot(BOT_TOKEN, parse_mode="HTML")
dp = Dispatcher()


def phone_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º",
    )


def subscription_check_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üîî –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_sub")
    return kb.as_markup()


def apply_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üì® –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É", callback_data="send_apply")
    return kb.as_markup()


def approve_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ü—Ä–∏–Ω—è—Ç—å", callback_data=f"approve:{user_id}")
    kb.button(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject:{user_id}")
    return kb.as_markup()


# ======= HELPERS =======
async def is_subscribed(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        return member.status in ("member", "administrator", "creator")
    except Exception as e:
        logging.exception("Failed to check subscription: %r", e)
        return False

async def send_to_moderation(text: str):
    if MODERATION_CHAT_ID:
        await bot.send_message(MODERATION_CHAT_ID, text)

async def create_invite_link() -> Optional[ChatInviteLink]:
    try:
        link = await bot.create_chat_invite_link(
            chat_id=CLAN_CHAT_ID,
            name=f"Onboarding {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            creates_join_request=False,
            expire_date=None,
            member_limit=1,
        )
        return link
    except Exception as e:
        logging.exception("Cannot create invite link: %r", e)
        return None


# ======= HANDLERS =======
@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if user and user.get("status") in (Status.APPROVED, Status.JOINED):
        await message.answer("–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /profile, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–∞–Ω–Ω—ã–µ.")
        return

    await upsert_user(
        message.from_user.id,
        status=Status.NEW.value,
        created_at=datetime.utcnow().isoformat(),
    )
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –∫–ª–∞–Ω–∞ Blackberry. –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
        reply_markup=phone_kb(),
    )
    await state.set_state(RegStates.waiting_phone)


@dp.message(RegStates.waiting_phone, F.contact)
async def got_phone(message: Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("–û—Ç–ª–∏—á–Ω–æ! –í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫ (—Ä–µ–∞–ª—å–Ω–æ–µ –∏–º—è):", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_nickname)


@dp.message(RegStates.waiting_phone)
async def need_phone(message: Message):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞.", reply_markup=phone_kb())


@dp.message(RegStates.waiting_nickname)
async def got_nick(message: Message, state: FSMContext):
    await state.update_data(nickname=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ Discord:")
    await state.set_state(RegStates.waiting_discord)


@dp.message(RegStates.waiting_discord)
async def got_discord(message: Message, state: FSMContext):
    await state.update_data(discord=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ SteamID:")
    await state.set_state(RegStates.waiting_steam)


@dp.message(RegStates.waiting_steam)
async def got_steam(message: Message, state: FSMContext):
    await state.update_data(steamid=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–æ–∑—Ä–∞—Å—Ç:")
    await state.set_state(RegStates.waiting_age)


@dp.message(RegStates.waiting_age)
async def got_age(message: Message, state: FSMContext):
    text = message.text.strip()
    if not text.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–≤–æ–∑—Ä–∞—Å—Ç –≤ –≥–æ–¥–∞—Ö).")
        return
    await state.update_data(age=int(text))
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä, GMT+3 –∏–ª–∏ Europe/Moscow):")
    await state.set_state(RegStates.waiting_tz)


@dp.message(RegStates.waiting_tz)
async def got_tz(message: Message, state: FSMContext):
    await state.update_data(timezone=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∞—à –ª–∏—á–Ω—ã–π Telegram (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://t.me/username):")
    await state.set_state(RegStates.waiting_tg_link)


@dp.message(RegStates.waiting_tg_link)
async def got_tg_link(message: Message, state: FSMContext):
    data = await state.update_data(tg_link=message.text.strip())
    data = await state.get_data()

    # Persist to DB
    await upsert_user(
        message.from_user.id,
        phone=data.get("phone"),
        nickname=data.get("nickname"),
        discord=data.get("discord"),
        steamid=data.get("steamid"),
        age=data.get("age"),
        timezone=data.get("timezone"),
        tg_link=data.get("tg_link"),
        status=Status.PENDING_CHANNEL.value,
    )

    preview = (
        f"<b>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ</b>\n"
        f"–ù–∏–∫: {data.get('nickname')}\n"
        f"Discord: {data.get('discord')}\n"
        f"SteamID: {data.get('steamid')}\n"
        f"–í–æ–∑—Ä–∞—Å—Ç: {data.get('age')}\n"
        f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {data.get('timezone')}\n"
        f"–õ–∏—á–Ω—ã–π TG: {data.get('tg_link')}\n\n"
        f"–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π: {CHANNEL_USERNAME}"
    )

    await message.answer(preview)
    await message.answer(
        "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=subscription_check_kb(),
    )
    await state.clear()


# Check subscription
@dp.callback_query(F.data == "check_sub")
async def on_check_sub(call: CallbackQuery):
    uid = call.from_user.id
    if await is_subscribed(uid):
        await upsert_user(uid, status=Status.PENDING_REVIEW.value)
        await call.message.edit_text(
            "–ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ.",
            reply_markup=apply_kb(),
        )
    else:
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @SquadBlackBerry", show_alert=True)


# Send application to moderators
@dp.callback_query(F.data == "send_apply")
async def on_send_apply(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not user or user.get("status") != Status.PENDING_REVIEW.value:
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É.", show_alert=True)
        return

    # Stamp application time
    await upsert_user(uid, applied_at=datetime.utcnow().isoformat())

    text = (
        f"<b>–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –≤ –∫–ª–∞–Ω</b>
"
        f"ID: <code>{uid}</code>
"
        f"–ù–∏–∫: {user.get('nickname')}
"
        f"Discord: {user.get('discord')}
"
        f"SteamID: {user.get('steamid')}
"
        f"–í–æ–∑—Ä–∞—Å—Ç: {user.get('age')}
"
        f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {user.get('timezone')}
"
        f"–õ–∏—á–Ω—ã–π TG: {user.get('tg_link')}
"
    )
    await bot.send_message(
        MODERATION_CHAT_ID,
        text,
        reply_markup=approve_kb(uid),
    )
    await call.message.edit_text("–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –û–∂–∏–¥–∞–π—Ç–µ —Ä–µ—à–µ–Ω–∏—è.")


# Moderation actions
@dp.callback_query(F.data.startswith("approve:"))
async def on_approve(call: CallbackQuery):
    if call.message.chat.id != MODERATION_CHAT_ID:
        await call.answer("–î–µ–π—Å—Ç–≤–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –≤ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—Å–∫–æ–º —á–∞—Ç–µ.", show_alert=True)
        return
    # Permission check: only moderators/admins
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ–¥–æ–±—Ä—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return
    target_id = int(call.data.split(":")[1])

    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat())

    link = await create_invite_link()
    if not link:
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞ –≤ —á–∞—Ç–µ –∫–ª–∞–Ω–∞.", show_alert=True)
        return

    await bot.send_message(
        target_id,
        f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞! –í–æ—Ç —Å—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ —á–∞—Ç –∫–ª–∞–Ω–∞: {link.invite_link}",
    )

    await call.message.edit_text(call.message.text + "\n\n‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ")


@dp.callback_query(F.data.startswith("reject:"))
async def on_reject(call: CallbackQuery):
    if call.message.chat.id != MODERATION_CHAT_ID:
        await call.answer("–î–µ–π—Å—Ç–≤–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –≤ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—Å–∫–æ–º —á–∞—Ç–µ.", show_alert=True)
        return
    # Permission check: only moderators/admins
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ—Ç–∫–ª–æ–Ω—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return
    target_id = int(call.data.split(":")[1])
    await upsert_user(target_id, status=Status.REJECTED.value)
    await bot.send_message(target_id, "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ.")
    await call.message.edit_text(call.message.text + "\n\n‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ")


# Profile command
@dp.message(or_f(F.text == "/profile", F.text == "profile"))
async def cmd_profile(message: Message):
    user = await get_user(message.from_user.id)
    if not user:
        await message.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start")
        return
    lines = ["<b>–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å</b>"]
    for key in ("nickname", "discord", "steamid", "age", "timezone", "tg_link", "status", "created_at", "approved_at", "joined_at"):
        if user.get(key):
            lines.append(f"{key}: {user.get(key)}")
    await message.answer("\n".join(lines))


# Announce when user joins clan chat
@dp.message(F.chat.id == CLAN_CHAT_ID, F.new_chat_members)
async def on_user_joined_clan(message: Message):
    for member in message.new_chat_members:
        uid = member.id
        user = await get_user(uid)
        if user and user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
            # Save joined_at and status if first time
            now_iso = datetime.utcnow().isoformat()
            first_join = not user.get("joined_at")
            if first_join:
                await upsert_user(uid, status=Status.JOINED.value, joined_at=now_iso)
                user = await get_user(uid)  # refresh
            nickname = user.get("nickname") or member.full_name

            # Announce to clan chat
            await bot.send_message(CLAN_CHAT_ID, f"<b>{nickname}</b> –≤—Å—Ç—É–ø–∏–ª –≤ –Ω–∞—à –∫–ª–∞–Ω!")

            # Notify moderators automatically about the join event
            join_text = (
                f"<b>–£—á–∞—Å—Ç–Ω–∏–∫ –≤—Å—Ç—É–ø–∏–ª –≤ –∫–ª–∞–Ω</b>
"
                f"ID: <code>{uid}</code>
"
                f"–ù–∏–∫: {nickname}
"
                f"Discord: {user.get('discord') or '-'}
"
                f"SteamID: {user.get('steamid') or '-'}
"
                f"–í–æ–∑—Ä–∞—Å—Ç: {user.get('age') or '-'}
"
                f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {user.get('timezone') or '-'}
"
                f"–õ–∏—á–Ω—ã–π TG: {user.get('tg_link') or '-'}
"
                f"–î–∞—Ç–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {user.get('joined_at') or now_iso}"
            )
            await send_to_moderation(join_text)



# Fallback for when the bot is added to the clan chat (ensure it can see join events)
@dp.message(F.new_chat_members)
async def on_user_joined_any(message: Message):
    # Only announce in clan chat; ignore others
    if message.chat.id != CLAN_CHAT_ID:
        return
    await on_user_joined_clan(message)


# /help
@dp.message(or_f(F.text == "/help", F.text == "help"))
async def cmd_help(message: Message):
    await message.answer(
        """–ö–æ–º–∞–Ω–¥—ã:
/start ‚Äî –Ω–∞—á–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é
/profile ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ
/help ‚Äî –ø–æ–º–æ—â—å

–®–∞–≥–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:
1) –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞
2) –í–≤–µ—Å—Ç–∏ –Ω–∏–∫, Discord, SteamID, –≤–æ–∑—Ä–∞—Å—Ç, —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å, —Å—Å—ã–ª–∫—É –Ω–∞ –ª–∏—á–Ω—ã–π TG
3) –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–æ–≤–æ—Å—Ç–∏ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å
4) –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –∏ –¥–æ–∂–¥–∞—Ç—å—Å—è —Ä–µ—à–µ–Ω–∏—è
5) –ü–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –∏ –≤—Å—Ç—É–ø–∏—Ç—å –≤ —á–∞—Ç –∫–ª–∞–Ω–∞
        """
    )


# ======= REPORTING =======
async def get_stats(start: Optional[datetime], end: Optional[datetime]) -> str:
    # Build dynamic conditions
    params_created: list = []
    params_applied: list = []
    params_approved: list = []
    params_joined: list = []

    def range_cond(col: str, params_list: list):
        c = []
        if start:
            c.append(f"date({col}) >= date(?)")
            params_list.append(start.isoformat())
        if end:
            c.append(f"date({col}) <= date(?)")
            params_list.append(end.isoformat())
        return (" AND ".join(c)) if c else "1=1"

    cond_created = range_cond("created_at", params_created)
    cond_applied = range_cond("applied_at", params_applied)
    cond_approved = range_cond("approved_at", params_approved)
    cond_joined = range_cond("joined_at", params_joined)

    async with aiosqlite.connect(DB_PATH) as db:
        new_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE {cond_created}", params_created)).fetchone())[0]
        applied_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE applied_at IS NOT NULL AND {cond_applied}", params_applied)).fetchone())[0]
        approved_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE approved_at IS NOT NULL AND {cond_approved}", params_approved)).fetchone())[0]
        joined_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone())[0]

        total = (await (await db.execute("SELECT COUNT(1) FROM users")).fetchone())[0]
        pending = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.PENDING_REVIEW.value,))).fetchone())[0]
        approved_not_joined = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.APPROVED.value,))).fetchone())[0]
        joined_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.JOINED.value,))).fetchone())[0]
        rejected_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.REJECTED.value,))).fetchone())[0]

        avg_age_row = await (await db.execute(f"SELECT AVG(age) FROM users WHERE age IS NOT NULL AND joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone()
        avg_age = round(avg_age_row[0], 1) if avg_age_row and avg_age_row[0] is not None else None

        tz_rows = await (await db.execute(
            f"SELECT timezone, COUNT(1) c FROM users WHERE joined_at IS NOT NULL AND timezone IS NOT NULL AND {cond_joined} GROUP BY timezone ORDER BY c DESC LIMIT 5",
            params_joined,
        )).fetchall()

    lines = ["<b>–ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã</b>"]
    if start or end:
        lines.append(f"–ü–µ—Ä–∏–æ–¥: {start.date() if start else '‚Äî'} ‚Äî {end.date() if end else '‚Äî'}")
    lines += [
        f"–ù–æ–≤—ã—Ö —Å—Ç–∞—Ä—Ç–æ–≤ /start: <b>{new_cnt}</b>",
        f"–ó–∞—è–≤–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: <b>{applied_cnt}</b>",
        f"–û–¥–æ–±—Ä–µ–Ω–æ: <b>{approved_cnt}</b>",
        f"–í—Å—Ç—É–ø–∏–ª–æ: <b>{joined_cnt}</b>",
        "",
        "<b>–í–æ—Ä–æ–Ω–∫–∞ (–≤—Å–µ–≥–æ):</b>",
        f"–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}",
        f"–ù–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏: {pending}",
        f"–û–¥–æ–±—Ä–µ–Ω—ã (–Ω–µ –≤—Å—Ç—É–ø–∏–ª–∏): {approved_not_joined}",
        f"–í—Å—Ç—É–ø–∏–ª–∏: {joined_total}",
        f"–û—Ç–∫–ª–æ–Ω–µ–Ω—ã: {rejected_total}",
    ]
    if avg_age is not None:
        lines.append(f"–°—Ä–µ–¥–Ω–∏–π –≤–æ–∑—Ä–∞—Å—Ç (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ –≤ –ø–µ—Ä–∏–æ–¥): {avg_age}")
    if tz_rows:
        lines.append("–¢–æ–ø –ø–æ —á–∞—Å–æ–≤—ã–º –ø–æ—è—Å–∞–º (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ):")
        for tz, c in tz_rows:
            lines.append(f"‚Ä¢ {tz}: {c}")
    return "
".join(lines)


def period_bounds(key: str):
    now = datetime.utcnow()
    if key == "today":
        start = datetime(now.year, now.month, now.day)
        end = now
    elif key == "7d":
        end = now
        start = now - timedelta(days=7)
    elif key == "30d":
        end = now
        start = now - timedelta(days=30)
    else:
        start = None
        end = None
    return start, end


def stats_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–°–µ–≥–æ–¥–Ω—è", callback_data="stats:today")
    kb.button(text="7 –¥–Ω–µ–π", callback_data="stats:7d")
    kb.button(text="30 –¥–Ω–µ–π", callback_data="stats:30d")
    kb.button(text="–ó–∞ –≤—Å—ë –≤—Ä–µ–º—è", callback_data="stats:all")
    kb.button(text="CSV (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ 30–¥)", callback_data="export:joined:30d")
    kb.button(text="CSV (–≤—Å–µ –∑–∞ 30–¥)", callback_data="export:all:30d")
    return kb.as_markup()


@dp.message(F.text == "/stats")
async def cmd_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ—Ç—á—ë—Ç–∞:", reply_markup=stats_kb())


@dp.callback_query(F.data.startswith("stats:"))
async def on_stats(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    key = call.data.split(":")[1]
    start, end = period_bounds(key)
    text = await get_stats(start, end)
    await call.message.edit_text(text, reply_markup=stats_kb())


async def export_csv(kind: str, start: Optional[datetime], end: Optional[datetime]) -> str:
    cond_col = {"joined": "joined_at", "all": "created_at"}[kind]
    params = []
    where = []
    if start:
        where.append(f"date({cond_col}) >= date(?)")
        params.append(start.isoformat())
    if end:
        where.append(f"date({cond_col}) <= date(?)")
        params.append(end.isoformat())
    if kind == "joined":
        where.append("joined_at IS NOT NULL")
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            f"SELECT user_id, nickname, discord, steamid, age, timezone, tg_link, phone, status, created_at, applied_at, approved_at, joined_at FROM users WHERE {where_sql}",
            params,
        )
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
    fname = f"bb_report_{kind}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
    import csv
    with open(fname, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(cols)
        writer.writerows(rows)
    return fname


@dp.callback_query(F.data.startswith("export:"))
async def on_export(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    _, kind, key = call.data.split(":")
    start, end = period_bounds(key)
    path = await export_csv(kind, start, end)
    await bot.send_document(call.from_user.id, FSInputFile(path))
    await call.answer("CSV –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")


async def main():
    await init_db()
    logging.info("DB initialized at %s", DB_PATH)
    await dp.start_polling(bot)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
