"""
Aiogram 3.x Telegram bot for clan 'Blackberry' (updated)
Изменения в этой версии:
- Добавлены поля `name` и `age` при регистрации
- Регистрация: сбор номера (через кнопку), имени (текст), возраста (через кнопки выбора или ручной ввод), ника, Discord, SteamID, часового пояса
- Все пользовательские сообщения и все подписи кнопок — на русском языке
- Вся основная навигация для модераторов/администраторов и часть взаимодействий реализована через кнопки (главное меню, модераторское меню, просмотр участника, принятие заявок и т.д.)
- Таблица БД расширена, добавлены безопасные ALTER TABLE при старте
- Сохранение даты вступления, учёт резерва, фракций и ролей сохранён
- Опросы и статистика — без изменений в логике, кнопки на русском

ВАЖНО: Заполните конфигурационные поля (BOT_TOKEN, ADMIN_IDS, CHANNEL_USERNAMES, CLAN_CHAT_INVITE_LINK) перед запуском.

Запуск: python blackberry_bot.py
Зависимости: aiogram aiosqlite APScheduler pytz
"""

import asyncio
import logging
import aiosqlite
from datetime import datetime, date, timedelta
from typing import List, Optional

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command, Text
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import ChatMemberUpdated

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
import pytz

# --------------------------- CONFIG ---------------------------
BOT_TOKEN = "REPLACE_WITH_YOUR_BOT_TOKEN"
ADMIN_IDS: List[int] = [123456789]
MODERATOR_IDS: List[int] = []
CHANNEL_USERNAMES = ["@blackberry_diary", "@blackberry_info", "@blackberry_news"]
CLAN_CHAT_INVITE_LINK = "https://t.me/+example_invite_link"
CLAN_CHAT_ID: Optional[int] = None
DB_PATH = "blackberry_bot.db"
MSK_TZ = pytz.timezone("Europe/Moscow")
# --------------------------------------------------------------

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# --------------------------- FSM -------------------------------
class Registration(StatesGroup):
    await_contact = State()
    ask_name = State()
    ask_age_buttons = State()
    ask_age_manual = State()
    ask_nick = State()
    ask_discord = State()
    ask_steam = State()
    ask_timezone = State()

class AttendanceReason(StatesGroup):
    waiting_reason = State()

class ModeratorFlow(StatesGroup):
    awaiting_member_for_action = State()

# --------------------------- DB helpers ------------------------
async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
        CREATE TABLE IF NOT EXISTS members (
            tg_id INTEGER PRIMARY KEY,
            phone TEXT,
            name TEXT,
            age INTEGER,
            nick TEXT,
            discord TEXT,
            steamid TEXT,
            timezone TEXT,
            factions TEXT,
            roles TEXT,
            is_reserve INTEGER DEFAULT 0,
            join_date TEXT
        )
        """)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS approvals (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER,
            requested_at TEXT,
            status TEXT,
            reviewer_id INTEGER,
            comment TEXT
        )
        """)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS attendance (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tg_id INTEGER,
            date TEXT,
            answer TEXT,
            reason TEXT
        )
        """)
        await db.commit()
        # backward-compatible: try adding columns if missing
        try:
            await db.execute("ALTER TABLE members ADD COLUMN name TEXT")
            await db.execute("ALTER TABLE members ADD COLUMN age INTEGER")
            await db.commit()
        except Exception:
            # columns probably already exist
            pass

async def save_member(tg_id: int, phone: str, name: str, age: Optional[int], nick: str, discord: str, steamid: str, timezone: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO members (tg_id, phone, name, age, nick, discord, steamid, timezone, factions, roles, join_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (tg_id, phone, name, age, nick, discord, steamid, timezone, '', '', None))
        await db.commit()

async def set_member_join_date(tg_id: int, join_date: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE members SET join_date = ? WHERE tg_id = ?", (join_date, tg_id))
        await db.commit()

async def member_exists(tg_id: int) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT 1 FROM members WHERE tg_id = ?", (tg_id,))
        r = await cur.fetchone()
        return r is not None

async def list_members() -> List[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT tg_id, name, nick, factions, roles, is_reserve, join_date FROM members")
        rows = await cur.fetchall()
        return [dict(tg_id=row[0], name=row[1], nick=row[2], factions=row[3], roles=row[4], is_reserve=row[5], join_date=row[6]) for row in rows]

async def get_member(tg_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM members WHERE tg_id = ?", (tg_id,))
        r = await cur.fetchone()
        if not r:
            return None
        cols = [c[0] for c in cur.description]
        return dict(zip(cols, r))

async def update_member_fields(tg_id:int, **fields):
    if not fields:
        return
    keys = ", ".join([f"{k} = ?" for k in fields.keys()])
    vals = list(fields.values())
    vals.append(tg_id)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(f"UPDATE members SET {keys} WHERE tg_id = ?", vals)
        await db.commit()

async def add_approval_request(tg_id:int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO approvals (tg_id, requested_at, status) VALUES (?, ?, 'pending')", (tg_id, datetime.utcnow().isoformat()))
        await db.commit()

async def get_pending_approvals() -> List[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT a.tg_id, m.nick, m.name FROM approvals a LEFT JOIN members m ON a.tg_id = m.tg_id WHERE a.status = 'pending'")
        rows = await cur.fetchall()
        return [{'tg_id': r[0], 'nick': r[1], 'name': r[2]} for r in rows]

async def set_approval_status(tg_id:int, status:str, reviewer_id:int, comment:Optional[str]=None):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE approvals SET status = ?, reviewer_id = ?, comment = ? WHERE tg_id = ? AND status = 'pending'", (status, reviewer_id, comment, tg_id))
        await db.commit()

async def record_attendance(tg_id:int, for_date: date, answer: str, reason: Optional[str]=None):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO attendance (tg_id, date, answer, reason) VALUES (?, ?, ?, ?)", (tg_id, for_date.isoformat(), answer, reason))
        await db.commit()

async def attendance_stats_for_user(tg_id:int, since: date):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT date, answer FROM attendance WHERE tg_id = ? AND date >= ?", (tg_id, since.isoformat()))
        rows = await cur.fetchall()
        return rows

async def attendance_summary_for_date(the_date: date):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT answer, COUNT(*) FROM attendance WHERE date = ? GROUP BY answer", (the_date.isoformat(),))
        rows = await cur.fetchall()
        return {r[0]: r[1] for r in rows}

async def unanswered_members_for_date(the_date: date):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT tg_id, nick FROM members WHERE tg_id NOT IN (SELECT tg_id FROM attendance WHERE date = ?)", (the_date.isoformat(),))
        rows = await cur.fetchall()
        return [{'tg_id': r[0], 'nick': r[1]} for r in rows]

async def consecutive_nonanswers(days:int=3):
    today = date.today()
    dates = [(today - timedelta(days=i)).isoformat() for i in range(days)]
    async with aiosqlite.connect(DB_PATH) as db:
        placeholders = ','.join('?' for _ in dates)
        cur = await db.execute(f"SELECT tg_id, nick FROM members WHERE tg_id NOT IN (SELECT tg_id FROM attendance WHERE date IN ({placeholders}))", dates)
        rows = await cur.fetchall()
        return [{'tg_id': r[0], 'nick': r[1]} for r in rows]

# --------------------------- Util -------------------------------
def is_admin(user_id:int) -> bool:
    return user_id in ADMIN_IDS

def is_moderator(user_id:int) -> bool:
    return user_id in MODERATOR_IDS or is_admin(user_id)

# --------------------------- Handlers ---------------------------
@dp.message(Command(commands=["start"]))
async def cmd_start(message: types.Message, state: FSMContext):
    kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Поделиться номером телефона", request_contact=True)]], resize_keyboard=True)
    await message.answer("Добро пожаловать в клан Blackberry! Чтобы зарегистрироваться нажмите кнопку и поделитесь номером телефона.", reply_markup=kb)
    await state.set_state(Registration.await_contact)

@dp.message(Registration.await_contact, F.contact)
async def contact_received(message: types.Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("Пожалуйста, введите ваше полное имя:", reply_markup=ReplyKeyboardRemove())
    await state.set_state(Registration.ask_name)

@dp.message(Registration.await_contact)
async def ask_contact_again(message: types.Message):
    kb = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Поделиться номером телефона", request_contact=True)]], resize_keyboard=True)
    await message.answer("Нам нужен ваш номер телефона — пожалуйста, нажмите кнопку и поделитесь контактом.", reply_markup=kb)

@dp.message(Registration.ask_name)
async def name_received(message: types.Message, state: FSMContext):
    name = message.text.strip()
    await state.update_data(name=name)
    # Send age selection keyboard (13..60)
    inline_keyboard = []
    row = []
    for age_val in range(13, 61):
        row.append(InlineKeyboardButton(text=str(age_val), callback_data=f"age:{age_val}"))
        if len(row) == 6:
            inline_keyboard.append(row)
            row = []
    if row:
        inline_keyboard.append(row)
    inline_keyboard.append([InlineKeyboardButton(text="Ввести вручную", callback_data="age:manual")])
    kb = InlineKeyboardMarkup(inline_keyboard=inline_keyboard)
    await message.answer("Выберите ваш возраст (нажмите кнопку) или введите вручную:", reply_markup=kb)
    await state.set_state(Registration.ask_age_buttons)

@dp.callback_query(Text(startswith="age:"))
async def cb_age_select(callback: types.CallbackQuery, state: FSMContext):
    data = callback.data.split(":",1)[1]
    if data == 'manual':
        await callback.message.answer("Пожалуйста, введите ваш возраст цифрами (например: 25)")
        await state.set_state(Registration.ask_age_manual)
        await callback.answer()
        return
    try:
        age = int(data)
    except Exception:
        await callback.answer("Некорректный возраст.", show_alert=True)
        return
    await state.update_data(age=age)
    await callback.message.answer("Введите ваш ник (имя в клане):")
    await state.set_state(Registration.ask_nick)
    await callback.answer()

@dp.message(Registration.ask_age_manual)
async def age_manual_received(message: types.Message, state: FSMContext):
    txt = message.text.strip()
    try:
        age = int(txt)
    except ValueError:
        await message.answer("Пожалуйста, введите возраст цифрами.")
        return
    await state.update_data(age=age)
    await message.answer("Введите ваш ник (имя в клане):")
    await state.set_state(Registration.ask_nick)

@dp.message(Registration.ask_nick)
async def nick_received(message: types.Message, state: FSMContext):
    nick = message.text.strip()
    await state.update_data(nick=nick)
    await message.answer("Введите ваш Discord (например: ник#1234):")
    await state.set_state(Registration.ask_discord)

@dp.message(Registration.ask_discord)
async def discord_received(message: types.Message, state: FSMContext):
    discord = message.text.strip()
    await state.update_data(discord=discord)
    await message.answer("Введите ваш SteamID (или ссылку на профиль):")
    await state.set_state(Registration.ask_steam)

@dp.message(Registration.ask_steam)
async def steam_received(message: types.Message, state: FSMContext):
    steam = message.text.strip()
    await state.update_data(steamid=steam)
    await message.answer("Введите ваш часовой пояс (например: Europe/Moscow или UTC+3):")
    await state.set_state(Registration.ask_timezone)

@dp.message(Registration.ask_timezone)
async def timezone_received(message: types.Message, state: FSMContext):
    tz = message.text.strip()
    data = await state.get_data()
    phone = data.get('phone')
    name = data.get('name')
    age = data.get('age')
    nick = data.get('nick')
    discord = data.get('discord')
    steamid = data.get('steamid')
    tg_id = message.from_user.id

    # Save member provisional data
    await save_member(tg_id, phone, name, age, nick, discord, steamid, tz)

    # Send links to publics and buttons to recheck subscription
    text = "Спасибо! Чтобы завершить регистрацию, пожалуйста подпишитесь на наши паблики: 
"
    for ch in CHANNEL_USERNAMES:
        text += f"{ch}
"
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Проверить подписку", callback_data=f"checksub:{tg_id}"), InlineKeyboardButton(text="Отправить заявку на проверку", callback_data=f"request_review:{tg_id}")]
    ])
    await message.answer(text, reply_markup=kb)

    # Add approval request and initial check
    await add_approval_request(tg_id)

    await message.answer("Мы уведомили модераторов для проверки вашей заявки. Ожидайте одобрения.")
    await state.clear()

@dp.callback_query(Text(startswith="checksub:"))
async def cb_check_subscription(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    ok = await check_subscriptions(tg_id)
    if ok:
        await callback.answer("Подписки в порядке.")
    else:
        await callback.answer("Не все подписки обнаружены. Пожалуйста, подпишитесь на указанные паблики.")

@dp.callback_query(Text(startswith="request_review:"))
async def cb_request_review(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    mem = await get_member(tg_id)
    nick = mem.get('nick') if mem else str(tg_id)
    subs_ok = await check_subscriptions(tg_id)
    await notify_reviewers_of_request(tg_id, nick, subs_ok)
    await callback.answer("Заявка отправлена модераторам.")

async def check_subscriptions(tg_id: int) -> bool:
    ok = True
    for ch in CHANNEL_USERNAMES:
        try:
            member = await bot.get_chat_member(ch, tg_id)
            status = member.status
            if status in ("left", "kicked"):
                ok = False
        except Exception as e:
            logger.warning(f"Failed to verify subscription for {ch}: {e}")
            ok = False
    return ok

async def notify_reviewers_of_request(tg_id:int, nick:str, subs_ok:bool):
    inline = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Одобрить", callback_data=f"approve:{tg_id}"), InlineKeyboardButton(text="Отклонить", callback_data=f"reject:{tg_id}")]
    ])
    text = f"Новая заявка: {nick} (ID {tg_id})
Подписки в порядке: {subs_ok}
Нажмите кнопку для одобрения/отклонения."
    recipients = set(ADMIN_IDS + MODERATOR_IDS)
    for r in recipients:
        try:
            await bot.send_message(r, text, reply_markup=inline)
        except Exception as e:
            logger.exception(f"Failed to notify reviewer {r}: {e}")

# Callback handlers for approval
@dp.callback_query(Text(startswith="approve:"))
async def cb_approve(callback: types.CallbackQuery):
    user = callback.from_user
    if not is_moderator(user.id):
        await callback.answer("Только модераторы/админы могут принимать заявки.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    await set_approval_status(tg_id, 'approved', user.id)
    try:
        await bot.send_message(tg_id, f"Ваша заявка одобрена! Ссылка на чат: {CLAN_CHAT_INVITE_LINK}")
    except Exception as e:
        logger.warning(f"Could not send invite to {tg_id}: {e}")
    await callback.message.edit_text(callback.message.text + f"
Одобрено модератором {user.full_name}")
    await callback.answer("Заявка одобрена.")

@dp.callback_query(Text(startswith="reject:"))
async def cb_reject(callback: types.CallbackQuery):
    user = callback.from_user
    if not is_moderator(user.id):
        await callback.answer("Только модераторы/админы могут отклонять заявки.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    await set_approval_status(tg_id, 'rejected', user.id)
    await bot.send_message(tg_id, "К сожалению, ваша заявка отклонена. Для уточнений свяжитесь с администрацией.")
    await callback.message.edit_text(callback.message.text + f"
Отклонено модератором {user.full_name}")
    await callback.answer("Заявка отклонена.")

# Detect when member joins the clan chat and announce
@dp.chat_member()
async def chat_member_update(event: ChatMemberUpdated):
    try:
        if CLAN_CHAT_ID and event.chat.id != CLAN_CHAT_ID:
            return
        old = event.old_chat_member
        new = event.new_chat_member
        user = event.from_user
        if old.status in ("left", "kicked") and new.status in ("member", "administrator", "creator"):
            info = await get_member(user.id)
            nick = info['nick'] if info else user.full_name
            await event.bot.send_message(event.chat.id, f"{nick} вступил в наш клан!")
            await set_member_join_date(user.id, datetime.utcnow().isoformat())
    except Exception as e:
        logger.exception(f"chat_member_update error: {e}")

# --------------------------- Menu and moderator flows --------------
@dp.message(Command(commands=["menu"]))
async def cmd_menu(message: types.Message):
    user_id = message.from_user.id
    kb = InlineKeyboardMarkup(inline_keyboard=[])
    # Common user buttons
    kb.inline_keyboard.append([InlineKeyboardButton(text="Мой профиль", callback_data=f"profile:{user_id}"), InlineKeyboardButton(text="Проверить подписку", callback_data=f"checksub:{user_id}")])
    kb.inline_keyboard.append([InlineKeyboardButton(text="Повторно отправить заявку на проверку", callback_data=f"request_review:{user_id}")])
    # Moderator-specific
    if is_moderator(user_id):
        kb.inline_keyboard.append([InlineKeyboardButton(text="🛠 Одобрить заявки", callback_data="approve_requests")])
        kb.inline_keyboard.append([InlineKeyboardButton(text="📋 Список участников", callback_data="list_members_cb")])
    # Admin-specific
    if is_admin(user_id):
        kb.inline_keyboard.append([InlineKeyboardButton(text="⭐ Добавить модератора", callback_data="promote_member")])
    await message.answer("Меню:", reply_markup=kb)

@dp.callback_query(Text(equals="approve_requests"))
async def cb_approve_requests(callback: types.CallbackQuery):
    if not is_moderator(callback.from_user.id):
        await callback.answer("Доступно только модераторам.", show_alert=True)
        return
    pending = await get_pending_approvals()
    if not pending:
        await callback.answer("Нет ожидающих заявок.")
        return
    for p in pending:
        tg_id = p['tg_id']
        nick = p.get('nick') or p.get('name') or str(tg_id)
        inline = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Одобрить", callback_data=f"approve:{tg_id}"), InlineKeyboardButton(text="Отклонить", callback_data=f"reject:{tg_id}")]
        ])
        await callback.message.answer(f"Заявка: {nick} (ID {tg_id})", reply_markup=inline)
    await callback.answer()

@dp.callback_query(Text(equals="list_members_cb"))
async def cb_list_members(callback: types.CallbackQuery):
    if not is_moderator(callback.from_user.id):
        await callback.answer("Доступно только модераторам.", show_alert=True)
        return
    rows = await list_members()
    if not rows:
        await callback.message.answer("Нет зарегистрированных участников.")
        return
    # build inline keyboard with small pages (here simply list up to 50)
    kb_lines = []
    for r in rows:
        label = f"{r['nick'] or 'без ника'} ({r['tg_id']})"
        kb_lines.append([InlineKeyboardButton(text=label, callback_data=f"view_member:{r['tg_id']}")])
    kb = InlineKeyboardMarkup(inline_keyboard=kb_lines)
    await callback.message.answer("Список участников (нажмите для просмотра):", reply_markup=kb)
    await callback.answer()

@dp.callback_query(Text(startswith="view_member:"))
async def cb_view_member(callback: types.CallbackQuery):
    if not is_moderator(callback.from_user.id):
        await callback.answer("Доступно только модераторам.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    member = await get_member(tg_id)
    if not member:
        await callback.answer("Участник не найден.", show_alert=True)
        return
    text = f"Информация об участнике:
ID: {member.get('tg_id')}
Имя: {member.get('name')}
Возраст: {member.get('age')}
Ник: {member.get('nick')}
Discord: {member.get('discord')}
SteamID: {member.get('steamid')}
Часовой пояс: {member.get('timezone')}
Фракции: {member.get('factions')}
Должности: {member.get('roles')}
Резерв: {member.get('is_reserve')}
Дата вступления: {member.get('join_date')}"
    # action buttons
    actions = []
    actions.append(InlineKeyboardButton(text="Добавить фракцию", callback_data=f"add_faction_to:{tg_id}"))
    actions.append(InlineKeyboardButton(text="Добавить подразделение", callback_data=f"add_division_to:{tg_id}"))
    actions.append(InlineKeyboardButton(text="Добавить в резерв", callback_data=f"to_reserve_cb:{tg_id}"))
    actions.append(InlineKeyboardButton(text="Удалить участника", callback_data=f"remove_member_cb:{tg_id}"))
    row_actions = [actions[i:i+2] for i in range(0, len(actions), 2)]
    kb = InlineKeyboardMarkup(inline_keyboard=row_actions)
    # admin extra
    if is_admin(callback.from_user.id):
        kb.inline_keyboard.append([InlineKeyboardButton(text="Назначить модератором", callback_data=f"promote_to_mod:{tg_id}"), InlineKeyboardButton(text="Снять модератора", callback_data=f"demote_from_mod:{tg_id}")])
    await callback.message.answer(text, reply_markup=kb)
    await callback.answer()

# Add faction flow
@dp.callback_query(Text(startswith="add_faction_to:"))
async def cb_add_faction_to(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    factions = ["Blueberry", "Cranberry", "Watermelon", "Рекрут", "Резерв"]
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=f, callback_data=f"set_faction:{tg_id}:{f}") for f in factions[:3]]])
    kb.inline_keyboard.append([InlineKeyboardButton(text=factions[3], callback_data=f"set_faction:{tg_id}:{factions[3]}"), InlineKeyboardButton(text=factions[4], callback_data=f"set_faction:{tg_id}:{factions[4]}")])
    await callback.message.answer("Выберите фракцию:", reply_markup=kb)
    await callback.answer()

@dp.callback_query(Text(startswith="set_faction:"))
async def cb_set_faction(callback: types.CallbackQuery):
    _, rest = callback.data.split(':',1)
    tg_id_str, faction = rest.split(':',1)
    tg_id = int(tg_id_str)
    mem = await get_member(tg_id)
    if not mem:
        await callback.answer("Участник не найден.", show_alert=True)
        return
    factions = mem.get('factions') or ''
    if faction in (f.strip() for f in (factions or '').split(',')):
        await callback.answer("Фракция уже указана.")
        return
    new = (factions + ',' + faction).strip(',') if factions else faction
    await update_member_fields(tg_id, factions=new)
    await callback.answer(f"Фракция '{faction}' добавлена.")

# Add division flow (roles)
@dp.callback_query(Text(startswith="add_division_to:"))
async def cb_add_division_to(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    roles = ["Командир фракции", "Офицер", "Модератор сервера", "Администратор сервера", "HR"]
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=r, callback_data=f"set_role:{tg_id}:{r}")] for r in roles])
    await callback.message.answer("Выберите должность (нажатие добавит должность):", reply_markup=kb)
    await callback.answer()

@dp.callback_query(Text(startswith="set_role:"))
async def cb_set_role(callback: types.CallbackQuery):
    _, rest = callback.data.split(':',1)
    tg_id_str, role = rest.split(':',1)
    tg_id = int(tg_id_str)
    mem = await get_member(tg_id)
    if not mem:
        await callback.answer("Участник не найден.", show_alert=True)
        return
    roles = mem.get('roles') or ''
    if role in (r.strip() for r in (roles or '').split(',')):
        await callback.answer("Должность уже указана.")
        return
    new = (roles + ',' + role).strip(',') if roles else role
    await update_member_fields(tg_id, roles=new)
    await callback.answer(f"Должность '{role}' добавлена.")

# To reserve
@dp.callback_query(Text(startswith="to_reserve_cb:"))
async def cb_to_reserve(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    await update_member_fields(tg_id, is_reserve=1)
    await callback.answer("Участник добавлен в резерв.")

# Remove member
@dp.callback_query(Text(startswith="remove_member_cb:"))
async def cb_remove_member(callback: types.CallbackQuery):
    tg_id = int(callback.data.split(':',1)[1])
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM members WHERE tg_id = ?", (tg_id,))
        await db.commit()
    await callback.answer("Участник удалён из базы.")

# Promote/demote moderator
@dp.callback_query(Text(startswith="promote_to_mod:"))
async def cb_promote_to_mod(callback: types.CallbackQuery):
    if not is_admin(callback.from_user.id):
        await callback.answer("Только администратор может назначать модераторов.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    if tg_id not in MODERATOR_IDS:
        MODERATOR_IDS.append(tg_id)
    await callback.answer("Пользователь назначен модератором.")

@dp.callback_query(Text(startswith="demote_from_mod:"))
async def cb_demote_from_mod(callback: types.CallbackQuery):
    if not is_admin(callback.from_user.id):
        await callback.answer("Только администратор может снимать модераторов.", show_alert=True)
        return
    tg_id = int(callback.data.split(':',1)[1])
    if tg_id in MODERATOR_IDS:
        MODERATOR_IDS.remove(tg_id)
    await callback.answer("Пользователь лишён статуса модератора.")

# --------------------------- Moderator/Admin commands (backwards compatible) ------------------
@dp.message(Command(commands=["list_members"]))
async def cmd_list_members(message: types.Message):
    if not is_moderator(message.from_user.id):
        await message.reply("Только модераторы и администраторы могут использовать эту команду.")
        return
    rows = await list_members()
    if not rows:
        await message.reply("Нет зарегистрированных участников.")
        return
    text = "Список участников:
"
    for r in rows:
        text += f"ID: {r['tg_id']} — {r['nick']} — фракции:{r['factions']} — должности:{r['roles']} — резерв:{r['is_reserve']} — joined:{r['join_date']}
"
    await message.reply(text)

# --------------------------- Attendance survey ----------------------
async def send_daily_survey():
    logger.info("Отправка ежедневного опроса о тренировке всем участникам")
    rows = await list_members()
    for r in rows:
        tg_id = r['tg_id']
        text = "Будешь ли ты сегодня на тренировке?"
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да", callback_data=f"att:{date.today().isoformat()}:yes")],
            [InlineKeyboardButton(text="Нет", callback_data=f"att:{date.today().isoformat()}:no")],
            [InlineKeyboardButton(text="Опоздаю", callback_data=f"att:{date.today().isoformat()}:late")]
        ])
        try:
            await bot.send_message(tg_id, text, reply_markup=kb)
        except Exception as e:
            logger.warning(f"Could not send survey to {tg_id}: {e}")

@dp.callback_query(Text(startswith="att:"))
async def cb_attendance(callback: types.CallbackQuery, state: FSMContext):
    _, for_date, answer = callback.data.split(":", 2)
    tg_id = callback.from_user.id
    if answer == 'no':
        await callback.message.answer("Почему тебя не будет на тренировке?")
        await state.set_state(AttendanceReason.waiting_reason)
        await state.update_data(pending_att_date=for_date)
        await callback.answer()
    else:
        await record_attendance(tg_id, date.fromisoformat(for_date), answer)
        await callback.answer("Ответ сохранён. Спасибо!")

@dp.message(AttendanceReason.waiting_reason)
async def reason_received(message: types.Message, state: FSMContext):
    data = await state.get_data()
    for_date = data.get('pending_att_date')
    reason = message.text.strip()
    await record_attendance(message.from_user.id, date.fromisoformat(for_date), 'no', reason)
    await message.answer("Спасибо, причина записана.")
    await state.clear()

async def send_daily_stats():
    the_date = date.today()
    summary = await attendance_summary_for_date(the_date)
    yes = summary.get('yes', 0)
    no = summary.get('no', 0)
    late = summary.get('late', 0)
    unanswered = await unanswered_members_for_date(the_date)
    text = f"Статистика по тренировке за {the_date.isoformat()}:
Придут: {yes}
Не придут: {no}
Опоздают: {late}
Не ответили: {len(unanswered)}
"
    if unanswered:
        text += "Список неответивших:
"
        for u in unanswered:
            text += f"{u['nick']} — ID:{u['tg_id']}
"
    for admin in ADMIN_IDS:
        try:
            await bot.send_message(admin, text)
        except Exception as e:
            logger.warning(f"Failed sending stats to admin {admin}: {e}")

async def check_three_day_nonanswers():
    arr = await consecutive_nonanswers(3)
    if not arr:
        return
    text = "Внимание: следующие пользователи не отвечали на опросы в течение 3-х дней:
"
    for u in arr:
        text += f"{u['nick']} — ID:{u['tg_id']}
"
    recipients = set(ADMIN_IDS + MODERATOR_IDS)
    for r in recipients:
        try:
            await bot.send_message(r, text)
        except Exception as e:
            logger.warning(f"Failed notify nonanswer to {r}: {e}")

# --------------------------- Scheduler setup -----------------------
scheduler = AsyncIOScheduler(timezone=MSK_TZ)

async def start_scheduler():
    scheduler.add_job(lambda: asyncio.create_task(send_daily_survey()), CronTrigger(hour=15, minute=0))
    scheduler.add_job(lambda: asyncio.create_task(send_daily_stats()), CronTrigger(hour=19, minute=0))
    scheduler.add_job(lambda: asyncio.create_task(check_three_day_nonanswers()), CronTrigger(hour=20, minute=0))
    scheduler.start()

# --------------------------- Startup / Shutdown --------------------
async def on_startup():
    await init_db()
    await start_scheduler()
    logger.info("Бот запущен, БД и планировщик инициализированы.")

async def on_shutdown():
    await bot.session.close()

# --------------------------- Running ------------------------------
if __name__ == '__main__':
    try:
        loop = asyncio.get_event_loop()
        loop.create_task(on_startup())
        dp.run_polling(bot)
    except (KeyboardInterrupt, SystemExit):
        logger.info("Shutting down...")
        loop.run_until_complete(on_shutdown())
