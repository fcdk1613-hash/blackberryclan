# main.py
# aiogram 3.x bot for Blackberry clan onboarding
# Adds: internal ClanID, DM review, factions, DOB. Reports/CSV.
# Removal checklist updated: items 1 (DB) and 3 (Discord) are MANUAL via "Выполнено".
# Only item 2 (remove from Telegram clan chat) is automatic.
import asyncio
import logging
from datetime import datetime, timedelta, date
from enum import Enum
from typing import Optional, Tuple, List

import aiosqlite
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart, or_f, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    Message,
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    CallbackQuery,
    ChatInviteLink,
    FSInputFile,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder

# ======= CONFIG =======
BOT_TOKEN = ""                     # ← token from @BotFather (required)
CHANNEL_USERNAME = "@SquadBlackBerry"
CLAN_CHAT_ID = 0                   # -100...
MODERATION_CHAT_ID = 0             # optional: join notifications

ADMIN_IDS = set()                  # {111, 222}
MODERATOR_IDS = set()              # {333}

DB_PATH = "blackberry_bot.db"

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set in code (fill BOT_TOKEN at the top of main.py)")

# ======= DB LAYER =======
CREATE_USERS_SQL = """
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    clan_id INTEGER,
    phone TEXT,
    nickname TEXT,
    discord TEXT,
    steamid TEXT,
    age INTEGER,
    birth_date TEXT,
    timezone TEXT,
    tg_link TEXT,
    faction TEXT,
    status TEXT,
    created_at TEXT,
    applied_at TEXT,
    approved_at TEXT,
    joined_at TEXT
);
"""
CREATE_USERS_ARCHIVE_SQL = """
CREATE TABLE IF NOT EXISTS users_archive AS
SELECT user_id, clan_id, phone, nickname, discord, steamid, age, birth_date, timezone, tg_link,
       faction, status, created_at, applied_at, approved_at, joined_at,
       '' AS archived_at
FROM users WHERE 0;
"""
CREATE_REMOVE_TABLE_SQL = """
CREATE TABLE IF NOT EXISTS removal_checklist (
    user_id INTEGER PRIMARY KEY,
    db_done INTEGER DEFAULT 0,
    tg_done INTEGER DEFAULT 0,
    discord_done INTEGER DEFAULT 0
);
"""

class Status(str, Enum):
    NEW = "new"
    PENDING_CHANNEL = "pending_channel"
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    JOINED = "joined"
    REMOVED = "removed"

FACTIONS = {
    "cran": "Cranberry",
    "blue": "Blueberry",
    "water": "Watermelon",
    "recruit": "Рекрут",
    "reserve": "Резерв",
    "command": "Командование",
}

def faction_tuple_list() -> Tuple[Tuple[str, str], ...]:
    return (
        ("cran", "Cranberry"),
        ("blue", "Blueberry"),
        ("water", "Watermelon"),
        ("recruit", "Рекрут"),
        ("reserve", "Резерв"),
        ("command", "Командование"),
    )

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(CREATE_USERS_SQL)
        await db.execute(CREATE_USERS_ARCHIVE_SQL)
        await db.execute(CREATE_REMOVE_TABLE_SQL)
        # Migrations
        for alter in [
            "ALTER TABLE users ADD COLUMN applied_at TEXT",
            "ALTER TABLE users ADD COLUMN birth_date TEXT",
            "ALTER TABLE users ADD COLUMN faction TEXT",
            "ALTER TABLE users ADD COLUMN clan_id INTEGER",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE users_archive ADD COLUMN archived_at TEXT",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE removal_checklist ADD COLUMN db_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN tg_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN discord_done INTEGER DEFAULT 0",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        await db.commit()
    await ensure_clan_ids()

async def ensure_clan_ids():
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) FROM users")
        (max_clan_id,) = await cur.fetchone()
        cur = await db.execute("SELECT user_id FROM users WHERE clan_id IS NULL ORDER BY rowid")
        rows = await cur.fetchall()
        next_id = max_clan_id + 1
        changed = False
        for (uid,) in rows:
            await db.execute("UPDATE users SET clan_id=? WHERE user_id=?", (next_id, uid))
            next_id += 1
            changed = True
        if changed:
            await db.commit()

async def next_clan_id(db: aiosqlite.Connection) -> int:
    cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) + 1 FROM users")
    (nid,) = await cur.fetchone()
    return int(nid)

async def upsert_user(user_id: int, **fields):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id, clan_id FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if row:
            cols = ", ".join([f"{k}=?" for k in fields.keys()])
            vals = list(fields.values()) + [user_id]
            await db.execute(f"UPDATE users SET {cols} WHERE user_id=?", vals)
        else:
            cid = await next_clan_id(db)
            keys = ["user_id", "clan_id", *fields.keys()]
            placeholders = ",".join(["?"] * len(keys))
            vals = [user_id, cid, *fields.values()]
            await db.execute(
                f"INSERT INTO users ({','.join(keys)}) VALUES ({placeholders})",
                vals,
            )
        await db.commit()

async def get_user(user_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def get_user_by_username(username: str) -> Optional[dict]:
    uname = username.lstrip("@")
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE (tg_link LIKE ?) OR (LOWER(nickname)=LOWER(?)) LIMIT 1",
            (f"%t.me/{uname}%", uname,)
        )
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def search_users_by_nickname(q: str, limit: int = 10) -> List[dict]:
    q = q.strip()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE nickname LIKE ? ORDER BY created_at DESC LIMIT ?",
            (f"%{q}%", limit)
        )
        rows = await cur.fetchall()
        columns = [col[0] for col in cur.description]
        return [dict(zip(columns, r)) for r in rows]

# ======= FSM =======
class RegStates(StatesGroup):
    waiting_phone = State()
    waiting_nickname = State()
    waiting_discord = State()
    waiting_steam = State()
    waiting_birthdate = State()
    waiting_tz = State()
    waiting_tg_link = State()

# ======= BOT SETUP =======
logging.basicConfig(level=logging.INFO)
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher()

def phone_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="📱 Отправить номер", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="Нажмите, чтобы поделиться номером",
    )

def subscription_check_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="🔔 Проверить подписку", callback_data="check_sub")
    return kb.as_markup()

def apply_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="📨 Отправить заявку", callback_data="send_apply")
    return kb.as_markup()

def profile_admin_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="🎯 Выбрать фракцию", callback_data=f"profile_choosefac:{user_id}")
    kb.button(text="🗑 Удалить игрока", callback_data=f"remove:init:{user_id}")
    kb.row()
    kb.button(text="🔄 Обновить", callback_data=f"profile_refresh:{user_id}")
    return kb.as_markup()

def faction_choose_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("cran","Cranberry"),("blue","Blueberry"),("water","Watermelon")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("recruit","Рекрут"),("reserve","Резерв"),("command","Командование")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    kb.button(text="⬅️ Назад к профилю", callback_data=f"profile_back:{user_id}")
    return kb.as_markup()

def approve_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="✅ Принять", callback_data=f"approve:{user_id}")
    kb.button(text="❌ Отклонить", callback_data=f"reject:{user_id}")
    return kb.as_markup()

def pad_clan_id(v: Optional[int]) -> str:
    if not v:
        return "—"
    return f"{int(v):04d}"

def format_profile(user: dict, title: str = "Профиль игрока") -> str:
    lines = [f"<b>{title}</b>"]
    fields = [
        ("ClanID", pad_clan_id(user.get("clan_id"))),
        ("Telegram ID", user.get("user_id")),
        ("Ник", user.get("nickname")),
        ("Discord", user.get("discord")),
        ("SteamID", user.get("steamid")),
        ("Дата рождения", user.get("birth_date")),
        ("Возраст", user.get("age")),
        ("Часовой пояс", user.get("timezone")),
        ("Личный TG", user.get("tg_link")),
        ("Фракция", user.get("faction")),
        ("Статус", user.get("status")),
        ("Создан", user.get("created_at")),
        ("Заявка", user.get("applied_at")),
        ("Одобрен", user.get("approved_at")),
        ("Вступил", user.get("joined_at")),
    ]
    for k, v in fields:
        if v not in (None, "", "None"):
            lines.append(f"{k}: {v}")
    return "\n".join(lines)

# ======= HELPERS =======
async def is_subscribed(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        return member.status in ("member", "administrator", "creator")
    except Exception as e:
        logging.exception("Failed to check subscription: %r", e)
        return False

def reviewer_ids() -> List[int]:
    return sorted(set(ADMIN_IDS) | set(MODERATOR_IDS))

async def send_application_to_all(text: str, user_id: int):
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, text, reply_markup=approve_kb(user_id))
        except Exception as e:
            logging.warning("Cannot DM reviewer %s: %r", rid, e)

async def notify_review_outcome(user_id: int, outcome: str):
    label = "✅ Одобрено" if outcome == "approved" else "❌ Отклонено"
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, f"{label}: заявка пользователя <code>{user_id}</code> уже обработана.")
        except Exception:
            pass

async def send_to_moderation(text: str, reply_markup: Optional[InlineKeyboardMarkup] = None):
    if MODERATION_CHAT_ID:
        try:
            await bot.send_message(MODERATION_CHAT_ID, text, reply_markup=reply_markup)
        except Exception:
            pass

async def create_invite_link() -> Optional[ChatInviteLink]:
    try:
        link = await bot.create_chat_invite_link(
            chat_id=CLAN_CHAT_ID,
            name=f"Onboarding {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            creates_join_request=False,
            expire_date=None,
            member_limit=1,
        )
        return link
    except Exception as e:
        logging.exception("Cannot create invite link: %r", e)
        return None

# ======= Removal checklist (manual for items 1 and 3) =======
async def ensure_removal_record(user_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id) VALUES(?) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        await db.commit()

def removal_kb(user_id: int, done_db: bool, done_tg: bool, done_discord: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text=("✅ 1. Проверено (таблица)" if done_db else "1. Выполнено (таблица)"), callback_data=f"remove:dbdone:{user_id}")
    kb.button(text=("✅ 2. Удалён из клан-чата" if done_tg else "2. Удалить из клан-чата"), callback_data=f"remove:tg:{user_id}")
    kb.row()
    kb.button(text=("✅ 3. Проверено (Discord)" if done_discord else "3. Выполнено (Discord)"), callback_data=f"remove:discdone:{user_id}")
    kb.row()
    kb.button(text="⬅️ Назад к профилю", callback_data=f"profile_back:{user_id}")
    return kb.as_markup()

async def removal_state(user_id: int) -> tuple[bool, bool, bool]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT db_done, tg_done, discord_done FROM removal_checklist WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
    if row:
        return bool(row[0]), bool(row[1]), bool(row[2])
    return False, False, False

def removal_text(user: Optional[dict], done_db: bool, done_tg: bool, done_discord: bool) -> str:
    title = "<b>Удаление игрока — чек-лист</b>"
    if user:
        header = f"ClanID: <code>{pad_clan_id(user.get('clan_id'))}</code> | ID: <code>{user.get('user_id')}</code> | Ник: {user.get('nickname') or '-'}"
    else:
        header = f"ID: <code>{user}</code>"
    def mark(b): return "✅" if b else "☐"
    lines = [
        title,
        header,
        "",
        f"{mark(done_db)} 1) Проверить: игрок удалён из таблицы БД (отмечается вручную кнопкой «Выполнено (таблица)»).",
        f"{mark(done_tg)} 2) Удалить из клан-чата Telegram (выполняет бот по кнопке).",
        f"{mark(done_discord)} 3) Проверить: игрок удалён из Discord (отмечается вручную кнопкой «Выполнено (Discord)»).",
    ]
    return "\n".join(lines)

# ======= HANDLERS =======
@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if user and user.get("status") in (Status.APPROVED, Status.JOINED):
        await message.answer("Вы уже зарегистрированы. Используйте /profile, чтобы посмотреть данные.")
        return

    await upsert_user(
        message.from_user.id,
        status=Status.NEW.value,
        created_at=datetime.utcnow().isoformat(),
    )
    await ensure_clan_ids()
    await message.answer(
        "Привет! Я бот клана Blackberry. Для начала регистрации поделитесь номером телефона:",
        reply_markup=phone_kb(),
    )
    await state.set_state(RegStates.waiting_phone)

@dp.message(RegStates.waiting_phone, F.contact)
async def got_phone(message: Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("Отлично! Введите ник (реальное имя):", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_nickname)

@dp.message(RegStates.waiting_phone)
async def need_phone(message: Message):
    await message.answer("Пожалуйста, нажмите кнопку и поделитесь номером телефона.", reply_markup=phone_kb())

@dp.message(RegStates.waiting_nickname)
async def got_nick(message: Message, state: FSMContext):
    await state.update_data(nickname=message.text.strip())
    await message.answer("Введите Discord:")
    await state.set_state(RegStates.waiting_discord)

@dp.message(RegStates.waiting_discord)
async def got_discord(message: Message, state: FSMContext):
    await state.update_data(discord=message.text.strip())
    await message.answer("Введите SteamID:")
    await state.set_state(RegStates.waiting_steam)

@dp.message(RegStates.waiting_steam)
async def got_steam(message: Message, state: FSMContext):
    await state.update_data(steamid=message.text.strip())
    await message.answer("Введите дату рождения (в формате ДД.ММ.ГГГГ):")
    await state.set_state(RegStates.waiting_birthdate)

@dp.message(RegStates.waiting_birthdate)
async def got_birthdate(message: Message, state: FSMContext):
    text = message.text.strip()
    try:
        birth_date = datetime.strptime(text, "%d.%m.%Y").date()
        if birth_date > date.today():
            raise ValueError("future")
    except Exception:
        await message.answer("❌ Неверный формат. Введите дату рождения как ДД.ММ.ГГГГ (например, 15.08.1995).")
        return

    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))

    await state.update_data(birth_date=birth_date.isoformat(), age=age)
    await message.answer(f"✅ Принято. Ваш возраст: {age}.\nВведите часовой пояс (например, GMT+3 или Europe/Moscow):")
    await state.set_state(RegStates.waiting_tz)

@dp.message(RegStates.waiting_tz)
async def got_tz(message: Message, state: FSMContext):
    await state.update_data(timezone=message.text.strip())
    await message.answer("Введите ссылку на ваш личный Telegram (например, https://t.me/username):")
    await state.set_state(RegStates.waiting_tg_link)

@dp.message(RegStates.waiting_tg_link)
async def got_tg_link(message: Message, state: FSMContext):
    data = await state.update_data(tg_link=message.text.strip())
    data = await state.get_data()

    await upsert_user(
        message.from_user.id,
        phone=data.get("phone"),
        nickname=data.get("nickname"),
        discord=data.get("discord"),
        steamid=data.get("steamid"),
        age=data.get("age"),
        birth_date=data.get("birth_date"),
        timezone=data.get("timezone"),
        tg_link=data.get("tg_link"),
        status=Status.PENDING_CHANNEL.value,
    )
    await ensure_clan_ids()

    preview = (
        f"<b>Проверьте данные</b>\n"
        f"Ник: {data.get('nickname')}\n"
        f"Discord: {data.get('discord')}\n"
        f"SteamID: {data.get('steamid')}\n"
        f"Дата рождения: {data.get('birth_date')}\n"
        f"Возраст (по дате): {data.get('age')}\n"
        f"Часовой пояс: {data.get('timezone')}\n"
        f"Личный TG: {data.get('tg_link')}\n\n"
        f"Подпишитесь на канал новостей: {CHANNEL_USERNAME}"
    )

    await message.answer(preview)
    await message.answer(
        "После подписки нажмите кнопку ниже:",
        reply_markup=subscription_check_kb(),
    )
    await state.clear()

# Subscription
@dp.callback_query(F.data == "check_sub")
async def on_check_sub(call: CallbackQuery):
    uid = call.from_user.id
    if await is_subscribed(uid):
        await upsert_user(uid, status=Status.PENDING_REVIEW.value)
        await call.message.edit_text(
            "Подписка подтверждена. Теперь отправьте заявку на вступление.",
            reply_markup=apply_kb(),
        )
    else:
        await call.answer("Сначала подпишитесь на канал @SquadBlackBerry", show_alert=True)

# Send application to ALL reviewers in DMs
@dp.callback_query(F.data == "send_apply")
async def on_send_apply(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not user or user.get("status") != Status.PENDING_REVIEW.value:
        await call.answer("Сначала подтвердите подписку.", show_alert=True)
        return

    await upsert_user(uid, applied_at=datetime.utcnow().isoformat())
    user = await get_user(uid)
    clan_id = pad_clan_id(user.get("clan_id"))

    text = (
        f"<b>Новая заявка в клан</b>\n"
        f"ClanID: <code>{clan_id}</code>\n"
        f"Telegram ID: <code>{uid}</code>\n"
        f"Ник: {user.get('nickname')}\n"
        f"Discord: {user.get('discord')}\n"
        f"SteamID: {user.get('steamid')}\n"
        f"Дата рождения: {user.get('birth_date') or '-'}\n"
        f"Возраст: {user.get('age') or '-'}\n"
        f"Часовой пояс: {user.get('timezone')}\n"
        f"Личный TG: {user.get('tg_link')}\n"
        f"Фракция: {user.get('faction') or '— (выберите в профиле игрока)'}\n"
    )
    await send_application_to_all(text, uid)
    await call.message.edit_text("Заявка отправлена администраторам и модераторам. Ожидайте решения.")

# ======= Moderation/Profile flow =======
@dp.message(Command("player"))
async def cmd_player(message: Message, command: Command):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("Только модераторы/администраторы.")
        return
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("Использование: /player <user_id | @username | часть ника>")
        return
    query = args[1].strip()

    target_user: Optional[dict] = None
    if query.isdigit():
        target_user = await get_user(int(query))
    if not target_user and query.startswith("@"):
        target_user = await get_user_by_username(query)
    if not target_user:
        matches = await search_users_by_nickname(query, limit=10)
        if len(matches) == 1:
            target_user = matches[0]
        elif len(matches) > 1:
            lines = ["Найдено несколько пользователей:"]
            for u in matches:
                lines.append(f"• {u.get('nickname') or '-'} — ClanID: {pad_clan_id(u.get('clan_id'))} — ID: <code>{u['user_id']}</code> — фракция: {u.get('faction') or '-'}")
            lines.append("\nУточните: /player <ID>")
            await message.answer("\n".join(lines))
            return

    if not target_user:
        await message.answer("Пользователь не найден.")
        return

    await message.answer(format_profile(target_user), reply_markup=profile_admin_kb(target_user["user_id"]))

@dp.callback_query(F.data.startswith("profile_refresh:"))
async def on_profile_refresh(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("Пользователь не найден.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer("Профиль обновлён.")

@dp.callback_query(F.data.startswith("profile_choosefac:"))
async def on_profile_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("Пользователь не найден.", show_alert=True)
        return
    text = format_profile(user, title="Выбор фракции")
    try:
        await call.message.edit_text(text + "\n\nВыберите фракцию:", reply_markup=faction_choose_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("profile_back:"))
async def on_profile_back(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("Пользователь не найден.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("facset:"))
async def on_profile_set_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    try:
        _, uid_str, code = call.data.split(":")
        target_id = int(uid_str)
        title = {"cran":"Cranberry","blue":"Blueberry","water":"Watermelon","recruit":"Рекрут","reserve":"Резерв","command":"Командование"}.get(code)
        if not title:
            raise ValueError("unknown faction code")
    except Exception:
        await call.answer("Некорректные данные.", show_alert=True)
        return
    await upsert_user(target_id, faction=title)
    user = await get_user(target_id)
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer(f"Фракция установлена: {title}")

# ======= Removal flow (manual items 1 & 3) =======
@dp.callback_query(F.data.startswith("remove:init:"))
async def on_remove_init(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    await ensure_removal_record(target_id)
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:dbdone:"))
async def on_remove_dbdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, db_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET db_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("Отмечено как выполнено (таблица).")

@dp.callback_query(F.data.startswith("remove:tg:"))
async def on_remove_tg(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    try:
        await bot.ban_chat_member(CLAN_CHAT_ID, target_id)
        await bot.unban_chat_member(CLAN_CHAT_ID, target_id)
        ok = True
    except Exception as e:
        logging.warning("Failed to remove from chat: %r", e)
        ok = False
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, tg_done) VALUES(?,?) ON CONFLICT(user_id) DO UPDATE SET tg_done=?", (target_id, 1 if ok else 0, 1 if ok else 0))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("Удалён из клан-чата." if ok else "Не удалось удалить из клан-чата.")

@dp.callback_query(F.data.startswith("remove:discdone:"))
async def on_remove_discdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Недостаточно прав.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, discord_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET discord_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("Отмечено как выполнено (Discord).")

# ======= Approve/Reject (DM) =======
@dp.callback_query(F.data.startswith("approve:"))
async def on_approve(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Только модераторы/администраторы могут одобрять заявки.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("Пользователь не найден", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("Заявка уже одобрена ранее.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("Заявка уже отклонена ранее.", show_alert=True)
        return

    faction = user.get("faction") or "Рекрут"
    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat(), faction=faction)

    link = await create_invite_link()
    if not link:
        await call.answer("Не удалось создать ссылку-приглашение. Проверьте права бота в чате клана.", show_alert=True)
        return

    await bot.send_message(
        target_id,
        f"Ваша заявка одобрена!\nФракция: {faction}\nСсылка для вступления в чат клана: {link.invite_link}",
    )

    try:
        await call.message.edit_text(call.message.text + "\n\n✅ Одобрено")
    except Exception:
        pass
    await call.answer("Одобрено ✅")
    await notify_review_outcome(target_id, "approved")

@dp.callback_query(F.data.startswith("reject:"))
async def on_reject(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Только модераторы/администраторы могут отклонять заявки.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("Пользователь не найден", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("Пользователь уже одобрен/вступил.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("Заявка уже отклонена ранее.", show_alert=True)
        return

    await upsert_user(target_id, status=Status.REJECTED.value)
    await bot.send_message(target_id, "К сожалению, ваша заявка отклонена. Вы можете попробовать позже.")

    try:
        await call.message.edit_text(call.message.text + "\n\n❌ Отклонено")
    except Exception:
        pass
    await call.answer("Отклонено ❌")
    await notify_review_outcome(target_id, "rejected")

# ======= Profile & Join Announce =======
@dp.message(or_f(F.text == "/profile", F.text == "profile"))
async def cmd_profile(message: Message):
    user = await get_user(message.from_user.id)
    if not user:
        await message.answer("Профиль не найден. Нажмите /start")
        return
    lines = ["<b>Ваш профиль</b>"]
    for key in ("clan_id", "user_id", "nickname", "discord", "steamid", "birth_date", "age", "timezone", "tg_link", "faction", "status", "created_at", "applied_at", "approved_at", "joined_at"):
        val = user.get(key)
        if key == "clan_id":
            val = pad_clan_id(val)
        if val:
            lines.append(f"{key}: {val}")
    await message.answer("\n".join(lines))

@dp.message(F.chat.id == CLAN_CHAT_ID, F.new_chat_members)
async def on_user_joined_clan(message: Message):
    for member in message.new_chat_members:
        uid = member.id
        user = await get_user(uid)
        if user and user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
            now_iso = datetime.utcnow().isoformat()
            first_join = not user.get("joined_at")
            if first_join:
                await upsert_user(uid, status=Status.JOINED.value, joined_at=now_iso)
                user = await get_user(uid)
            nickname = user.get("nickname") or member.full_name
            await bot.send_message(CLAN_CHAT_ID, f"<b>{nickname}</b> вступил в наш клан!")
            clanid = pad_clan_id(user.get("clan_id"))
            join_text = (
                f"<b>Участник вступил в клан</b>\n"
                f"ClanID: <code>{clanid}</code>\n"
                f"Telegram ID: <code>{uid}</code>\n"
                f"Ник: {nickname}\n"
                f"Discord: {user.get('discord') or '-'}\n"
                f"SteamID: {user.get('steamid') or '-'}\n"
                f"Дата рождения: {user.get('birth_date') or '-'}\n"
                f"Возраст: {user.get('age') or '-'}\n"
                f"Фракция: {user.get('faction') or '-'}\n"
                f"Часовой пояс: {user.get('timezone') or '-'}\n"
                f"Личный TG: {user.get('tg_link') or '-'}\n"
                f"Дата вступления: {user.get('joined_at') or now_iso}"
            )
            await send_to_moderation(join_text)

@dp.message(F.new_chat_members)
async def on_user_joined_any(message: Message):
    if message.chat.id != CLAN_CHAT_ID:
        return
    await on_user_joined_clan(message)

# ======= Help & Stats =======
@dp.message(or_f(F.text == "/help", F.text == "help"))
async def cmd_help(message: Message):
    await message.answer(
        """Команды:
/start — регистрация
/profile — ваш профиль
/player <user_id | @username | часть ника> — профиль игрока (для модераторов, выбор фракции/удаление из профиля)
/stats — агрегированные отчёты (для модераторов/админов)
"""
    )

async def get_stats(start: Optional[datetime], end: Optional[datetime]) -> str:
    params_created: list = []
    params_applied: list = []
    params_approved: list = []
    params_joined: list = []
    def range_cond(col: str, params_list: list):
        c = []
        if start:
            c.append(f"date({col}) >= date(?)")
            params_list.append(start.isoformat())
        if end:
            c.append(f"date({col}) <= date(?)")
            params_list.append(end.isoformat())
        return (" AND ".join(c)) if c else "1=1"
    cond_created = range_cond("created_at", params_created)
    cond_applied = range_cond("applied_at", params_applied)
    cond_approved = range_cond("approved_at", params_approved)
    cond_joined = range_cond("joined_at", params_joined)
    async with aiosqlite.connect(DB_PATH) as db:
        new_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE {cond_created}", params_created)).fetchone())[0]
        applied_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE applied_at IS NOT NULL AND {cond_applied}", params_applied)).fetchone())[0]
        approved_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE approved_at IS NOT NULL AND {cond_approved}", params_approved)).fetchone())[0]
        joined_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone())[0]
        total = (await (await db.execute("SELECT COUNT(1) FROM users")).fetchone())[0]
        pending = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.PENDING_REVIEW.value,))).fetchone())[0]
        approved_not_joined = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.APPROVED.value,))).fetchone())[0]
        joined_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.JOINED.value,))).fetchone())[0]
        rejected_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.REJECTED.value,))).fetchone())[0]
        avg_age_row = await (await db.execute(f"SELECT AVG(age) FROM users WHERE age IS NOT NULL AND joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone()
        avg_age = round(avg_age_row[0], 1) if avg_age_row and avg_age_row[0] is not None else None
        tz_rows = await (await db.execute(
            f"SELECT timezone, COUNT(1) c FROM users WHERE joined_at IS NOT NULL AND timezone IS NOT NULL AND {cond_joined} GROUP BY timezone ORDER BY c DESC LIMIT 5",
            params_joined,
        )).fetchall()
    lines = ["<b>Агрегированные отчёты</b>"]
    if start or end:
        lines.append(f"Период: {start.date() if start else '—'} — {end.date() if end else '—'}")
    lines += [
        f"Новых стартов /start: <b>{new_cnt}</b>",
        f"Заявок отправлено: <b>{applied_cnt}</b>",
        f"Одобрено: <b>{approved_cnt}</b>",
        f"Вступило: <b>{joined_cnt}</b>",
        "",
        "<b>Воронка (всего):</b>",
        f"Всего пользователей: {total}",
        f"На модерации: {pending}",
        f"Одобрены (не вступили): {approved_not_joined}",
        f"Вступили: {joined_total}",
        f"Отклонены: {rejected_total}",
    ]
    if avg_age is not None:
        lines.append(f"Средний возраст (вступившие в период): {avg_age}")
    if tz_rows:
        lines.append("Топ по часовым поясам (вступившие):")
        for tz, c in tz_rows:
            lines.append(f"• {tz}: {c}")
    return "\n".join(lines)

def period_bounds(key: str):
    now = datetime.utcnow()
    if key == "today":
        start = datetime(now.year, now.month, now.day)
        end = now
    elif key == "7d":
        end = now
        start = now - timedelta(days=7)
    elif key == "30d":
        end = now
        start = now - timedelta(days=30)
    else:
        start = None
        end = None
    return start, end

def stats_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="Сегодня", callback_data="stats:today")
    kb.button(text="7 дней", callback_data="stats:7d")
    kb.button(text="30 дней", callback_data="stats:30d")
    kb.button(text="За всё время", callback_data="stats:all")
    kb.button(text="CSV (вступившие 30д)", callback_data="export:joined:30d")
    kb.button(text="CSV (все за 30д)", callback_data="export:all:30d")
    return kb.as_markup()

@dp.message(F.text == "/stats")
async def cmd_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("Только модераторы/администраторы.")
        return
    await message.answer("Выберите период для отчёта:", reply_markup=stats_kb())

@dp.callback_query(F.data.startswith("stats:"))
async def on_stats(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Только модераторы/администраторы", show_alert=True)
        return
    key = call.data.split(":")[1]
    start, end = period_bounds(key)
    text = await get_stats(start, end)
    await call.message.edit_text(text, reply_markup=stats_kb())

async def export_csv(kind: str, start: Optional[datetime], end: Optional[datetime]) -> str:
    cond_col = {"joined": "joined_at", "all": "created_at"}[kind]
    params = []
    where = []
    if start:
        where.append(f"date({cond_col}) >= date(?)")
        params.append(start.isoformat())
    if end:
        where.append(f"date({cond_col}) <= date(?)")
        params.append(end.isoformat())
    if kind == "joined":
        where.append("joined_at IS NOT NULL")
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT clan_id, user_id, nickname, discord, steamid, age, birth_date, timezone, tg_link, phone, faction, status, created_at, applied_at, approved_at, joined_at FROM users WHERE {where}".format(where=where_sql),
            params,
        )
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
    fname = f"bb_report_{kind}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
    import csv
    with open(fname, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(cols)
        writer.writerows(rows)
    return fname

@dp.callback_query(F.data.startswith("export:"))
async def on_export(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("Только модераторы/администраторы", show_alert=True)
        return
    _, kind, key = call.data.split(":")
    start, end = period_bounds(key)
    path = await export_csv(kind, start, end)
    await bot.send_document(call.from_user.id, FSInputFile(path))
    await call.answer("CSV отправлен в личные сообщения.")

async def main():
    await init_db()
    logging.info("DB initialized at %s", DB_PATH)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")
