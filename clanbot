
# main.py
# aiogram 3.x bot for Blackberry clan onboarding
# Adds: internal ClanID, DM review, factions, DOB. Reports/CSV.
# Removal checklist updated: items 1 (DB) and 3 (Discord) are MANUAL via "–í—ã–ø–æ–ª–Ω–µ–Ω–æ".
# Only item 2 (remove from Telegram clan chat) is automatic.
import asyncio
import logging
from datetime import datetime, timedelta, date
from enum import Enum
from typing import Optional, Tuple, List
import aiosqlite
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart, or_f, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.exceptions import TelegramBadRequest
from aiogram.types import (
    ChatMemberUpdated,
    Message,
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    CallbackQuery,
    ChatInviteLink,
    FSInputFile,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from zoneinfo import ZoneInfo

# ======= CONFIG =======
BOT_TOKEN = "8351592944:AAHXUVRpePbaBLmBkLkdicrQpeX-aulJoYY"                     # ‚Üê token from @BotFather (required)
CHANNEL_USERNAME = "@SquadBlackBerry"
CLAN_CHAT_ID = -1002482539490                   # -100...
MODERATION_CHAT_ID = 0             # optional: join notifications

ADMIN_IDS = {403704696, 1806167653, 95472883, 6931795405}                 # {111, 222}
MODERATOR_IDS = {5065520697, 850675380, 1268697850, 5662345281, 7566533396}              # {333}

DB_PATH = "blackberry_bot.db"

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set in code (fill BOT_TOKEN at the top of main.py)")

# ======= DB LAYER =======
CREATE_USERS_SQL = """
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    clan_id INTEGER,
    phone TEXT,
    nickname TEXT,
    discord TEXT,
    steamid TEXT,
    age INTEGER,
    birth_date TEXT,
    timezone TEXT,
    tg_link TEXT,
    faction TEXT,
    status TEXT,
    created_at TEXT,
    applied_at TEXT,
    approved_at TEXT,
    joined_at TEXT
);
"""
CREATE_USERS_ARCHIVE_SQL = """
CREATE TABLE IF NOT EXISTS users_archive AS
SELECT user_id, clan_id, phone, nickname, discord, steamid, age, birth_date, timezone, tg_link,
       faction, status, created_at, applied_at, approved_at, joined_at,
       '' AS archived_at
FROM users WHERE 0;
"""
CREATE_REMOVE_TABLE_SQL = """
CREATE TABLE IF NOT EXISTS removal_checklist (
    user_id INTEGER PRIMARY KEY,
    db_done INTEGER DEFAULT 0,
    tg_done INTEGER DEFAULT 0,
    discord_done INTEGER DEFAULT 0
);
"""

class Status(str, Enum):
    NEW = "new"
    PENDING_CHANNEL = "pending_channel"
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    JOINED = "joined"
    REMOVED = "removed"


FACTIONS = {
    "hq": "–®—Ç–∞–±",
    "blackhole": "Black Hole",
    "armless": "Armless",
    "brainless": "Brainless",
    "burning": "Burning Assholes",
    "freshmeat": "Fresh Meat",
    "useless": "Useless cans",
    "reserve": "–†–µ–∑–µ—Ä–≤",
}


def faction_tuple_list() -> Tuple[Tuple[str, str], ...]:
    return (
        ("hq", "–®—Ç–∞–±"),
        ("blackhole", "Black Hole"),
        ("armless", "Armless"),
        ("brainless", "Brainless"),
        ("burning", "Burning Assholes"),
        ("freshmeat", "Fresh Meat"),
        ("useless", "Useless cans"),
        ("reserve", "–†–µ–∑–µ—Ä–≤"),
        ("blue", "Blueberry"),
        ("water", "Watermelon"),
        ("recruit", "Fresh Meat"),
        ("reserve", "–†–µ–∑–µ—Ä–≤"),
        ("command", "–®—Ç–∞–±"),
    )

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(CREATE_USERS_SQL)
        await db.execute(CREATE_USERS_ARCHIVE_SQL)
        await db.execute(CREATE_REMOVE_TABLE_SQL)
        # Migrations
        for alter in [
            "ALTER TABLE users ADD COLUMN applied_at TEXT",
            "ALTER TABLE users ADD COLUMN birth_date TEXT",
            "ALTER TABLE users ADD COLUMN faction TEXT",
            "ALTER TABLE users ADD COLUMN clan_id INTEGER",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE users_archive ADD COLUMN archived_at TEXT",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE removal_checklist ADD COLUMN db_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN tg_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN discord_done INTEGER DEFAULT 0",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        await db.commit()
    await ensure_clan_ids()

async def ensure_clan_ids():
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) FROM users")
        (max_clan_id,) = await cur.fetchone()
        cur = await db.execute("SELECT user_id FROM users WHERE clan_id IS NULL ORDER BY rowid")
        rows = await cur.fetchall()
        next_id = max_clan_id + 1
        changed = False
        for (uid,) in rows:
            await db.execute("UPDATE users SET clan_id=? WHERE user_id=?", (next_id, uid))
            next_id += 1
            changed = True
        if changed:
            await db.commit()

async def next_clan_id(db: aiosqlite.Connection) -> int:
    cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) + 1 FROM users")
    (nid,) = await cur.fetchone()
    return int(nid)

async def upsert_user(user_id: int, **fields):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id, clan_id FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if row:
            cols = ", ".join([f"{k}=?" for k in fields.keys()])
            vals = list(fields.values()) + [user_id]
            await db.execute(f"UPDATE users SET {cols} WHERE user_id=?", vals)
        else:
            cid = await next_clan_id(db)
            keys = ["user_id", "clan_id", *fields.keys()]
            placeholders = ",".join(["?"] * len(keys))
            vals = [user_id, cid, *fields.values()]
            await db.execute(
                f"INSERT INTO users ({','.join(keys)}) VALUES ({placeholders})",
                vals,
            )
        await db.commit()

async def get_user(user_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def get_user_by_username(username: str) -> Optional[dict]:
    uname = username.lstrip("@")
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE (tg_link LIKE ?) OR (LOWER(nickname)=LOWER(?)) LIMIT 1",
            (f"%t.me/{uname}%", uname,)
        )
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def search_users_by_nickname(q: str, limit: int = 10) -> List[dict]:
    q = q.strip()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE nickname LIKE ? ORDER BY created_at DESC LIMIT ?",
            (f"%{q}%", limit)
        )
        rows = await cur.fetchall()
        columns = [col[0] for col in cur.description]
        return [dict(zip(columns, r)) for r in rows]

# ======= FSM =======
class RegStates(StatesGroup):
    waiting_phone = State()
    waiting_nickname = State()
    waiting_discord = State()
    waiting_steam = State()
    waiting_birthdate = State()
    waiting_tz = State()
    waiting_tg_link = State()


class AdminEdit(StatesGroup):
    waiting_value = State()

class TrainingReason(StatesGroup):
    waiting_reason = State()


# ======= BOT SETUP =======
logging.basicConfig(level=logging.INFO)
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher()

async def ensure_training_tables():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            """CREATE TABLE IF NOT EXISTS training_attendance(
                date TEXT NOT NULL,
                user_id INTEGER NOT NULL,
                response TEXT NOT NULL,   -- 'yes' | 'no' | 'late'
                reason TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY(date, user_id)
            )"""
        )
        await db.commit()

def phone_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º",
    )

def subscription_check_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üîî –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_sub")
    return kb.adjust(1).as_markup()

def apply_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üì® –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É", callback_data="send_apply")
    return kb.adjust(1).as_markup()

def profile_admin_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üéØ –í—ã–±—Ä–∞—Ç—å —Ñ—Ä–∞–∫—Ü–∏—é", callback_data=f"profile_choosefac:{user_id}")
    kb.button(text="üóë –£–¥–∞–ª–∏—Ç—å –∏–≥—Ä–æ–∫–∞", callback_data=f"remove:init:{user_id}")
    kb.row()
    kb.button(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit:init:{user_id}")
    kb.button(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=f"profile_refresh:{user_id}")
    return kb.adjust(1).as_markup()


def faction_choose_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("hq","–®—Ç–∞–±"),("blackhole","Black Hole")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("armless","Armless"),("brainless","Brainless")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("burning","Burning Assholes"),("freshmeat","Fresh Meat")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("useless","Useless cans"),("reserve","–†–µ–∑–µ—Ä–≤")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()

def approve_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ü—Ä–∏–Ω—è—Ç—å", callback_data=f"approve:{user_id}")
    kb.button(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject:{user_id}")
    return kb.adjust(1).as_markup()

def edit_menu_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–ù–∏–∫", callback_data=f"edit:field:{user_id}:nickname")
    kb.button(text="Discord", callback_data=f"edit:field:{user_id}:discord")
    kb.button(text="SteamID", callback_data=f"edit:field:{user_id}:steamid")
    kb.row()
    kb.button(text="–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è", callback_data=f"edit:field:{user_id}:birth_date")
    kb.button(text="–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å", callback_data=f"edit:field:{user_id}:timezone")
    kb.button(text="–õ–∏—á–Ω—ã–π TG", callback_data=f"edit:field:{user_id}:tg_link")
    kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()
def pad_clan_id(v: Optional[int]) -> str:
    if not v:
        return "‚Äî"
    return f"{int(v):04d}"

def format_profile(user: dict, title: str = "–ü—Ä–æ—Ñ–∏–ª—å –∏–≥—Ä–æ–∫–∞") -> str:
    lines = [f"<b>{title}</b>"]
    fields = [
        ("ClanID", pad_clan_id(user.get("clan_id"))),
        ("Telegram ID", user.get("user_id")),
        ("–ù–∏–∫", user.get("nickname")),
        ("Discord", user.get("discord")),
        ("SteamID", user.get("steamid")),
        ("–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è", user.get("birth_date")),
        ("–í–æ–∑—Ä–∞—Å—Ç", user.get("age")),
        ("–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å", user.get("timezone")),
        ("–õ–∏—á–Ω—ã–π TG", user.get("tg_link")),
        ("–§—Ä–∞–∫—Ü–∏—è", user.get("faction")),
        ("–°—Ç–∞—Ç—É—Å", user.get("status")),
        ("–°–æ–∑–¥–∞–Ω", user.get("created_at")),
        ("–ó–∞—è–≤–∫–∞", user.get("applied_at")),
        ("–û–¥–æ–±—Ä–µ–Ω", user.get("approved_at")),
        ("–í—Å—Ç—É–ø–∏–ª", user.get("joined_at")),
    ]
    for k, v in fields:
        if v not in (None, "", "None"):
            lines.append(f"{k}: {v}")
    return "\n".join(lines)


def display_name(user: dict | None, fallback_fullname: str | None = None) -> str:
    try:
        nick = (user.get("nickname") if user else None) or (fallback_fullname or "")
    except Exception:
        nick = fallback_fullname or ""
    uname = None
    try:
        tl = (user or {}).get("tg_link")
        if tl:
            tl = tl.strip()
            if tl.startswith("https://t.me/") or tl.startswith("http://t.me/") or tl.startswith("t.me/"):
                uname = tl.split("t.me/")[-1].strip("/ ")
            elif tl.startswith("@"):
                uname = tl[1:]
    except Exception:
        uname = None
    return f"{nick} (@{uname})" if uname else nick


# ======= HELPERS =======
async def is_subscribed(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        return member.status in ("member", "administrator", "creator")
    except Exception as e:
        logging.exception("Failed to check subscription: %r", e)
        return False

def reviewer_ids() -> List[int]:
    return sorted(set(ADMIN_IDS) | set(MODERATOR_IDS))

async def send_application_to_all(text: str, user_id: int):
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, text, reply_markup=approve_kb(user_id))
        except Exception as e:
            logging.warning("Cannot DM reviewer %s: %r", rid, e)

async def notify_review_outcome(user_id: int, outcome: str):
    label = "‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ" if outcome == "approved" else "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ"
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, f"{label}: –∑–∞—è–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <code>{user_id}</code> —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.")
        except Exception:
            pass

async def send_to_moderation(text: str, reply_markup: Optional[InlineKeyboardMarkup] = None):
    if MODERATION_CHAT_ID:
        try:
            await bot.send_message(MODERATION_CHAT_ID, text, reply_markup=reply_markup)
        except Exception:
            pass
async def notify_staff(text: str):
    sent = False
    try:
        await send_to_moderation(text)
        sent = True
    except Exception:
        sent = False
    # –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –õ–° –≤—Å–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º
    try:
        for rid in reviewer_ids():
            try:
                await bot.send_message(rid, text)
            except Exception:
                pass
    except Exception:
        pass

async def create_invite_link() -> Optional[ChatInviteLink]:
    try:
        link = await bot.create_chat_invite_link(
            chat_id=CLAN_CHAT_ID,
            name=f"Onboarding {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            creates_join_request=False,
            expire_date=None,
            member_limit=1,
        )
        return link
    except Exception as e:
        logging.exception("Cannot create invite link: %r", e)
        return None

# ======= Removal checklist (manual for items 1 and 3) =======
async def ensure_removal_record(user_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id) VALUES(?) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        await db.commit()

def removal_kb(user_id: int, done_db: bool, done_tg: bool, done_discord: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text=("‚úÖ 1. –ò–∑ —Ç–∞–±–ª–∏—Ü—ã –æ—Ç–º–µ—á–µ–Ω–æ" if done_db else "1. –û—Ç–º–µ—Ç–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã"), callback_data=f"remove:dbdone:{user_id}")
    kb.button(text=("‚úÖ 2. –ò–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞" if done_tg else "2. –£–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞"), callback_data=f"remove:tg:{user_id}")
    kb.row()
    kb.button(text=("‚úÖ 3. –ò–∑ Discord –æ—Ç–º–µ—á–µ–Ω–æ" if done_discord else "3. –û—Ç–º–µ—Ç–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ Discord"), callback_data=f"remove:discdone:{user_id}")
    kb.row()
    if done_db and done_tg and done_discord:
        kb.button(text="üßπ –ó–∞–≤–µ—Ä—à–∏—Ç—å ‚Äî —Å—Ç–µ—Ä–µ—Ç—å –∏–∑ –±–∞–∑—ã", callback_data=f"remove:final:{user_id}")
        kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()

async def removal_state(user_id: int) -> tuple[bool, bool, bool]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT db_done, tg_done, discord_done FROM removal_checklist WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
    if row:
        return bool(row[0]), bool(row[1]), bool(row[2])
    return False, False, False

def removal_text(user: Optional[dict], done_db: bool, done_tg: bool, done_discord: bool) -> str:
    title = "<b>–£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ ‚Äî —á–µ–∫-–ª–∏—Å—Ç</b>"
    if user:
        header = f"ClanID: <code>{pad_clan_id(user.get('clan_id'))}</code> | ID: <code>{user.get('user_id')}</code> | –ù–∏–∫: {user.get('nickname') or '-'}"
    else:
        header = f"ID: <code>{user}</code>"
    def mark(b): return "‚úÖ" if b else "‚òê"
    lines = [
        title,
        header,
        "",
        f"{mark(done_db)} 1) –ü—Ä–æ–≤–µ—Ä–∏—Ç—å: –∏–≥—Ä–æ–∫ —É–¥–∞–ª—ë–Ω –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –ë–î (–æ—Ç–º–µ—á–∞–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é –∫–Ω–æ–ø–∫–æ–π ¬´–í—ã–ø–æ–ª–Ω–µ–Ω–æ (—Ç–∞–±–ª–∏—Ü–∞)¬ª).",
        f"{mark(done_tg)} 2) –£–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞ Telegram (–≤—ã–ø–æ–ª–Ω—è–µ—Ç –±–æ—Ç –ø–æ –∫–Ω–æ–ø–∫–µ).",
        f"{mark(done_discord)} 3) –ü—Ä–æ–≤–µ—Ä–∏—Ç—å: –∏–≥—Ä–æ–∫ —É–¥–∞–ª—ë–Ω –∏–∑ Discord (–æ—Ç–º–µ—á–∞–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é –∫–Ω–æ–ø–∫–æ–π ¬´–í—ã–ø–æ–ª–Ω–µ–Ω–æ (Discord)¬ª).",
    ]
    return "\n".join(lines)


def _not_empty(v):
    return bool(v and str(v).strip())

async def is_profile_complete(user_id: int) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT nickname, discord, steamid, birth_date, timezone, tg_link FROM users WHERE user_id=?",
            (user_id,)
        )
        row = await cur.fetchone()
    if not row:
        return False
    nickname, discord, steamid, birth_date, timezone, tg_link = row
    return all([_not_empty(nickname), _not_empty(discord), _not_empty(steamid),
                _not_empty(birth_date), _not_empty(timezone), _not_empty(tg_link)])

# ======= HANDLERS =======
@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if user and user.get("status") in (Status.APPROVED, Status.JOINED):
        await message.answer("–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /profile, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–∞–Ω–Ω—ã–µ.")
        return

    await upsert_user(
        message.from_user.id,
        status=Status.NEW.value,
        created_at=datetime.utcnow().isoformat(),
    )
    await ensure_clan_ids()
    await ensure_joined_if_member(message.from_user.id)
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –∫–ª–∞–Ω–∞ Blackberry. –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
        reply_markup=phone_kb(),
    )
    await state.set_state(RegStates.waiting_phone)

@dp.message(RegStates.waiting_phone, F.contact)
async def got_phone(message: Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("–û—Ç–ª–∏—á–Ω–æ! –í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫(—Ä–µ–∞–ª—å–Ω–æ–µ –∏–º—è): –ü—Ä–∏–º–µ—Ä: Keech(–ê–ª–µ–∫—Å–∞–Ω–¥—Ä)", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_nickname)

@dp.message(RegStates.waiting_phone)
async def need_phone(message: Message):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞.", reply_markup=phone_kb())

@dp.message(RegStates.waiting_nickname)
async def got_nick(message: Message, state: FSMContext):
    await state.update_data(nickname=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ Discord:")
    await state.set_state(RegStates.waiting_discord)

@dp.message(RegStates.waiting_discord)
async def got_discord(message: Message, state: FSMContext):
    await state.update_data(discord=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ SteamID:")
    await state.set_state(RegStates.waiting_steam)

@dp.message(RegStates.waiting_steam)
async def got_steam(message: Message, state: FSMContext):
    await state.update_data(steamid=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è (–≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì):")
    await state.set_state(RegStates.waiting_birthdate)

@dp.message(RegStates.waiting_birthdate)
async def got_birthdate(message: Message, state: FSMContext):
    text = message.text.strip()
    try:
        birth_date = datetime.strptime(text, "%d.%m.%Y").date()
        if birth_date > date.today():
            raise ValueError("future")
    except Exception:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –∫–∞–∫ –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 15.08.1995).")
        return

    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))

    await state.update_data(birth_date=birth_date.isoformat(), age=age)
    await message.answer(f"‚úÖ –ü—Ä–∏–Ω—è—Ç–æ. –í–∞—à –≤–æ–∑—Ä–∞—Å—Ç: {age}.\n–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å:", reply_markup=tz_choice_kb())
    await state.set_state(RegStates.waiting_tz)

def tz_choice_kb() -> ReplyKeyboardMarkup:
    # –ö–Ω–æ–ø–∫–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ, –æ—Ç MSK-3 –¥–æ MSK+7
    rows = [[KeyboardButton(text=label)] for label in ["MSK-3","MSK-2","MSK-1","MSK","MSK+1","MSK+2","MSK+3","MSK+4","MSK+5","MSK+6","MSK+7"]]
    return ReplyKeyboardMarkup(
        keyboard=rows,
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å"
    )

@dp.message(RegStates.waiting_tz)
async def got_tz(message: Message, state: FSMContext):
    choice = (message.text or "").strip()
    allowed = ["MSK-3","MSK-2","MSK-1","MSK","MSK+1","MSK+2","MSK+3","MSK+4","MSK+5","MSK+6","MSK+7"]
    if choice not in allowed:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ.", reply_markup=tz_choice_kb())
        return
    await state.update_data(timezone=choice)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∞—à –ª–∏—á–Ω—ã–π Telegram (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://t.me/username –∏–ª–∏ @username):", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_tg_link)

@dp.message(RegStates.waiting_tg_link)

@dp.message(RegStates.waiting_tg_link)
async def got_tg_link(message: Message, state: FSMContext):
    data = await state.update_data(tg_link=message.text.strip())
    data = await state.get_data()

    await upsert_user(
        message.from_user.id,
        phone=data.get("phone"),
        nickname=data.get("nickname"),
        discord=data.get("discord"),
        steamid=data.get("steamid"),
        age=data.get("age"),
        birth_date=data.get("birth_date"),
        timezone=data.get("timezone"),
        tg_link=data.get("tg_link"),
        status=Status.PENDING_CHANNEL.value,
    )
    await ensure_clan_ids()

    preview = (
        f"<b>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ</b>\n"
        f"–ù–∏–∫: {data.get('nickname')}\n"
        f"Discord: {data.get('discord')}\n"
        f"SteamID: {data.get('steamid')}\n"
        f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {data.get('birth_date')}\n"
        f"–í–æ–∑—Ä–∞—Å—Ç (–ø–æ –¥–∞—Ç–µ): {data.get('age')}\n"
        f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {data.get('timezone')}\n"
        f"–õ–∏—á–Ω—ã–π TG: {data.get('tg_link')}\n\n"
        f"–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π: {CHANNEL_USERNAME}"
    )

    await message.answer(preview)
    await message.answer(
        "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=subscription_check_kb(),
    )
    await state.clear()

# Subscription
@dp.callback_query(F.data == "check_sub")
async def on_check_sub(call: CallbackQuery):
    uid = call.from_user.id
    if await is_subscribed(uid):
        await upsert_user(uid, status=Status.PENDING_REVIEW.value)
        await call.message.edit_text(
            "–ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ.",
            reply_markup=apply_kb(),
        )
    else:
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @SquadBlackBerry", show_alert=True)

# Send application to ALL reviewers in DMs
@dp.callback_query(F.data == "send_apply")
async def on_send_apply(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not user or user.get("status") != Status.PENDING_REVIEW.value:
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É.", show_alert=True)
        return

    await upsert_user(uid, applied_at=datetime.utcnow().isoformat())
    user = await get_user(uid)
    clan_id = pad_clan_id(user.get("clan_id"))

    text = (
        f"<b>–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –≤ –∫–ª–∞–Ω</b>\n"
        f"ClanID: <code>{clan_id}</code>\n"
        f"Telegram ID: <code>{uid}</code>\n"
        f"–ù–∏–∫: {user.get('nickname')}\n"
        f"Discord: {user.get('discord')}\n"
        f"SteamID: {user.get('steamid')}\n"
        f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {user.get('birth_date') or '-'}\n"
        f"–í–æ–∑—Ä–∞—Å—Ç: {user.get('age') or '-'}\n"
        f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {user.get('timezone')}\n"
        f"–õ–∏—á–Ω—ã–π TG: {user.get('tg_link')}\n"
        f"–§—Ä–∞–∫—Ü–∏—è: {user.get('faction') or '‚Äî (–≤—ã–±–µ—Ä–∏—Ç–µ –≤ –ø—Ä–æ—Ñ–∏–ª–µ –∏–≥—Ä–æ–∫–∞)'}\n"
    )
    await send_application_to_all(text, uid)
    await call.message.edit_text("–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –û–∂–∏–¥–∞–π—Ç–µ —Ä–µ—à–µ–Ω–∏—è.")

# ======= Moderation/Profile flow =======
@dp.message(Command("player"))
async def cmd_player(message: Message, command: Command):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /player <user_id | @username | —á–∞—Å—Ç—å –Ω–∏–∫–∞>")
        return
    query = args[1].strip()

    target_user: Optional[dict] = None
    if query.isdigit():
        target_user = await get_user(int(query))
    if not target_user and query.startswith("@"):
        target_user = await get_user_by_username(query)
    if not target_user:
        matches = await search_users_by_nickname(query, limit=10)
        if len(matches) == 1:
            target_user = matches[0]
        elif len(matches) > 1:
            lines = ["–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:"]
            for u in matches:
                lines.append(f"‚Ä¢ {u.get('nickname') or '-'} ‚Äî ClanID: {pad_clan_id(u.get('clan_id'))} ‚Äî ID: <code>{u['user_id']}</code> ‚Äî —Ñ—Ä–∞–∫—Ü–∏—è: {u.get('faction') or '-'}")
            lines.append("\n–£—Ç–æ—á–Ω–∏—Ç–µ: /player <ID>")
            await message.answer("\n".join(lines))
            return

    if not target_user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    await message.answer(format_profile(target_user), reply_markup=profile_admin_kb(target_user["user_id"]))

@dp.callback_query(F.data.startswith("profile_refresh:"))
async def on_profile_refresh(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer("–ü—Ä–æ—Ñ–∏–ª—å –æ–±–Ω–æ–≤–ª—ë–Ω.")

@dp.callback_query(F.data.startswith("profile_choosefac:"))
async def on_profile_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    text = format_profile(user, title="–í—ã–±–æ—Ä —Ñ—Ä–∞–∫—Ü–∏–∏")
    try:
        await call.message.edit_text(text + "\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ñ—Ä–∞–∫—Ü–∏—é:", reply_markup=faction_choose_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("profile_back:"))
async def on_profile_back(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("facset:"))
async def on_profile_set_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, uid_str, code = call.data.split(":")
        target_id = int(uid_str)
        title = {"hq":"–®—Ç–∞–±","blackhole":"Black Hole","armless":"Armless","brainless":"Brainless","burning":"Burning Assholes","freshmeat":"Fresh Meat","useless":"Useless cans","reserve":"–†–µ–∑–µ—Ä–≤"}.get(code)
        if not title:
            raise ValueError("unknown faction code")
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return
    await upsert_user(target_id, faction=title)
    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –æ —Å–º–µ–Ω–µ —Ñ—Ä–∞–∫—Ü–∏–∏
    await send_faction_notice(target_id, title)

    user = await get_user(target_id)
    try:
        await call.message.edit_text(format_profile(user), reply_markup=profile_admin_kb(target_id))
    except Exception:
        pass
    await call.answer(f"–§—Ä–∞–∫—Ü–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {title}")


@dp.callback_query(F.data.startswith("edit:init:"))
async def on_edit_init(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    text = format_profile(user, title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è")
    try:
        await call.message.edit_text(text + "\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=edit_menu_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("edit:field:"))
async def on_edit_field(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str, field = call.data.split(":")
    target_id = int(uid_str)
    allowed = {"nickname","discord","steamid","birth_date","timezone","tg_link"}
    if field not in allowed:
        await call.answer("–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –ø–æ–ª–µ.", show_alert=True)
        return
    prompts = {
        "nickname": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –Ω–∏–∫ (—Ä–µ–∞–ª—å–Ω–æ–µ –∏–º—è):",
        "discord": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π Discord:",
        "steamid": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π SteamID:",
        "birth_date": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì:",
        "timezone": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä, GMT+3 –∏–ª–∏ Europe/Moscow):",
        "tg_link": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∞—à Telegram (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://t.me/username):",
    }
    await state.update_data(edit_user_id=target_id, edit_field=field, edit_message_id=call.message.message_id, chat_id=call.message.chat.id)
    await call.message.answer(prompts[field])
    await state.set_state(AdminEdit.waiting_value)
    await call.answer()

@dp.message(AdminEdit.waiting_value)
async def on_edit_value(message: Message, state: FSMContext):
    data = await state.get_data()
    target_id = data.get("edit_user_id")
    field = data.get("edit_field")
    if not target_id or not field:
        await message.answer("–°–µ—Å—Å–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å —Å–Ω–æ–≤–∞.")
        await state.clear()
        return
    value = (message.text or "").strip()
    updates = {}
    if field == "birth_date":
        from datetime import datetime, date as _date
        try:
            bdate = datetime.strptime(value, "%d.%m.%Y").date()
            if bdate > _date.today():
                raise ValueError("future")
        except Exception:
            await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∫–∞–∫ –î–î.–ú–ú.–ì–ì–ì–ì.")
            return
        today = _date.today()
        age = today.year - bdate.year - ((today.month, today.day) < (bdate.month, bdate.day))
        updates["birth_date"] = bdate.isoformat()
        updates["age"] = age
    else:
        updates[field] = value

    await upsert_user(target_id, **updates)
    user = await get_user(target_id)
    await message.answer("‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–æ.")
    try:
        await bot.edit_message_text(
            chat_id=data.get("chat_id"),
            message_id=data.get("edit_message_id"),
            text=format_profile(user),
            reply_markup=profile_admin_kb(target_id)
        )
    except Exception:
        await message.answer(format_profile(user), reply_markup=profile_admin_kb(target_id))

    # Log change
    try:
        who = message.from_user.full_name
        field_ru = {
            "nickname": "–ù–∏–∫",
            "discord": "Discord",
            "steamid": "SteamID",
            "birth_date": "–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è",
            "timezone": "–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å",
            "tg_link": "–õ–∏—á–Ω—ã–π TG",
        }.get(field, field)
        log_text = (f"‚úèÔ∏è <b>–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è</b>\n"
                    f"–ö–µ–º: {who} (ID: <code>{message.from_user.id}</code>)\n"
                    f"–ò–≥—Ä–æ–∫ ID: <code>{target_id}</code>\n"
                    f"–ü–æ–ª–µ: {field_ru} ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
        await send_to_moderation(log_text)
    except Exception:
        pass

    await state.clear()

# ======= Removal flow (manual items 1 & 3) =======
@dp.callback_query(F.data.startswith("remove:init:"))
async def on_remove_init(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    await ensure_removal_record(target_id)
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:dbdone:"))
async def on_remove_dbdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, db_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET db_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("–û—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ (—Ç–∞–±–ª–∏—Ü–∞).")

@dp.callback_query(F.data.startswith("remove:tg:"))
async def on_remove_tg(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    try:
        await bot.ban_chat_member(CLAN_CHAT_ID, target_id)
        await bot.unban_chat_member(CLAN_CHAT_ID, target_id)
        ok = True
    except Exception as e:
        logging.warning("Failed to remove from chat: %r", e)
        ok = False
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, tg_done) VALUES(?,?) ON CONFLICT(user_id) DO UPDATE SET tg_done=?", (target_id, 1 if ok else 0, 1 if ok else 0))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("–£–¥–∞–ª—ë–Ω –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞." if ok else "–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞.")

@dp.callback_query(F.data.startswith("remove:discdone:"))
async def on_remove_discdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, discord_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET discord_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("–û—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ (Discord).")

# ======= Approve/Reject (DM) =======
@dp.callback_query(F.data.startswith("approve:"))
async def on_approve(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ–¥–æ–±—Ä—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω–∞ —Ä–∞–Ω–µ–µ.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ —Ä–∞–Ω–µ–µ.", show_alert=True)
        return

    faction = user.get("faction") or "Fresh Meat"
    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat(), faction=faction)
    await ensure_joined_if_member(target_id)

    link = await create_invite_link()
    if not link:
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞ –≤ —á–∞—Ç–µ –∫–ª–∞–Ω–∞.", show_alert=True)
        return

    await bot.send_message(
        target_id,
        f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞!\n–§—Ä–∞–∫—Ü–∏—è: {faction}\n–°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ —á–∞—Ç –∫–ª–∞–Ω–∞: {link.invite_link}",
    )

    try:
        await call.message.edit_text(call.message.text + "\n\n‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ")
    except Exception:
        pass
    await call.answer("–û–¥–æ–±—Ä–µ–Ω–æ ‚úÖ")
    await notify_review_outcome(target_id, "approved")
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ç—ç–≥—É –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º —Å–µ—Ä–≤–µ—Ä–∞–º
    await bot.send_message(
        target_id,
        "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–≥ –≤ –∏–≥—Ä–µ: ‚ùÄ[BBr]\n\n"
        "–ù–∞–∑–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –ø–∞—Ä–æ–ª–∏ –æ—Ç –Ω–∏—Ö\n"
        "Blackberry | Training - Blackberries #1 0106\n"
        "Blackberry | Training- Strawberries #2 7848\n"
        "Blackberry | Training- Blueberries #3 9723\n"
        "Blackberry | Training- Cranberries #4 8831\n\n"
        "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è:\n"
        "–ò–ù–§–û Blackberry: https://t.me/+sL9VacfwkxYyYmUy\n"
        "–î–Ω–µ–≤–Ω–∏–∫ Blackberry: https://t.me/+QZJOj-3aiXowYjEy\n"
    )

@dp.callback_query(F.data.startswith("reject:"))
async def on_reject(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ—Ç–∫–ª–æ–Ω—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω/–≤—Å—Ç—É–ø–∏–ª.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ —Ä–∞–Ω–µ–µ.", show_alert=True)
        return

    await upsert_user(target_id, status=Status.REJECTED.value)
    await bot.send_message(target_id, "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ.")

    try:
        await call.message.edit_text(call.message.text + "\n\n‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ")
    except Exception:
        pass
    await call.answer("–û—Ç–∫–ª–æ–Ω–µ–Ω–æ ‚ùå")
    await notify_review_outcome(target_id, "rejected")

# ======= Profile & Join Announce =======
@dp.message(or_f(F.text == "/profile", F.text == "profile"))
async def cmd_profile(message: Message):
    user = await get_user(message.from_user.id)
    if not user:
        await message.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start")
        return
    lines = ["<b>–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å</b>"]
    for key in ("clan_id", "user_id", "nickname", "discord", "steamid", "birth_date", "age", "timezone", "tg_link", "faction", "status", "created_at", "applied_at", "approved_at", "joined_at"):
        val = user.get(key)
        if key == "clan_id":
            val = pad_clan_id(val)
        if val:
            lines.append(f"{key}: {val}")
    await message.answer("\n".join(lines))

@dp.message(F.chat.id == CLAN_CHAT_ID, F.new_chat_members)
async def on_user_joined_clan(message: Message):
    for member in message.new_chat_members:
        uid = member.id
        user = await get_user(uid)
        if user and user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
            now_iso = datetime.utcnow().isoformat()
            first_join = not user.get("joined_at")
            if first_join:
                await upsert_user(uid, status=Status.JOINED.value, joined_at=now_iso)
                user = await get_user(uid)
            nickname = user.get("nickname") or member.full_name
            tg_username = None
            try:
                if getattr(member, "username", None):
                    tg_username = f"@{member.username}"
            except Exception:
                tg_username = None
            if not tg_username and user:
                link = user.get("tg_link")
                if link:
                    l = link.strip()
                    if l.startswith("https://t.me/") or l.startswith("http://t.me/") or l.startswith("t.me/"):
                        uname = l.split("t.me/")[-1].strip("/ ")
                        if uname:
                            tg_username = f"@{uname}"
                    elif l.startswith("@"):
                        tg_username = l
            announce = (
                f"<b>{nickname}</b> ({tg_username}) –≤—Å—Ç—É–ø–∏–ª –≤ –Ω–∞—à –∫–ª–∞–Ω!" if tg_username
                else f"<b>{nickname}</b> –≤—Å—Ç—É–ø–∏–ª –≤ –Ω–∞—à –∫–ª–∞–Ω!"
            )
            await bot.send_message(CLAN_CHAT_ID, announce)
            clanid = pad_clan_id(user.get("clan_id"))
            join_text = (
                f"<b>–£—á–∞—Å—Ç–Ω–∏–∫ –≤—Å—Ç—É–ø–∏–ª –≤ –∫–ª–∞–Ω</b>\n"
                f"ClanID: <code>{clanid}</code>\n"
                f"Telegram ID: <code>{uid}</code>\n"
                f"–ù–∏–∫: {nickname}\n"
                f"Discord: {user.get('discord') or '-'}\n"
                f"SteamID: {user.get('steamid') or '-'}\n"
                f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {user.get('birth_date') or '-'}\n"
                f"–í–æ–∑—Ä–∞—Å—Ç: {user.get('age') or '-'}\n"
                f"–§—Ä–∞–∫—Ü–∏—è: {user.get('faction') or '-'}\n"
                f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {user.get('timezone') or '-'}\n"
                f"–õ–∏—á–Ω—ã–π TG: {user.get('tg_link') or '-'}\n"
                f"–î–∞—Ç–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {user.get('joined_at') or now_iso}"
            )
            await send_to_moderation(join_text)

@dp.message(F.new_chat_members)
async def on_user_joined_any(message: Message):
    if message.chat.id != CLAN_CHAT_ID:
        return
    await on_user_joined_clan(message)

# ======= Help & Stats =======
@dp.message(or_f(F.text == "/help", F.text == "help"))
async def cmd_help(message: Message):
    await message.answer(
        """–ö–æ–º–∞–Ω–¥—ã:
/start ‚Äî —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
/profile ‚Äî –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å
/player <user_id | @username | —á–∞—Å—Ç—å –Ω–∏–∫–∞> ‚Äî –ø—Ä–æ—Ñ–∏–ª—å –∏–≥—Ä–æ–∫–∞ (–¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤, –≤—ã–±–æ—Ä —Ñ—Ä–∞–∫—Ü–∏–∏/—É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è)
/stats ‚Äî –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã (–¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤/–∞–¥–º–∏–Ω–æ–≤)
"""
    )

async def get_stats(start: Optional[datetime], end: Optional[datetime]) -> str:
    params_created: list = []
    params_applied: list = []
    params_approved: list = []
    params_joined: list = []
    def range_cond(col: str, params_list: list):
        c = []
        if start:
            c.append(f"date({col}) >= date(?)")
            params_list.append(start.isoformat())
        if end:
            c.append(f"date({col}) <= date(?)")
            params_list.append(end.isoformat())
        return (" AND ".join(c)) if c else "1=1"
    cond_created = range_cond("created_at", params_created)
    cond_applied = range_cond("applied_at", params_applied)
    cond_approved = range_cond("approved_at", params_approved)
    cond_joined = range_cond("joined_at", params_joined)
    async with aiosqlite.connect(DB_PATH) as db:
        new_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE {cond_created}", params_created)).fetchone())[0]
        applied_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE applied_at IS NOT NULL AND {cond_applied}", params_applied)).fetchone())[0]
        approved_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE approved_at IS NOT NULL AND {cond_approved}", params_approved)).fetchone())[0]
        joined_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone())[0]
        total = (await (await db.execute("SELECT COUNT(1) FROM users")).fetchone())[0]
        pending = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.PENDING_REVIEW.value,))).fetchone())[0]
        approved_not_joined = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.APPROVED.value,))).fetchone())[0]
        joined_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.JOINED.value,))).fetchone())[0]
        rejected_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.REJECTED.value,))).fetchone())[0]
        avg_age_row = await (await db.execute(f"SELECT AVG(age) FROM users WHERE age IS NOT NULL AND joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone()
        avg_age = round(avg_age_row[0], 1) if avg_age_row and avg_age_row[0] is not None else None
        tz_rows = await (await db.execute(
            f"SELECT timezone, COUNT(1) c FROM users WHERE joined_at IS NOT NULL AND timezone IS NOT NULL AND {cond_joined} GROUP BY timezone ORDER BY c DESC LIMIT 5",
            params_joined,
        )).fetchall()
    lines = ["<b>–ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã</b>"]
    if start or end:
        lines.append(f"–ü–µ—Ä–∏–æ–¥: {start.date() if start else '‚Äî'} ‚Äî {end.date() if end else '‚Äî'}")
    lines += [
        f"–ù–æ–≤—ã—Ö —Å—Ç–∞—Ä—Ç–æ–≤ /start: <b>{new_cnt}</b>",
        f"–ó–∞—è–≤–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: <b>{applied_cnt}</b>",
        f"–û–¥–æ–±—Ä–µ–Ω–æ: <b>{approved_cnt}</b>",
        f"–í—Å—Ç—É–ø–∏–ª–æ: <b>{joined_cnt}</b>",
        "",
        "<b>–í–æ—Ä–æ–Ω–∫–∞ (–≤—Å–µ–≥–æ):</b>",
        f"–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}",
        f"–ù–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏: {pending}",
        f"–û–¥–æ–±—Ä–µ–Ω—ã (–Ω–µ –≤—Å—Ç—É–ø–∏–ª–∏): {approved_not_joined}",
        f"–í—Å—Ç—É–ø–∏–ª–∏: {joined_total}",
        f"–û—Ç–∫–ª–æ–Ω–µ–Ω—ã: {rejected_total}",
    ]
    if avg_age is not None:
        lines.append(f"–°—Ä–µ–¥–Ω–∏–π –≤–æ–∑—Ä–∞—Å—Ç (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ –≤ –ø–µ—Ä–∏–æ–¥): {avg_age}")
    if tz_rows:
        lines.append("–¢–æ–ø –ø–æ —á–∞—Å–æ–≤—ã–º –ø–æ—è—Å–∞–º (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ):")
        for tz, c in tz_rows:
            lines.append(f"‚Ä¢ {tz}: {c}")
    return "\n".join(lines)

def period_bounds(key: str):
    now = datetime.utcnow()
    if key == "today":
        start = datetime(now.year, now.month, now.day)
        end = now
    elif key == "7d":
        end = now
        start = now - timedelta(days=7)
    elif key == "30d":
        end = now
        start = now - timedelta(days=30)
    else:
        start = None
        end = None
    return start, end

def stats_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–°–µ–≥–æ–¥–Ω—è", callback_data="stats:today")
    kb.button(text="7 –¥–Ω–µ–π", callback_data="stats:7d")
    kb.button(text="30 –¥–Ω–µ–π", callback_data="stats:30d")
    kb.button(text="–ó–∞ –≤—Å—ë –≤—Ä–µ–º—è", callback_data="stats:all")
    kb.button(text="CSV (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ 30–¥)", callback_data="export:joined:30d")
    kb.button(text="CSV (–≤—Å–µ –∑–∞ 30–¥)", callback_data="export:all:30d")
    return kb.adjust(1).as_markup()

@dp.message(F.text == "/stats")
async def cmd_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ—Ç—á—ë—Ç–∞:", reply_markup=stats_kb())

@dp.callback_query(F.data.startswith("stats:"))
async def on_stats(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    key = call.data.split(":")[1]
    start, end = period_bounds(key)
    text = await get_stats(start, end)
    await call.message.edit_text(text, reply_markup=stats_kb())

async def export_csv(kind: str, start: Optional[datetime], end: Optional[datetime]) -> str:
    cond_col = {"joined": "joined_at", "all": "created_at"}[kind]
    params = []
    where = []
    if start:
        where.append(f"date({cond_col}) >= date(?)")
        params.append(start.isoformat())
    if end:
        where.append(f"date({cond_col}) <= date(?)")
        params.append(end.isoformat())
    if kind == "joined":
        where.append("joined_at IS NOT NULL")
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT clan_id, user_id, nickname, discord, steamid, age, birth_date, timezone, tg_link, phone, faction, status, created_at, applied_at, approved_at, joined_at FROM users WHERE {where}".format(where=where_sql),
            params,
        )
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
    fname = f"bb_report_{kind}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
    import csv
    with open(fname, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(cols)
        writer.writerows(rows)
    return fname

@dp.callback_query(F.data.startswith("export:"))
async def on_export(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    _, kind, key = call.data.split(":")
    start, end = period_bounds(key)
    path = await export_csv(kind, start, end)
    await bot.send_document(call.from_user.id, FSInputFile(path))
    await call.answer("CSV –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")


def username_from_tglink(link: str | None) -> str:
    if not link:
        return "‚Äî"
    link = link.strip()
    if link.startswith("https://t.me/") or link.startswith("http://t.me/") or link.startswith("t.me/"):
        uname = link.split("t.me/")[-1].strip("/ ")
        if uname:
            return "@" + uname
    if link.startswith("@"):
        return link
    return "‚Äî"
# ======= Players list (admins/mods) =======

async def fetch_joined_players(limit: int = 2000):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT clan_id, nickname, tg_link FROM users WHERE status=? ORDER BY clan_id ASC",
            ("joined",)
        )
        return await cur.fetchall()

def format_players_brief(rows) -> str:
    lines = ["<b>–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ –∫–ª–∞–Ω–∞</b>"]
    if not rows:
        lines.append("‚Äî –ø–æ–∫–∞ –ø—É—Å—Ç–æ ‚Äî")
    else:
        for clan_id, nickname, tg_link in rows:
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            nick = username_from_tglink(tg_link)
            name = nickname or "‚Äî"
            lines.append(f"{cid} ‚Äî –ù–∏–∫: {nick} ‚Äî –ò–º—è: {name}")
    return "\n".join(lines)
PAGE_SIZE = 10


def training_kb(date_str: str) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–î–∞", callback_data=f"train:yes:{date_str}")
    kb.button(text="–ù–µ—Ç", callback_data=f"train:no:{date_str}")
    kb.button(text="–û–ø–æ–∑–¥–∞—é", callback_data=f"train:late:{date_str}")
    return kb.adjust(1).as_markup()

def players_nav_kb(filter_type: str, filter_value: str, page: int, has_prev: bool, has_next: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    if has_prev:
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"players:{filter_type}:{filter_value}:{page-1}")
    if has_next:
        kb.button(text="–î–∞–ª–µ–µ ‚ñ∂Ô∏è", callback_data=f"players:{filter_type}:{filter_value}:{page+1}")
    kb.row()
    kb.button(text=("‚Ä¢ –í—Å–µ" if filter_type=="all" else "–í—Å–µ"), callback_data="players:all::1")
    kb.button(text=("‚Ä¢ –í—Å—Ç—É–ø–∏–ª–∏" if filter_type=="joined" else "–í—Å—Ç—É–ø–∏–ª–∏"), callback_data="players:joined::1")
    kb.button(text=("‚Ä¢ –§—Ä–∞–∫—Ü–∏–∏" if filter_type=="faction" else "–§—Ä–∞–∫—Ü–∏–∏"), callback_data=f"players:choose_faction::{page}")
    return kb.adjust(1).as_markup()


def players_factions_kb(page: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("hq","–®—Ç–∞–±"),("blackhole","Black Hole")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("armless","Armless"),("brainless","Brainless")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("burning","Burning Assholes"),("freshmeat","Fresh Meat")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("useless","Useless cans"),("reserve","–†–µ–∑–µ—Ä–≤")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ (–≤—Å–µ)", callback_data="players:all::1")
    return kb.adjust(1).as_markup()

async def fetch_players(filter_type: str, filter_value: str, page: int):
    offset = (page-1)*PAGE_SIZE
    where = []
    params = []
    where.append("(status IS NULL OR status != ?)")
    params.append("removed")
    if filter_type == "joined":
        where.append("status = ?")
        params.append("joined")
    elif filter_type == "faction" and filter_value:
        where.append("faction = ?")
        params.append(filter_value)
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(f"SELECT COUNT(1) FROM users WHERE {where_sql}", params)
        total = (await cur.fetchone())[0]
        cur = await db.execute(
            f"""SELECT clan_id, user_id, nickname, faction, status
                FROM users
                WHERE {where_sql}
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?""",
            params + [PAGE_SIZE, offset]
        )
        rows = await cur.fetchall()
    has_next = (offset + PAGE_SIZE) < total
    has_prev = page > 1
    return rows, has_prev, has_next, total

def format_players_list(rows, page: int, total: int, filter_type: str, filter_value: str) -> str:
    title_map = {
        "all": "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (–≤—Å–µ, –∫—Ä–æ–º–µ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö)",
        "joined": "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ)",
        "faction": f"–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (—Ñ—Ä–∞–∫—Ü–∏—è: {filter_value})" if filter_value else "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (–ø–æ —Ñ—Ä–∞–∫—Ü–∏–∏)"
    }
    lines = [f"<b>{title_map.get(filter_type, '–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤')}</b>"]
    lines.append(f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page} ‚Ä¢ –≤—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {total}")
    if not rows:
        lines.append("‚Äî –ø—É—Å—Ç–æ ‚Äî")
    else:
        for idx, (clan_id, user_id, nickname, faction, status) in enumerate(rows, 1):
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            nick = nickname or "-"
            fac = faction or "-"
            st = status or "-"
            lines.append(f"{idx:>2}. {cid} ‚Äî {nick} ({fac}) ‚Äî {st} ‚Äî ID: <code>{user_id}</code>")
    lines.append("\n–û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å: /player <ID>")
    return "\n".join(lines)


@dp.message(Command("players"))
async def cmd_players(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    # Sync: approved users already in chat -> mark as JOINED
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cur = await db.execute("SELECT user_id FROM users WHERE status=?", (Status.APPROVED.value,))
            ids = [r[0] for r in await cur.fetchall()]
        for uid in ids[:100]:
            await ensure_joined_if_member(uid)
    except Exception:
        pass
    rows = await fetch_joined_players()
    text = format_players_brief(rows)
    await message.answer(text)

@dp.callback_query(F.data.startswith("players:choose_faction"))
async def on_players_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    await call.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ—Ä–∞–∫—Ü–∏—é:", reply_markup=players_factions_kb(1))
    await call.answer()


    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –æ —Å–º–µ–Ω–µ —Ñ—Ä–∞–∫—Ü–∏–∏

    await send_faction_notice(uid, faction)

@dp.callback_query(F.data.startswith("players:"))
async def on_players_list(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    try:
        _, ftype, fvalue, page_str = call.data.split(":", 3)
        page = int(page_str or "1")
        ftype = ftype or "all"
        fvalue = fvalue or ""
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.", show_alert=True)
        return
    rows, has_prev, has_next, total = await fetch_players(ftype, fvalue, page)
    text = format_players_list(rows, page, total, ftype, fvalue)
    try:
        await call.message.edit_text(text, reply_markup=players_nav_kb(ftype, fvalue, page, has_prev, has_next))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:final:"))
async def on_remove_final(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    # check all steps complete
    done_db, done_tg, done_disc = await removal_state(target_id)
    if not (done_db and done_tg and done_disc):
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —Ç—Ä–∏ —à–∞–≥–∞ —á–µ–∫-–ª–∏—Å—Ç–∞.", show_alert=True)
        return
    # hard delete from users and archive
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM users WHERE user_id=?", (target_id,))
        await db.execute("DELETE FROM users_archive WHERE user_id=?", (target_id,))
        await db.execute("DELETE FROM removal_checklist WHERE user_id=?", (target_id,))
        await db.commit()
    await call.answer("–ò–≥—Ä–æ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—ë–Ω –∏–∑ –±–∞–∑—ã –±–æ—Ç–∞.", show_alert=True)
    try:
        await call.message.edit_text("<b>–£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.</b> –ò–≥—Ä–æ–∫ —Å—Ç–µ—Ä—ë–Ω –∏–∑ –±–∞–∑—ã.")
    except Exception:
        pass


async def ensure_joined_if_member(user_id: int):
    """Promote to JOINED only if user is member of chat AND already APPROVED."""
    try:
        user = await get_user(user_id)
        if not user:
            return
        member = await bot.get_chat_member(CLAN_CHAT_ID, user_id)
        if member.status in ("member", "administrator", "creator") and user.get("status") == Status.APPROVED.value:
            updates = {"status": Status.JOINED.value}
            if not user.get("joined_at"):
                from datetime import datetime
                updates["joined_at"] = datetime.utcnow().isoformat()
            await upsert_user(user_id, **updates)
    except Exception:
        pass


async def send_evening_training_poll():
    # Moscow date for the poll
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    date_str = today.isoformat()
    text = f"–ë—É–¥–µ—à—å —Å–µ–≥–æ–¥–Ω—è –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?\n–î–∞—Ç–∞: <b>{date_str}</b>"
    kb = training_kb(date_str)
    # send only to users without today's response
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT u.user_id FROM users u
            WHERE u.status = ?
              AND NOT EXISTS (
                SELECT 1 FROM training_attendance t
                WHERE t.user_id = u.user_id AND t.date = ?
              )
            """,
            ("joined", date_str)
        )
        ids = [r[0] for r in await cur.fetchall()]
    for uid in ids:
        try:
            await bot.send_message(uid, text, reply_markup=kb)
        except Exception:
            continue

async def check_training_inactive_3days():
    # Find users who have no answers for the last 3 days (MSK)
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    days = [(today - timedelta(days=i)).isoformat() for i in range(0, 3)]
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT u.user_id FROM users u
            WHERE u.status = ?
              AND (u.fraction IS NULL OR u.fraction != '–†–µ–∑–µ—Ä–≤')
              AND u.user_id NOT IN (
                SELECT DISTINCT user_id FROM training_attendance
                WHERE date IN (?,?,?)
              )
            """,
            ("joined", days[0], days[1], days[2])
        )
        ids = [r[0] for r in await cur.fetchall()]
    if not ids:
        return
    for uid in ids:
        try:
            user = await get_user(uid)
        except Exception:
            user = None
        nickname = user.get("nickname") if user else None
        headline = f"–í–Ω–∏–º–∞–Ω–∏–µ! –ò–≥—Ä–æ–∫ {nickname} (ID: {uid}) –Ω–µ –≤—ã—Ö–æ–¥–∏—Ç –Ω–∞ —Å–≤—è–∑—å –≤ —Ç–µ—á–µ–Ω–∏–µ 3 –¥–Ω–µ–π" if nickname else f"–í–Ω–∏–º–∞–Ω–∏–µ! –ò–≥—Ä–æ–∫ ID: {uid} –Ω–µ –≤—ã—Ö–æ–¥–∏—Ç –Ω–∞ —Å–≤—è–∑—å –≤ —Ç–µ—á–µ–Ω–∏–µ 3 –¥–Ω–µ–π"
        await notify_staff(headline)

async def save_training_response(user_id: int, date_str: str, response: str, reason: str | None):
    now_iso = datetime.utcnow().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO training_attendance(date,user_id,response,reason,created_at,updated_at) VALUES(?,?,?,?,?,?) "
            "ON CONFLICT(date,user_id) DO UPDATE SET response=excluded.response, reason=excluded.reason, updated_at=excluded.updated_at",
            (date_str, user_id, response, reason, now_iso, now_iso)
        )
        await db.commit()

async def send_daily_training_poll():
    # Moscow date for the poll
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    date_str = today.isoformat()
    text = f"–ë—É–¥–µ—à—å —Å–µ–≥–æ–¥–Ω—è –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?\n–î–∞—Ç–∞: <b>{date_str}</b>"
    kb = training_kb(date_str)
    # send to all active users (exclude removed)
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id FROM users WHERE status = ?", ("joined",))
        ids = [r[0] for r in await cur.fetchall()]
    for uid in ids:
        try:
            await bot.send_message(uid, text, reply_markup=kb)
        except Exception:
            continue


@dp.callback_query(F.data.startswith("train:"))
async def on_training_answer(call: CallbackQuery, state: FSMContext):
    # –°–†–ê–ó–£ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º callback, —á—Ç–æ–±—ã –Ω–µ —Å–ª–æ–≤–∏—Ç—å timeout
    try:
        await call.answer()
    except TelegramBadRequest:
        pass

    try:
        _, choice, date_str = call.data.split(":")
    except ValueError:
        return

    uid = call.from_user.id

    if choice == "yes":
        await save_training_response(uid, date_str, "yes", None)
        try:
            await call.message.edit_text(f"–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>–î–∞</b> –Ω–∞ {date_str}")
        except TelegramBadRequest:
            try:
                await call.message.answer(f"–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>–î–∞</b> –Ω–∞ {date_str}")
            except Exception:
                pass
        return

    # 'no' –∏ 'late' ‚Äî –ø—Ä–æ—Å–∏–º –ø—Ä–∏—á–∏–Ω—É
    await state.update_data(train_choice=choice, train_date=date_str, train_chat_id=call.message.chat.id, train_msg_id=call.message.message_id)
    try:
        await call.message.answer("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É:")
    except TelegramBadRequest:
        try:
            await bot.send_message(uid, "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É:")
        except Exception:
            pass
    await state.set_state(TrainingReason.waiting_reason)

@dp.message(TrainingReason.waiting_reason)
async def on_training_reason(message: Message, state: FSMContext):
    data = await state.get_data()
    uid = message.from_user.id
    reason = (message.text or "").strip()
    if not reason:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É —Ç–µ–∫—Å—Ç–æ–º.")
        return
    choice = data.get("train_choice")
    date_str = data.get("train_date")
    await save_training_response(uid, date_str, choice, reason)
    label = "–ù–µ—Ç" if choice == "no" else "–û–ø–æ–∑–¥–∞—é"
    await message.answer(f"–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>{label}</b> ({reason}) –Ω–∞ {date_str}")
    # Optionally remove keyboard from original poll to avoid duplicate clicks
    try:
        await bot.edit_message_reply_markup(chat_id=data.get("train_chat_id"), message_id=data.get("train_msg_id"), reply_markup=None)
    except Exception:
        pass
    await state.clear()

async def fetch_training_stats(date_from: str, date_to: str | None = None):
    async with aiosqlite.connect(DB_PATH) as db:
        if not date_to or date_to == date_from:
            cur = await db.execute(
                "SELECT response, COUNT(*) FROM training_attendance WHERE date=? GROUP BY response",
                (date_from,)
            )
            agg = {row[0]: row[1] for row in await cur.fetchall()}
            cur = await db.execute(
                "SELECT user_id, response, reason FROM training_attendance WHERE date=? AND response IN ('no','late')",
                (date_from,)
            )
            details = await cur.fetchall()
            return {"single": True, "date": date_from, "agg": agg, "details": details}
        else:
            cur = await db.execute(
                "SELECT date, response, COUNT(*) FROM training_attendance WHERE date BETWEEN ? AND ? GROUP BY date, response ORDER BY date ASC",
                (date_from, date_to)
            )
            rows = await cur.fetchall()
            return {"single": False, "rows": rows}




@dp.message(Command("train_stats"))  # /train_stats [YYYY-MM-DD] or /train_stats YYYY-MM-DD YYYY-MM-DD
async def cmd_train_stats(message: Message):
    # Access: keep same as before ‚Äî only admins (or add moderators if needed)
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    # Parse arguments
    tail = (message.text or "").split(maxsplit=1)
    dates = []
    if len(tail) > 1:
        dates = [t for t in tail[1].strip().split() if t]

    from zoneinfo import ZoneInfo
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date().isoformat()

    def valid_date(s: str) -> bool:
        try:
            datetime.strptime(s, "%Y-%m-%d")
            return True
        except Exception:
            return False

    # Decide mode
    if len(dates) == 0:
        date_from = today
        date_to = None
    elif len(dates) == 1 and valid_date(dates[0]):
        date_from = dates[0]
        date_to = None
    elif len(dates) >= 2 and valid_date(dates[0]) and valid_date(dates[1]):
        date_from = dates[0]
        date_to = dates[1]
    else:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /train_stats [YYYY-MM-DD] –∏–ª–∏ /train_stats YYYY-MM-DD YYYY-MM-DD")
        return

    # SINGLE-DAY: show detailed stats incl. '–ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏' and CSV
    if not date_to:
        date_str = date_from
        async with aiosqlite.connect(DB_PATH) as db:
            # aggregate yes/no/late
            cur = await db.execute("SELECT response, COUNT(*) FROM training_attendance WHERE date=? GROUP BY response", (date_str,))
            agg = {row[0]: row[1] for row in await cur.fetchall()}
            # details for no/late
            cur = await db.execute("SELECT user_id, response, reason FROM training_attendance WHERE date=? AND response IN ('no','late')", (date_str,))
            details = await cur.fetchall()
            # joined users
            cur = await db.execute("SELECT user_id, nickname, tg_link FROM users WHERE status = ?", ("joined",))
            joined_users = await cur.fetchall()
            all_joined_ids = {u[0] for u in joined_users}
            # answered set
            cur = await db.execute("SELECT DISTINCT user_id FROM training_attendance WHERE date=?", (date_str,))
            answered_ids = {r[0] for r in await cur.fetchall()}

        not_answered = [(uid, nick, link) for uid, nick, link in joined_users if uid not in answered_ids]
        total_joined = len(all_joined_ids)
        not_answered_count = len(not_answered)

        text_lines = [
            f"<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –∑–∞ {date_str}</b>",
            f"‚úÖ –î–∞: {agg.get('yes', 0)}",
            f"‚ùå –ù–µ—Ç: {agg.get('no', 0)}",
            f"‚è∞ –û–ø–æ–∑–¥–∞—é: {agg.get('late', 0)}",
            f"‚ÅâÔ∏è –ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏: {not_answered_count} –∏–∑ {total_joined}",
        ]

        # append reasons list (grouped)
        if details:
            text_lines.append("")
            text_lines.append("<b>–ü—Ä–∏—á–∏–Ω—ã (–ù–µ—Ç/–û–ø–æ–∑–¥–∞—é)</b>")
    async with aiosqlite.connect(DB_PATH) as db:
        for uid, resp, reason in details:
            label = "‚ùå –ù–µ—Ç" if resp == "no" else "‚è∞ –û–ø–æ–∑–¥–∞—é"
            reason = reason or "‚Äî"
            cur = await db.execute("SELECT nickname, tg_link FROM users WHERE user_id=?", (uid,))
            row = await cur.fetchone()
            if row and row[0]:
                disp = row[0]
            else:
                # fallback to @username from tg_link
                uname = username_from_tglink(row[1]) if row else None
                disp = uname if uname and uname != "‚Äî" else str(uid)
            text_lines.append(f"{label}: {disp}: {reason}")


        await message.answer("\n".join(text_lines))

        # Build and send CSV with not answered
        import csv
        csv_name = f"not_answered_{date_str}.csv"
        with open(csv_name, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["Nickname", "Username (tg_link)"])
            for uid, nick, link in not_answered:
                uname = username_from_tglink(link)
                writer.writerow([nick or "-", uname or "-"])
        try:
            await message.answer_document(FSInputFile(csv_name), caption="–ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ (CSV)")
        except Exception:
            try:
                await bot.send_document(message.chat.id, FSInputFile(csv_name))
            except Exception:
                pass
        return

    # RANGE MODE: aggregate by day and print per-day lines (kept old style)
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT date, response, COUNT(*) FROM training_attendance WHERE date BETWEEN ? AND ? GROUP BY date, response ORDER BY date ASC",
            (date_from, date_to)
        )
        rows = await cur.fetchall()

    lines = [f"<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –∑–∞ –ø–µ—Ä–∏–æ–¥ {date_from} ‚Äî {date_to}</b>"]
    cur_d = None
    agg_d = {}
    def push_day(d):
        if not agg_d: return
        lines.append(f"{d}: –î–∞ {agg_d.get('yes',0)} ‚Ä¢ –ù–µ—Ç {agg_d.get('no',0)} ‚Ä¢ –û–ø–æ–∑–¥–∞—é {agg_d.get('late',0)}")

    for d, resp, cnt in rows:
        if d != cur_d:
            if cur_d is not None:
                push_day(cur_d)
            cur_d = d
            agg_d = {}
        agg_d[resp] = cnt
    if cur_d is not None:
        push_day(cur_d)
    await message.answer("\n".join(lines))


@dp.message(Command("new"))
async def cmd_new_users(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    limit = 100
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, clan_id, nickname, created_at FROM users WHERE status = ? ORDER BY created_at DESC LIMIT ?",
            ("new", limit)
        )
        rows = await cur.fetchall()

    # Build text
    lines = ["<b>–ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (status=new)</b>"]
    if not rows:
        lines.append("‚Äî —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî")
    else:
        for uid, clan_id, nickname, created_at in rows:
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            name = nickname or "-"
            lines.append(f"ClanID: {cid} ‚Ä¢ ID: <code>{uid}</code> ‚Ä¢ –ù–∏–∫: {name} ‚Ä¢ –°–æ–∑–¥–∞–Ω: {created_at or '-'}")
        lines.append("\\n–ß—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å: –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É –∫–∞—Ä—Ç–æ—á–∫–∏.")
    text = "\\n".join(lines)

    # Build keyboard
    kb = InlineKeyboardBuilder()
    for uid, clan_id, nickname, created_at in rows:
        kb.button(text=f"üóë –£–¥–∞–ª–∏—Ç—å {nickname or uid}", callback_data=f"newdel:{uid}")
    markup = kb.adjust(1).as_markup()

    try:
        await message.answer(text, reply_markup=markup)
    except Exception:
        await message.answer(text)

@dp.callback_query(F.data.startswith("newdel:"))
async def on_new_user_delete(call: CallbackQuery):
    if call.from_user.id not in ADMIN_IDS:
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, uid_str = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT status FROM users WHERE user_id=?", (target_id,))
        row = await cur.fetchone()
        if not row or row[0] != "new":
            await call.answer("–£–¥–∞–ª—è—Ç—å –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º new.", show_alert=True)
            return
        await db.execute("DELETE FROM users WHERE user_id=?", (target_id,))
        try:
            await db.execute("DELETE FROM users_archive WHERE user_id=?", (target_id,))
        except Exception:
            pass
        try:
            await db.execute("DELETE FROM removal_checklist WHERE user_id=?", (target_id,))
        except Exception:
            pass
        try:
            await db.execute("DELETE FROM training_attendance WHERE user_id=?", (target_id,))
        except Exception:
            pass
        await db.commit()
    try:
        await call.message.edit_text("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω –∏–∑ –±–∞–∑—ã (status=new). –û–±–Ω–æ–≤–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥–æ–π /new.")
    except Exception:
        pass
    await call.answer("–£–¥–∞–ª—ë–Ω.")


async def check_recruit_promotion_candidates():
    from datetime import datetime, timedelta
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    threshold = (today - timedelta(days=14)).isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, nickname, tg_link, joined_at FROM users "
            "WHERE status = ? AND faction = ? AND joined_at IS NOT NULL AND date(joined_at) <= date(?)",
            ("joined", "Fresh Meat", threshold)
        )
        rows = await cur.fetchall()
    for uid, nickname, tg_link, joined_at in rows:
        user = { "user_id": uid, "nickname": nickname, "tg_link": tg_link, "joined_at": joined_at }
        text = f"–ò–≥—Ä–æ–∫ \"{display_name(user)}\" –≤ –∫–ª–∞–Ω–µ 14 –¥–Ω–µ–π –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–æ—Å—Ç–∞–≤."
        try:
            await notify_staff(text)
        except Exception:
            for rid in reviewer_ids():
                try:
                    await bot.send_message(rid, text)
                except Exception:
                    pass

async def check_birthdays_today():
    from datetime import datetime
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    mm = f"{today.month:02d}"; dd = f"{today.day:02d}"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, nickname, tg_link, birth_date FROM users "
            "WHERE status = ? AND birth_date IS NOT NULL",
            ("joined",)
        )
        rows = await cur.fetchall()
    for uid, nickname, tg_link, birth_date in rows:
        try:
            bmm = birth_date[5:7]; bdd = birth_date[8:10]
        except Exception:
            continue
        if bmm == mm and bdd == dd:
            user = { "user_id": uid, "nickname": nickname, "tg_link": tg_link }
            text = f"–ò–≥—Ä–æ–∫ \"{display_name(user)}\" —Å–µ–≥–æ–¥–Ω—è –æ—Ç–º–µ—á–∞–µ—Ç –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è!"
            try:
                await notify_staff(text)
            except Exception:
                for rid in reviewer_ids():
                    try:
                        await bot.send_message(rid, text)
                    except Exception:
                        pass

async def send_faction_notice(user_id: int, faction: str):
    texts = {
        "Cranberry": "–¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Cranberry. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Mukuru. –ò–∑–º–µ–Ω–∏ —Å–≤–æ–π —Ç—ç–≥ –Ω–∞: ‚ùÄ[BBa]",
        "Blueberry": "–¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Blueberry. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Buti. –ò–∑–º–µ–Ω–∏ —Å–≤–æ–π —Ç—ç–≥ –Ω–∞: ‚ùÄ[BBb]",
        "Watermelon": "–¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Watermelon. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Gadler. –ò–∑–º–µ–Ω–∏ —Å–≤–æ–π —Ç—ç–≥ –Ω–∞: ‚ùÄ[BBc]",
        "–†–µ–∑–µ—Ä–≤": "–¢—ã –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –≤ —Ä–µ–∑–µ—Ä–≤ –∫–ª–∞–Ω–∞. –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ! –î–ª—è —ç—Ç–æ–≥–æ —Ç—ã –º–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å –ª—é–±–æ–º—É –∏–∑ HR."
    }
    text = texts.get(faction)
    if not text:
        return
    try:
        await bot.send_message(user_id, text)
    except Exception:
        pass


# ==== Manual moderation commands (/accept, /reject) ====

@dp.message(Command("accept"))
async def cmd_accept(message: Message):
    # Only admins/moderators
    try:
        allowed = set(ADMIN_IDS) | set(MODERATOR_IDS)
    except Exception:
        allowed = set(ADMIN_IDS)
    if message.from_user.id not in allowed:
        await message.answer("‚õî –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.")
        return

    parts = (message.text or "").strip().split()
    if len(parts) < 2 or not parts[1].isdigit():
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /accept <tg_id>")
        return

    target_id = int(parts[1])
    user = await get_user(target_id)
    if not user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –±–æ—Ç–∞.")
        return

    # Already processed states
    st = user.get("status")
    if st == Status.REJECTED.value:
        await message.answer("–ó–∞—è–≤–∫–∞ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ä–∞–Ω–µ–µ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")
        return
    if st in (Status.APPROVED.value, Status.JOINED.value):
        await message.answer("–≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω –∏–ª–∏ –≤—Å—Ç—É–ø–∏–ª.")
        return

    # Optional: check profile completeness if —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞
    try:
        ok = await is_profile_complete(target_id)
    except Exception:
        ok = True
    if not ok:
        await message.answer("–ê–Ω–∫–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∞ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é ‚Äî –æ–¥–æ–±—Ä–µ–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")
        return

    # Set APPROVED and default faction if empty
    faction = user.get("faction") or "Fresh Meat"
    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat(), faction=faction)
    await ensure_joined_if_member(target_id)

    link = await create_invite_link()
    if not link:
        await message.answer("–û–¥–æ–±—Ä–µ–Ω–æ, –Ω–æ —Å—Å—ã–ª–∫—É —Å–æ–∑–¥–∞—Ç—å –Ω–µ —É–¥–∞–ª–æ—Å—å ‚Äî –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞ –≤ –∫–ª–∞–Ω-—á–∞—Ç–µ.")
    else:
        try:
            await bot.send_message(
                target_id,
                f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞!\n–§—Ä–∞–∫—Ü–∏—è: {faction}\n–°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ —á–∞—Ç –∫–ª–∞–Ω–∞: {link.invite_link}"
            )
        except Exception:
            pass

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∫–∞–∫ –ø—Ä–∏ –∫–Ω–æ–ø–∫–µ ¬´–û–¥–æ–±—Ä–∏—Ç—å¬ª
        try:
            await bot.send_message(
                target_id,
                "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–≥ –≤ –∏–≥—Ä–µ: ‚ùÄ[BBr]\n\n"
                "–ù–∞–∑–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –ø–∞—Ä–æ–ª–∏ –æ—Ç –Ω–∏—Ö\n"
                "Blackberry | Training - Blackberries #1 0106\n"
                "Blackberry | Training- Strawberries #2 7848\n"
                "Blackberry | Training- Blueberries #3 9723\n"
                "Blackberry | Training- Cranberries #4 8831\n\n"
                "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è:\n"
                "–ò–ù–§–û Blackberry: https://t.me/+sL9VacfwkxYyYmUy\n"
                "–î–Ω–µ–≤–Ω–∏–∫ Blackberry: https://t.me/+QZJOj-3aiXowYjEy\n"
            )
        except Exception:
            pass

    try:
        await notify_review_outcome(target_id, "approved")
    except Exception:
        pass

    await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_id} –æ–¥–æ–±—Ä–µ–Ω (—Å—Ç–∞—Ç—É—Å APPROVED).")

@dp.message(Command("reject"))
async def cmd_reject(message: Message):
    # Only admins/moderators
    try:
        allowed = set(ADMIN_IDS) | set(MODERATOR_IDS)
    except Exception:
        allowed = set(ADMIN_IDS)
    if message.from_user.id not in allowed:
        await message.answer("‚õî –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.")
        return

    parts = (message.text or "").strip().split()
    if len(parts) < 2 or not parts[1].isdigit():
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /reject <tg_id>")
        return

    target_id = int(parts[1])
    user = await get_user(target_id)
    if not user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –±–æ—Ç–∞.")
        return

    st = user.get("status")
    if st in (Status.APPROVED.value, Status.JOINED.value):
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω/–≤—Å—Ç—É–ø–∏–ª.")
        return
    if st == Status.REJECTED.value:
        await message.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ —Ä–∞–Ω–µ–µ.")
        return

    await upsert_user(target_id, status=Status.REJECTED.value)

    try:
        await bot.send_message(target_id, "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")
    except Exception:
        pass

    try:
        await notify_review_outcome(target_id, "rejected")
    except Exception:
        pass

    await message.answer(f"–ó–∞—è–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")



# === Admin-only broadcast: /seed (excludes faction "–†–µ–∑–µ—Ä–≤") ===
@dp.message(Command("seed"))
async def cmd_seed(message: Message):
    # Only administrators
    try:
        allowed = set(ADMIN_IDS)
    except Exception:
        allowed = set()
    if message.from_user.id not in allowed:
        await message.answer("‚õî –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return

    seed_text = (
        "–ü—Ä–∏–≤–µ—Ç! –£ –Ω–∞—Å –≤—Å–µ –µ—â–µ –Ω–µ –ø–æ–ª–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –∏ –Ω–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ, —á—Ç–æ–±—ã —Ç—ã –∑–∞—à–µ–ª –Ω–∞ –Ω–∞—à —Å–µ—Ä–≤–µ—Ä [RU] –§—Ä—É–∫—Ç–æ–≤—ã–π —Å–∞–¥. "
        "–¢—ã –º–æ–∂–µ—à—å –ø—Ä–æ—Å—Ç–æ –∑–∞–π—Ç–∏, –≤—ã—Å—Ç–∞–≤–∏—Ç—å –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ FPS –∏ –∑–∞–Ω–∏–º–∞—Ç—å—Å—è —Å–≤–æ–∏–º–∏ –¥–µ–ª–∞–º–∏. "
        "–ò–ª–∏ —Ç—ã –º–æ–∂–µ—à—å –∑–∞–π—Ç–∏ –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π —Å–∫–∏–ª–ª. "
        "–í –ª—é–±–æ–º —Å–ª—É—á–∞–µ, —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞—à–µ–º—É –∫–ª–∞–Ω—É –Ω—É–∂–µ–Ω –ø–æ–ª–Ω—ã–π —Å–µ—Ä–≤–µ—Ä, –≥–¥–µ –º—ã –Ω–∞–±–∏—Ä–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ –Ω–∞—à–∏ —Ä—è–¥—ã. "
        "–ë—É–¥—å —Å –∫–ª–∞–Ω–æ–º, –Ω–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–π —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ. –°–ø–∞—Å–∏–±–æ, –¥—Ä—É–≥!"
    )

    await message.answer("–ó–∞–ø—É—Å–∫–∞—é —Ä–∞—Å—Å—ã–ª–∫—É —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º (–∫—Ä–æ–º–µ —Ñ—Ä–∞–∫—Ü–∏–∏ '–†–µ–∑–µ—Ä–≤')...")

    sent = 0
    failed = 0
    ids = []

    # –≤—ã–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫—Ä–æ–º–µ —Ñ—Ä–∞–∫—Ü–∏–∏ "–†–µ–∑–µ—Ä–≤"
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cur = await db.execute(
                "SELECT DISTINCT user_id FROM users WHERE faction IS NULL OR faction != '–†–µ–∑–µ—Ä–≤'"
            )
            rows = await cur.fetchall()
            ids = [int(r[0]) for r in rows if r and r[0]]
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return

    # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º DM
    for uid in ids:
        try:
            await bot.send_message(uid, seed_text)
            sent += 1
            # –ª—ë–≥–∫–∏–π —Ç—Ä–æ—Ç—Ç–ª–∏–Ω–≥
            import asyncio
            await asyncio.sleep(0.05)
        except Exception:
            failed += 1

    await message.answer(f"–ì–æ—Ç–æ–≤–æ. –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent} | –ù–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {failed}.")


async def main():
    await init_db()
    await ensure_training_tables()
    logging.info("DB initialized at %s", DB_PATH)
    # Scheduler for training polls and inactivity checks
    try:
        scheduler = AsyncIOScheduler(timezone=ZoneInfo("Europe/Moscow"))
        scheduler.add_job(send_daily_training_poll, CronTrigger(hour=15, minute=30))
        scheduler.add_job(send_evening_training_poll, CronTrigger(hour=18, minute=0))
        scheduler.add_job(check_training_inactive_3days, CronTrigger(hour=18, minute=5))
        
    # Daily checks: recruits 14d & birthdays (MSK)
# Daily checks: recruits 14d & birthdays (MSK)
        scheduler.add_job(check_recruit_promotion_candidates, CronTrigger(hour=10, minute=0, timezone=ZoneInfo("Europe/Moscow")))
        scheduler.add_job(check_birthdays_today, CronTrigger(hour=9, minute=0, timezone=ZoneInfo("Europe/Moscow")))
        scheduler.start()
    except Exception:
        pass

    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")


async def fetch_new_users(limit: int = 100):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, clan_id, nickname, created_at FROM users WHERE status = ? ORDER BY created_at DESC LIMIT ?",
            ("new", limit)
        )
        return await cur.fetchall()

def format_new_users(rows) -> str:
    lines = ["<b>–ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (status=new)</b>"]
    if not rows:
        lines.append("‚Äî —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî")
    else:
        for uid, clan_id, nickname, created_at in rows:
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            name = nickname or "-"
            lines.append(f"ClanID: {cid} ‚Ä¢ ID: <code>{uid}</code> ‚Ä¢ –ù–∏–∫: {name} ‚Ä¢ –°–æ–∑–¥–∞–Ω: {created_at or '-'}")
        lines.append("\n–ß—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å: –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É –∫–∞—Ä—Ç–æ—á–∫–∏.")
    return "\n".join(lines)

def new_users_kb(rows) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for uid, clan_id, nickname, created_at in rows:
        kb.button(text=f"üóë –£–¥–∞–ª–∏—Ç—å {nickname or uid}", callback_data=f"newdel:{uid}")
    return kb.adjust(1).as_markup()
