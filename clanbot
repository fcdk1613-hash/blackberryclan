
# main.py
# aiogram 3.x bot for Blackberry clan onboarding
# Adds: internal ClanID, DM review, factions, DOB. Reports/CSV.
# Removal checklist updated: items 1 (DB) and 3 (Discord) are MANUAL via "–í—ã–ø–æ–ª–Ω–µ–Ω–æ".
# Only item 2 (remove from Telegram clan chat) is automatic.
import asyncio
import logging
from datetime import datetime, timedelta, date
from enum import Enum
from typing import Optional, Tuple, List
import aiosqlite
import csv
import os
import re
from PIL import Image, ImageDraw, ImageFont
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart, or_f, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.exceptions import TelegramBadRequest
from aiogram.types import (
    BotCommand,
    BotCommandScopeChat,
    ChatMemberUpdated,
    Message,
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    CallbackQuery,
    ChatInviteLink,
    FSInputFile,
)
from aiogram.utils.keyboard import InlineKeyboardBuilder
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from zoneinfo import ZoneInfo

CW_SCHEDULER = None  # AsyncIOScheduler will be set in main()


# ======= CONFIG =======
BOT_TOKEN = "8351592944:AAHXUVRpePbaBLmBkLkdicrQpeX-aulJoYY"                     # ‚Üê token from @BotFather (required)
CHANNEL_USERNAME = "@SquadBlackBerry"
CLAN_CHAT_ID = -1002482539490                   # -100...
MODERATION_CHAT_ID = 0             # optional: join notifications

ADMIN_IDS = {403704696, 1806167653, 95472883, 6931795405}                 # {111, 222}
MODERATOR_IDS = {5065520697, 850675380, 1268697850, 5662345281, 7566533396, 1919395404}              # {333}

DB_PATH = "blackberry_bot.db"

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set in code (fill BOT_TOKEN at the top of main.py)")

# ======= DB LAYER =======

CREATE_TOURNAMENT_HISTORY_SQL = """
CREATE TABLE IF NOT EXISTS tournament_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    author_id INTEGER,
    entry_text TEXT NOT NULL,
    created_at TEXT NOT NULL
);
"""
async def add_tournament_history_entry(user_id: int, author_id: int | None, entry_text: str) -> None:
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO tournament_history(user_id, author_id, entry_text, created_at) VALUES (?,?,?,?)",
            (user_id, author_id, entry_text.strip(), datetime.utcnow().isoformat())
        )
        await db.commit()

async def get_tournament_history(user_id: int) -> list[tuple[str, str]]:
    # returns list of (created_at, entry_text)
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute(
            "SELECT created_at, entry_text FROM tournament_history WHERE user_id = ? ORDER BY id ASC",
            (user_id,)
        ) as cur:
            return await cur.fetchall()

async def clear_tournament_history(user_id: int) -> None:
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM tournament_history WHERE user_id=?", (user_id,))
        await db.commit()
CREATE_USERS_SQL = """
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    clan_id INTEGER,
    phone TEXT,
    nickname TEXT,
    discord TEXT,
    steamid TEXT,
    age INTEGER,
    birth_date TEXT,
    timezone TEXT,
    tg_link TEXT,
    faction TEXT,
    status TEXT,
    created_at TEXT,
    applied_at TEXT,
    approved_at TEXT,
    joined_at TEXT,
    elo_rating INTEGER DEFAULT 1000,
    elo_rank TEXT DEFAULT 'None',
    cw_wins INTEGER DEFAULT 0,
    cw_losses INTEGER DEFAULT 0,
    cw_revives INTEGER DEFAULT 0,
    cw_kills INTEGER DEFAULT 0,
    cw_deaths INTEGER DEFAULT 0,
    cw_capture_points INTEGER DEFAULT 0,
    cw_mvp_count INTEGER DEFAULT 0,
    cw_mvp_list TEXT
);
"""
CREATE_USERS_ARCHIVE_SQL = """
CREATE TABLE IF NOT EXISTS users_archive AS
SELECT user_id, clan_id, phone, nickname, discord, steamid, age, birth_date, timezone, tg_link,
       faction, status, created_at, applied_at, approved_at, joined_at,
       '' AS archived_at
FROM users WHERE 0;
"""
CREATE_REMOVE_TABLE_SQL = """
CREATE TABLE IF NOT EXISTS removal_checklist (
    user_id INTEGER PRIMARY KEY,
    db_done INTEGER DEFAULT 0,
    tg_done INTEGER DEFAULT 0,
    discord_done INTEGER DEFAULT 0
);
"""
CREATE_CW_WARS_SQL = """
CREATE TABLE IF NOT EXISTS cw_wars (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    opponents TEXT NOT NULL,
    starts_at TEXT NOT NULL,
    map TEXT,
    team_size INTEGER NOT NULL,
    rules TEXT,
    server TEXT,
    status TEXT NOT NULL DEFAULT 'scheduled',
    winner TEXT,
    bb_score INTEGER,
    opp_score INTEGER
);
"""
CREATE_CW_REGS_SQL = """
CREATE TABLE IF NOT EXISTS cw_registrations (
    war_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    created_at TEXT NOT NULL,
    PRIMARY KEY (war_id, user_id),
    FOREIGN KEY (war_id) REFERENCES cw_wars(id) ON DELETE CASCADE
);
"""
CREATE_CW_PLAYER_STATS_SQL = """
CREATE TABLE IF NOT EXISTS cw_player_stats (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    war_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    revives INTEGER NOT NULL,
    kills INTEGER NOT NULL,
    deaths INTEGER NOT NULL,
    caps INTEGER NOT NULL,
    elo_delta REAL NOT NULL,
    FOREIGN KEY (war_id) REFERENCES cw_wars(id) ON DELETE CASCADE
);
"""
CREATE_USER_ROLES_SQL = """
CREATE TABLE IF NOT EXISTS user_roles (
    user_id INTEGER NOT NULL,
    role_code TEXT NOT NULL,
    opened_at TEXT NOT NULL,
    PRIMARY KEY (user_id, role_code)
);
"""
CREATE_MOD_ACTIONS_SQL = """
CREATE TABLE IF NOT EXISTS mod_actions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    actor_id INTEGER NOT NULL,
    actor_role TEXT,
    action TEXT NOT NULL,
    target_id INTEGER,
    extra TEXT,
    created_at TEXT NOT NULL
);
"""
CREATE_RATING_CHANGES_SQL = """
CREATE TABLE IF NOT EXISTS rating_changes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    delta INTEGER NOT NULL,
    reason TEXT,
    created_at TEXT NOT NULL
);
"""
# Idempotent per-user CW stats
CW_ALTERS_USERS = [
    "ALTER TABLE users ADD COLUMN cw_wins INTEGER DEFAULT 0",
    "ALTER TABLE users ADD COLUMN cw_losses INTEGER DEFAULT 0",
]


class Status(str, Enum):
    NEW = "new"
    PENDING_CHANNEL = "pending_channel"
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    JOINED = "joined"
    REMOVED = "removed"


FACTIONS = {
    "hq": "–®—Ç–∞–±",
    "blackhole": "Black Hole",
    "armless": "Armless",
    "brainless": "Brainless",
    "burning": "Burning Assholes",
    "freshmeat": "Fresh Meat",
    "useless": "Useless cans",
    "reserve": "–†–µ–∑–µ—Ä–≤",
}

CLAN_TITLES: list[str] = [
    "–†–µ–∫—Ä—É—Ç",
    "–†—è–¥–æ–≤–æ–π",
    "–†—è–¥–æ–≤–æ–π 1–∫–ª.",
    "–ö–∞–ø—Ä–∞–ª",
    "–°–µ—Ä–∂–∞–Ω—Ç",
    "–®—Ç–∞–±-—Å–µ—Ä–∂–∞–Ω—Ç",
    "–°–µ—Ä–∂–∞–Ω—Ç 1–∫–ª.",
    "–ú–∞—Å—Ç–µ—Ä-–°–µ—Ä–∂–∞–Ω—Ç",
    "–ú–ª. –õ–µ–π—Ç–µ–Ω–∞–Ω—Ç",
    "–õ–µ–π—Ç–µ–Ω–∞–Ω—Ç",
    "–ö–∞–ø–∏—Ç–∞–Ω",
    "–ú–∞–π–æ—Ä",
    "–ü–æ–ª–∫–æ–≤–Ω–∏–∫",
    "–ì–µ–Ω–µ—Ä–∞–ª",
]

# ======= CLAN ROLES (BLOCK SCHEME, –¢–ï–ö–£–©–ò–ï –í–ï–¢–ö–ò) =======

# –í–ù–ò–ú–ê–ù–ò–ï:
# - –∫–ª—é—á–∏ (code) ‚Äî –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ ID, –∏–º–∏ –æ–ø–µ—Ä–∏—Ä—É–µ—Ç –±–æ—Ç
# - –∑–Ω–∞—á–µ–Ω–∏—è ‚Äî —Ç–æ, —á—Ç–æ –≤–∏–¥–∏—Ç –∏–≥—Ä–æ–∫
# - –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ø–æ–≤—Ç–æ—Ä—è—é—Ç—Å—è, –Ω–æ k–æ–¥—ã —Ä–∞–∑–Ω—ã–µ (—Ä–∞–∑–Ω—ã–µ –º–µ—Å—Ç–∞ –≤ —Å—Ö–µ–º–µ)

ROLE_TITLES: dict[str, str] = {
    # –û–±—â–∏–π –∫–æ—Ä–µ–Ω—å
    "recruit": "–†–µ–∫—Ä—É—Ç",

    # –í–µ—Ç–∫–∞ –ú–µ—Ö–≤–æ–¥-–Ω–∞–≤–æ–¥—á–∏–∫
    "mech_nav": "–ú–µ—Ö–≤–æ–¥-–Ω–∞–≤–æ–¥—á–∏–∫",
    "mech_nav_school": "–ú–µ—Ö–≤–æ–¥-–Ω–∞–≤–æ–¥—á–∏–∫(—à–∫–æ–ª–∞)",
    "mech_nav_driver_gunner": "–ú–µ—Ö–≤–æ–¥, –Ω–∞–≤–æ–¥—á–∏–∫",
    "mech_nav_squad_leader": "–ú–µ—Ö–≤–æ–¥-–Ω–∞–≤–æ–¥—á–∏–∫ –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞",
    "mech_nav_tactics": "–û–±—É—á–µ–Ω–∏–µ —Ç–∞–∫—Ç–∏–∫–µ —Ç–µ—Ö.",
    "crew_cmd_profile": "–ö–æ–º–∞–Ω–¥–∏—Ä —ç–∫–∏–ø–∞–∂–∞(–ø—Ä–æ—Ñ–∏–ª—å–Ω—ã–π)",
    "crew_cmd_instr": "–ö–æ–º–∞–Ω–¥–∏—Ä —ç–∫–∏–ø–∞–∂–∞(–∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä)",
    "to_infantry": "–ü–µ—Ä–µ–≤–æ–¥ –≤ –ø–µ—Ö–æ—Ç—É",  # –æ–±—â–∏–π —É–∑–µ–ª, –∫ –Ω–µ–º—É —Å—Ö–æ–¥—è—Ç—Å—è –¥–≤–µ –≤–µ—Ç–∫–∏
    "officer_school": "–û—Ñ–∏—Ü–µ—Ä—Å–∫–∞—è —à–∫–æ–ª–∞",
    "leadership": "–†—É–∫–æ–≤–æ–¥—è—â–∏–π —Å–æ—Å—Ç–∞–≤",
    "asst_squad_leader": "–ó–∞–º.–∫–æ–º. –æ—Ç–¥–µ–ª–µ–Ω–∏—è",
    "squad_leader": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç–¥–µ–ª–µ–Ω–∏—è",
    "asst_faction_leader": "–ó–∞–º.–∫–æ–º. —Ñ—Ä–∞–∫—Ü–∏–∏",
    "faction_leader": "–ö–æ–º–∞–Ω–¥–∏—Ä —Ñ—Ä–∞–∫—Ü–∏–∏",

    # –í–µ—Ç–∫–∞ –°—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞ (–ø–æ–¥ —Ä–µ–∫—Ä—É—Ç–æ–º)
    "medic_tube_root": "–°—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞",
    "medic_tube_school": "–°—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞",
    "medic": "–°—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫",
    "tube": "–¢—Ä—É–±–∞",
    "squad_sergeant_cadet": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –°–µ—Ä–∂–∞–Ω—Ç(–ö—É—Ä—Å–∞–Ω—Ç)",
    "squad_instr": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä)",
    "to_tech": "–ü–µ—Ä–µ–≤–æ–¥ –≤ —Ç–µ—Ö",
    "squad_brigadier": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–±—Ä–∏–≥–∞–¥–∏—Ä)",
    "squad_replace_root": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ó–∞–º–µ–Ω–∞)",  # –ø–æ–¥ —Ä–µ–∫—Ä—É—Ç–æ–º
    "cmd_replace": "–¶–ú–î(–ó–∞–º–µ–Ω–∞)",
    "cmd_profile": "–¶–ú–î(–ø—Ä–æ—Ñ–∏–ª—å–Ω—ã–π)",
    "cmd_instr": "–¶–ú–î –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä",

    # –í–µ—Ç–∫–∞ –°–µ—Ä–∂–∞–Ω—Ç—Å–∫–∞—è —à–∫–æ–ª–∞ (–°–õ)
    "sergeant_school_sl": "–°–µ—Ä–∂–∞–Ω—Ç—Å–∫–∞—è —à–∫–æ–ª–∞(–°–õ)",
    "medic_tube_from_sl": "–°—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞ (–≤–∞—Ä–∏–∞–Ω—Ç –°–õ)",             # –æ—Ç–¥–µ–ª—å–Ω—ã–π —É–∑–µ–ª
    "squad_profile_sl": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ø—Ä–æ—Ñ–∏–ª—å–Ω—ã–π) (–≤–∞—Ä–∏–∞–Ω—Ç –°–õ)",       # –æ—Ç–¥–µ–ª—å–Ω—ã–π —É–∑–µ–ª
    "squad_instr_sl": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä (–≤–∞—Ä–∏–∞–Ω—Ç –°–õ)",          # –Ω–æ–≤—ã–π —É–∑–µ–ª
    "squad_profile_sl_2": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π) (–≤–∞—Ä–∏–∞–Ω—Ç –°–õ 2)",   # –Ω–æ–≤—ã–π —É–∑–µ–ª
    "cmd_replace_sl": "–¶–ú–î(–ó–∞–º–µ–Ω–∞)",                                      # –æ—Ç–¥–µ–ª—å–Ω—ã–π —É–∑–µ–ª

    # –í–µ—Ç–∫–∞ –õ—ë–≥–∫–∏—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤
    "light_specs": "–õ–µ–≥–∫–∏–µ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã",
    "light_mg": "–õ—ë–≥–∫–∏–π –ø—É–ª–µ–º–µ—Ç",
    "light_gp": "–ì–ü",
    "light_marksman": "–ú–∞—Ä–∫—Å–º–∞–Ω",
    "light_squad_cadet": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–∫—É—Ä—Å–∞–Ω—Ç)",
    "light_squad_profile": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π)",
    "light_squad_instr": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä",
    "light_multiclass": "–ú—É–ª—å—Ç–∏–∫–ª–∞—Å—Å",
    "light_multiclass_instr": "–ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä",
    "to_heavy_specs": "–ü–µ—Ä–µ–≤–æ–¥ –≤ —Ç—è–∂. —Å–ø–µ—Ü.",
    "to_medics_from_specs": "–ü–µ—Ä–µ–≤–æ–¥ –≤ —Å—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞",

    # –í–µ—Ç–∫–∞ –¢—è–∂—ë–ª—ã—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤
    "heavy_specs": "–¢—è–∂–µ–ª—ã–µ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã",
    "heavy_mg": "–¢—è–∂–µ–ª—ã–π –ø—É–ª–µ–º–µ—Ç",
    "heavy_sapper": "–°–∞–ø–µ—Ä",
    "heavy_tandem": "–¢–∞–Ω–¥–µ–º",
    "heavy_sniper_school": "–®–∫–æ–ª–∞ —Å–Ω–∞–π–ø–µ—Ä–æ–≤",
    "heavy_sniper": "–°–Ω–∞–π–ø–µ—Ä",
    "heavy_squad_replace": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ó–∞–º–µ–Ω–∞) (—Ç—è–∂. —Å–ø–µ—Ü.)",
    "heavy_squad_profile": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π) (—Ç—è–∂. —Å–ø–µ—Ü.)",
    "heavy_squad_instr": "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä (—Ç—è–∂. —Å–ø–µ—Ü.)",
    "heavy_multiclass": "–ú—É–ª—å—Ç–∏–∫–ª–∞—Å—Å —Ç—è–∂—ë–ª—ã—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤",
    "heavy_multiclass_instr": "–ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ç—è–∂—ë–ª—ã—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤",
}

# –ü–æ—Ä—è–¥–æ–∫ –≤—ã–≤–æ–¥–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –≤ –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ, –µ—Å–ª–∏ –Ω–∞–¥–æ)
ROLE_ORDER: list[str] = [
    "recruit",
    "mech_nav",
    "mech_nav_school",
    "mech_nav_driver_gunner",
    "mech_nav_squad_leader",
    "mech_nav_tactics",
    "crew_cmd_profile",
    "crew_cmd_instr",
    "to_infantry",
    "officer_school",
    "leadership",
    "asst_squad_leader",
    "squad_leader",
    "asst_faction_leader",
    "faction_leader",
    "medic_tube_root",
    "medic_tube_school",
    "medic",
    "tube",
    "squad_sergeant_cadet",
    "squad_instr",
    "to_tech",
    "squad_brigadier",
    "squad_replace_root",
    "cmd_replace",
    "cmd_profile",
    "cmd_instr",
    "sergeant_school_sl",
    "medic_tube_from_sl",
    "squad_profile_sl",
    "cmd_replace_sl",
    "light_specs",
    "light_mg",
    "light_gp",
    "light_marksman",
    "light_squad_cadet",
    "light_squad_profile",
    "light_squad_instr",
    "light_multiclass",
    "light_multiclass_instr",
    "to_heavy_specs",
    "to_medics_from_specs",
    "heavy_specs",
    "heavy_mg",
    "heavy_sapper",
    "heavy_tandem",
    "heavy_sniper_school",
    "heavy_sniper",
    "heavy_squad_replace",
    "heavy_squad_profile",
    "heavy_squad_instr",
    "heavy_multiclass",
    "heavy_multiclass_instr",
]

# –ì–†–ê–§ –†–û–õ–ï–ô –ü–û –¢–ï–ö–£–©–ï–ô –ë–õ–û–ö-–°–•–ï–ú–ï (–¢–û–õ–¨–ö–û –¢–û, –ß–¢–û –ú–´ –£–ñ–ï –†–ê–°–ü–ò–°–ê–õ–ò)
# parent -> [children]

ROLE_GRAPH: dict[str, list[str]] = {
    # –ö–æ—Ä–µ–Ω—å
    "recruit": ["mech_nav", "medic_tube_root"],

    # –ú–µ—Ö–≤–æ–¥-–Ω–∞–≤–æ–¥—á–∏–∫
    "mech_nav": ["mech_nav_school", "mech_nav_squad_leader", "mech_nav_tactics"],
    "mech_nav_school": ["mech_nav_driver_gunner"],
    "mech_nav_driver_gunner": [],  # –ø–æ–∫–∞ –∫–æ–Ω–µ—Ü
    "mech_nav_squad_leader": [],   # "–Ω–µ—Ç" –ø–æ —Ç–≤–æ–∏–º —Å–ª–æ–≤–∞–º
    "mech_nav_tactics": ["crew_cmd_profile"],
    "crew_cmd_profile": ["crew_cmd_instr"],
    "crew_cmd_instr": ["to_infantry", "officer_school"],
    "to_infantry": [],  # –æ–±—â–∏–π –∫–æ–Ω–µ—á–Ω—ã–π —É–∑–µ–ª
    "officer_school": ["leadership"],
    "leadership": ["asst_squad_leader"],
    "asst_squad_leader": ["squad_leader"],
    "squad_leader": ["asst_faction_leader", "to_infantry"],
    "asst_faction_leader": ["faction_leader"],
    "faction_leader": [],

    # –°—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞ (–ø–æ–¥ —Ä–µ–∫—Ä—É—Ç–æ–º)
    "medic_tube_root": [
        "medic_tube_school",
        "squad_replace_root",
        "sergeant_school_sl",
        "light_specs",
        "heavy_specs",
    ],
    "medic_tube_school": ["medic", "tube"],
    "medic": ["squad_sergeant_cadet"],
    "tube": ["squad_sergeant_cadet"],
    "squad_sergeant_cadet": ["squad_instr", "cmd_replace"],
    "squad_instr": ["to_tech", "squad_brigadier"],
    "to_tech": [],  # –ü–µ—Ä–µ–≤–æ–¥ –≤ —Ç–µ—Ö ‚Äî –¥–∞–ª—å—à–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ª–æ–≥–∏–∫–æ–π
    "squad_brigadier": [],
    "squad_replace_root": [],  # "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ó–∞–º–µ–Ω–∞)" –ø–æ–¥ —Ä–µ–∫—Ä—É—Ç–æ–º –∫–∞–∫ –∫–æ–Ω–µ—á–Ω—ã–π
    "cmd_replace": ["cmd_profile"],
    "cmd_profile": ["cmd_instr"],
    "cmd_instr": ["leadership"],  # –¶–ú–î –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä -> –†—É–∫–æ–≤–æ–¥—è—â–∏–π —Å–æ—Å—Ç–∞–≤

    # –°–µ—Ä–∂–∞–Ω—Ç—Å–∫–∞—è —à–∫–æ–ª–∞ (–°–õ)
    "sergeant_school_sl": ["medic_tube_from_sl", "squad_profile_sl"],
    "medic_tube_from_sl": ["squad_profile_sl"],
    "squad_profile_sl": ["cmd_replace_sl"],
    "cmd_replace_sl": [],

    # –õ—ë–≥–∫–∏–µ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã
    "light_specs": ["light_mg", "light_gp", "light_marksman", "light_multiclass"],
    "light_mg": ["light_squad_cadet"],
    "light_gp": ["light_squad_cadet"],
    "light_marksman": ["light_squad_cadet"],
    "light_squad_cadet": ["light_squad_profile"],
    "light_squad_profile": ["light_squad_instr"],
    # –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä (–ª—ë–≥–∫–∏–µ) -> –ü–µ—Ä–µ–≤–æ–¥ –≤ —Ç–µ—Ö / –¶–ú–î-–≤–µ—Ç–∫–∞
    "light_squad_instr": ["to_tech", "cmd_replace"],
    "light_multiclass": ["light_multiclass_instr"],
    # –ú—É–ª—å—Ç–∏–∫–ª–∞—Å—Å –ª—ë–≥–∫–∏—Ö: –ø–µ—Ä–µ–≤–æ–¥ –≤ —Ç—è–∂. —Å–ø–µ—Ü. –∏ –≤ —à–∫–æ–ª—É —Å—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞
    "light_multiclass_instr": ["to_heavy_specs", "to_medics_from_specs"],
    "to_heavy_specs": [],          # –¥–∞–ª—å—à–µ –ø—Ä—ã–∂–æ–∫ –ª–æ–≥–∏–∫–æ–π
    "to_medics_from_specs": [],    # –¥–∞–ª—å—à–µ –ø—Ä—ã–∂–æ–∫ –ª–æ–≥–∏–∫–æ–π

    # –¢—è–∂—ë–ª—ã–µ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç—ã
    "heavy_specs": [
        "heavy_mg",
        "heavy_sapper",
        "heavy_tandem",
        "heavy_sniper_school",
        "heavy_multiclass",
    ],
    # –¢—è–∂—ë–ª—ã–π –ø—É–ª–µ–º–µ—Ç, –°–∞–ø—ë—Ä, –¢–∞–Ω–¥–µ–º -> –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ó–∞–º–µ–Ω–∞)
    "heavy_mg": ["heavy_squad_replace"],
    "heavy_sapper": ["heavy_squad_replace"],
    "heavy_tandem": ["heavy_squad_replace"],
    # –®–∫–æ–ª–∞ —Å–Ω–∞–π–ø–µ—Ä–æ–≤ -> –°–Ω–∞–π–ø–µ—Ä
    "heavy_sniper_school": ["heavy_sniper"],
    "heavy_sniper": [],  # —Å–∞–º –∫–ª–∞—Å—Å; —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ —É—Å–ª–æ–≤–∏–∏ –º—É–ª—å—Ç–∏–∫–ª–∞—Å—Å–∞
    # –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ó–∞–º–µ–Ω–∞) -> –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π)
    "heavy_squad_replace": ["heavy_squad_profile"],
    # –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π) ->
    #   –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
    #   –ü–µ—Ä–µ–≤–æ–¥ –≤ —Ç–µ—Ö
    #   –ü–µ—Ä–µ–≤–æ–¥ –≤ —Å—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞
    "heavy_squad_profile": ["heavy_squad_instr", "to_tech", "to_medics_from_specs"],
    # –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä ->
    #   –ü–µ—Ä–µ–≤–æ–¥ –≤ —Ç–µ—Ö
    #   –¶–ú–î(–ó–∞–º–µ–Ω–∞) -> –¶–ú–î(–ü—Ä–æ—Ñ–∏–ª—å–Ω—ã–π) -> –¶–ú–î –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä -> –†—É–∫–æ–≤–æ–¥—è—â–∏–π —Å–æ—Å—Ç–∞–≤
    "heavy_squad_instr": ["to_tech", "cmd_replace"],
    # –ú—É–ª—å—Ç–∏–∫–ª–∞—Å—Å -> –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä -> –ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞(–ó–∞–º–µ–Ω–∞)
    "heavy_multiclass": ["heavy_multiclass_instr"],
    "heavy_multiclass_instr": ["heavy_squad_replace"],
}

# –†–æ–¥–∏—Ç–µ–ª–∏ —Å—á–∏—Ç–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (–Ω–∞ –æ—Å–Ω–æ–≤–µ ROLE_GRAPH)
ROLE_PARENTS: dict[str, list[str]] = {}
for parent, children in ROLE_GRAPH.items():
    for child in children:
        ROLE_PARENTS.setdefault(child, []).append(parent)

def get_role_title(code: str | None) -> str:
    if not code:
        return "‚Äî"
    return ROLE_TITLES.get(code, code)

# ===== –õ–æ–≥–∏–∫–∞ –≤–µ—Ç–æ–∫ –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –ø–æ —Ä–æ–ª—è–º =====

# –í–µ—Ç–∫–∞ –ú–µ—Ö–≤–æ–¥-–Ω–∞–≤–æ–¥—á–∏–∫
MECH_BRANCH: set[str] = {
    "mech_nav",
    "mech_nav_school",
    "mech_nav_driver_gunner",
    "mech_nav_squad_leader",
    "mech_nav_tactics",
    "crew_cmd_profile",
    "crew_cmd_instr",
    "to_infantry",
    "officer_school",
    "leadership",
    "asst_squad_leader",
    "squad_leader",
    "asst_faction_leader",
    "faction_leader",
}

# –í–µ—Ç–∫–∞ "—Å—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞" —Ü–µ–ª–∏–∫–æ–º (–¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –∏–∑ –º–µ—Ö–æ–≤)
MEDIC_BRANCH: set[str] = {
    "medic_tube_root",
    "medic_tube_school",
    "medic",
    "tube",
    "squad_sergeant_cadet",
    "squad_instr",
    "to_tech",
    "squad_brigadier",
    "squad_replace_root",
    "cmd_replace",
    "cmd_profile",
    "cmd_instr",
    "sergeant_school_sl",
    "medic_tube_from_sl",
    "squad_profile_sl",
    "cmd_replace_sl",
}

# –¢–æ–ª—å–∫–æ –ø–æ–¥–≤–µ—Ç–∫–∞ "—Å—Ç—Ä–µ–ª–æ–∫-–º–µ–¥–∏–∫-—Ç—Ä—É–±–∞(—à–∫–æ–ª–∞)"
MEDIC_SCHOOL_BRANCH: set[str] = {
    "medic_tube_school",
    "medic",
    "tube",
    "squad_sergeant_cadet",
    "squad_instr",
    "to_tech",
    "squad_brigadier",
    "cmd_replace",
    "cmd_profile",
    "cmd_instr",
}

# –í–µ—Ç–∫–∞ –ª—ë–≥–∫–∏—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤
LIGHT_BRANCH: set[str] = {
    "light_specs",
    "light_mg",
    "light_gp",
    "light_marksman",
    "light_squad_cadet",
    "light_squad_profile",
    "light_squad_instr",
    "light_multiclass",
    "light_multiclass_instr",
}

# –í–µ—Ç–∫–∞ —Ç—è–∂—ë–ª—ã—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤
HEAVY_BRANCH: set[str] = {
    "heavy_specs",
    "heavy_mg",
    "heavy_sapper",
    "heavy_tandem",
    "heavy_sniper_school",
    "heavy_sniper",
    "heavy_squad_replace",
    "heavy_squad_profile",
    "heavy_squad_instr",
    "heavy_multiclass",
    "heavy_multiclass_instr",
}

# –ò–Ω–¥–µ–∫—Å —Ä–æ–ª–∏ –≤ –æ–±—â–µ–º –ø–æ—Ä—è–¥–∫–µ ‚Äî –¥–ª—è –≤—ã–±–æ—Ä–∞ "—Å–∞–º–æ–π –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π" –æ—Ç–∫—Ä—ã—Ç–æ–π —Ä–æ–ª–∏
ROLE_INDEX: dict[str, int] = {code: i for i, code in enumerate(ROLE_ORDER)}

def get_best_open_role_in_branch(opened: list[str] | set[str], branch: set[str]) -> Optional[str]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–∞–º—É—é "–¥–∞–ª—å–Ω—é—é" (–ø–æ ROLE_ORDER) –æ—Ç–∫—Ä—ã—Ç—É—é —Ä–æ–ª—å –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–π –≤–µ—Ç–∫–µ
    –∏–ª–∏ None, –µ—Å–ª–∏ –≤ –≤–µ—Ç–∫–µ –µ—â—ë –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ.
    """
    opened_set = set(opened)
    candidates = [code for code in opened_set if code in branch]
    if not candidates:
        return None
    return max(candidates, key=lambda code: ROLE_INDEX.get(code, -1))

async def get_transfer_target(user_id: int, trigger_code: str) -> Optional[str]:
    """
    –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏-–ø–µ—Ä–µ–≤–æ–¥—ã:

    - 'to_infantry'            -> –±–ª–∏–∂–∞–π—à–∞—è –æ—Ç–∫—Ä—ã—Ç–∞—è —Ä–æ–ª—å –≤ MEDIC_BRANCH
    - 'to_tech'                -> –±–ª–∏–∂–∞–π—à–∞—è –æ—Ç–∫—Ä—ã—Ç–∞—è —Ä–æ–ª—å –≤ MECH_BRANCH
    - 'to_heavy_specs'         -> –±–ª–∏–∂–∞–π—à–∞—è –æ—Ç–∫—Ä—ã—Ç–∞—è —Ä–æ–ª—å –≤ HEAVY_BRANCH
    - 'to_medics_from_specs'   -> –±–ª–∏–∂–∞–π—à–∞—è –æ—Ç–∫—Ä—ã—Ç–∞—è —Ä–æ–ª—å –≤ MEDIC_SCHOOL_BRANCH
    """
    if trigger_code not in {"to_infantry", "to_tech", "to_heavy_specs", "to_medics_from_specs"}:
        return None

    opened = await get_user_roles(user_id)

    if trigger_code == "to_infantry":
        target = get_best_open_role_in_branch(opened, MEDIC_BRANCH)
        return target or "medic_tube_root"

    if trigger_code == "to_tech":
        target = get_best_open_role_in_branch(opened, MECH_BRANCH)
        return target or "mech_nav"

    if trigger_code == "to_heavy_specs":
        target = get_best_open_role_in_branch(opened, HEAVY_BRANCH)
        return target or "heavy_specs"

    if trigger_code == "to_medics_from_specs":
        target = get_best_open_role_in_branch(opened, MEDIC_SCHOOL_BRANCH)
        return target or "medic_tube_school"

    return None

def generate_role_tree_image(
    user_id: int,
    opened_roles: set[str] | list[str] | None,
    current_role: str | None = None,
) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –±–æ–ª—å—à—É—é PNG-–∫–∞—Ä—Ç–∏–Ω–∫—É –¥–µ—Ä–µ–≤–∞ —Ä–æ–ª–µ–π.
    –ó–µ–ª—ë–Ω—ã–º –ø–æ–¥—Å–≤–µ—á–∏–≤–∞—é—Ç—Å—è —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –±–ª–æ–∫–∏ –∏–∑ opened_roles.
    """
    from collections import deque
    import os
    import time
    from PIL import Image, ImageDraw, ImageFont

    # –†–æ–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ –ù–ï –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ –∫–∞—Ä—Ç–∏–Ω–∫–µ
    HIDDEN_TREE_ROLES = {"squad_instr_sl", "squad_profile_sl_2"}

    opened_set: set[str] = set(opened_roles or [])

    # --- —Å—Ç—Ä–æ–∏–º —É—Ä–æ–≤–Ω–∏ –¥–µ—Ä–µ–≤–∞ –ø–æ ROLE_GRAPH ---
    depths: dict[str, int] = {}
    root = "recruit"
    if root in ROLE_GRAPH:
        q = deque([root])
        depths[root] = 0
        while q:
            v = q.popleft()
            d = depths[v]
            for child in ROLE_GRAPH.get(v, []):
                if child not in depths:
                    depths[child] = d + 1
                    q.append(child)

    # –ü–æ–¥—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Ä–æ–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ ROLE_TITLES, –Ω–æ –Ω–µ –ø–æ–ø–∞–ª–∏ –≤ BFS
    # (–∫—Ä–æ–º–µ —Ç–µ—Ö, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤–æ–æ–±—â–µ)
    max_depth = max(depths.values()) if depths else 0
    for code in ROLE_TITLES.keys():
        if code in HIDDEN_TREE_ROLES:
            continue
        if code not in depths:
            max_depth += 1
            depths[code] = max_depth

    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —É—Ä–æ–≤–Ω—è–º
    levels: dict[int, list[str]] = {}
    for code, d in depths.items():
        levels.setdefault(d, []).append(code)

    def role_sort_key(code: str) -> int:
        return ROLE_INDEX.get(code, 9999)

    for d in levels:
        levels[d].sort(key=role_sort_key)

    ordered_depths = sorted(levels.keys())
    if not ordered_depths:
        # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π, —á—Ç–æ–±—ã –Ω–µ —É–ø–∞—Å—Ç—å
        ordered_depths = [0]
        levels[0] = ["recruit"]

    # --- –≥–µ–æ–º–µ—Ç—Ä–∏—è –∫–∞—Ä—Ç–∏–Ω–∫–∏ ---
    block_w, block_h = 260, 110  # –±–ª–æ–∫ —Å—Ç–∞–ª –≤—ã—à–µ
    h_spacing = 40
    v_spacing = 120
    margin_x, margin_top, margin_bottom = 60, 120, 80

    max_per_level = max(len(levels[d]) for d in ordered_depths)
    img_w = margin_x * 2 + max_per_level * block_w + (max_per_level - 1) * h_spacing
    levels_count = len(ordered_depths)
    img_h = margin_top + margin_bottom + levels_count * block_h + (levels_count - 1) * v_spacing

    img = Image.new("RGBA", (img_w, img_h), (10, 10, 20, 255))
    draw = ImageDraw.Draw(img)

    # --- —à—Ä–∏—Ñ—Ç—ã ---
    try:
        title_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 34)
        node_font = ImageFont.truetype("DejaVuSans.ttf", 20)
    except Exception:
        title_font = node_font = ImageFont.load_default()

    def wrap_text(text: str, font: ImageFont.FreeTypeFont, max_width: int) -> list[str]:
        """
        –†–∞–∑–±–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫ —Ç–∞–∫, —á—Ç–æ–±—ã –∫–∞–∂–¥–∞—è –ø–æ–º–µ—â–∞–ª–∞—Å—å –≤ max_width.
        """
        words = text.split()
        if not words:
            return [""]

        lines: list[str] = []
        current = ""

        for w in words:
            test = (current + " " + w).strip()
            bbox = draw.textbbox((0, 0), test, font=font)
            width = bbox[2] - bbox[0]
            if width <= max_width or not current:
                current = test
            else:
                lines.append(current)
                current = w

        if current:
            lines.append(current)

        return lines

    # --- –∑–∞–≥–æ–ª–æ–≤–æ–∫ ---
    header = "–î–µ—Ä–µ–≤–æ —Ä–æ–ª–µ–π"
    if current_role:
        header += f" (—Ç–µ–∫—É—â–∞—è: {get_role_title(current_role)})"
    hb = draw.textbbox((0, 0), header, font=title_font)
    hw = hb[2] - hb[0]
    draw.text(((img_w - hw) // 2, 30), header, font=title_font, fill=(240, 240, 240))

    # --- –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –±–ª–æ–∫–æ–≤ ---
    positions: dict[str, tuple[int, int, int, int]] = {}
    for level_index, depth in enumerate(ordered_depths):
        roles_at_level = levels[depth]
        count = len(roles_at_level)
        total_width = count * block_w + (count - 1) * h_spacing
        start_x = (img_w - total_width) // 2
        y1 = margin_top + level_index * (block_h + v_spacing)

        for i, code in enumerate(roles_at_level):
            x1 = start_x + i * (block_w + h_spacing)
            x2 = x1 + block_w
            y2 = y1 + block_h
            positions[code] = (x1, y1, x2, y2)

    # --- —Å–≤—è–∑–∏ –º–µ–∂–¥—É –±–ª–æ–∫–∞–º–∏ ---
    line_color = (90, 90, 140, 255)
    for parent, children in ROLE_GRAPH.items():
        if parent not in positions:
            continue
        px1, py1, px2, py2 = positions[parent]
        pcx = (px1 + px2) // 2
        pcy = py2
        for child in children:
            if child not in positions:
                continue
            cx1, cy1, cx2, cy2 = positions[child]
            ccx = (cx1 + cx2) // 2
            ccy = cy1
            draw.line((pcx, pcy, ccx, ccy), fill=line_color, width=3)

    # --- —Å–∞–º–∏ –±–ª–æ–∫–∏ ---
    for code, (x1, y1, x2, y2) in positions.items():
        is_open = code in opened_set
        is_current = current_role == code

        fill = (30, 130, 70, 255) if is_open else (35, 35, 70, 255)
        outline = (240, 240, 240, 255) if is_current else (130, 130, 170, 255)

        try:
            draw.rounded_rectangle(
                (x1, y1, x2, y2),
                radius=18,
                fill=fill,
                outline=outline,
                width=3,
            )
        except Exception:
            draw.rectangle((x1, y1, x2, y2), fill=fill, outline=outline, width=3)

        title = get_role_title(code)

        # –ø–µ—Ä–µ–Ω–æ—Å–∏–º —Ç–µ–∫—Å—Ç –ø–æ —Å—Ç—Ä–æ–∫–∞–º, –µ—Å–ª–∏ –æ–Ω –Ω–µ –≤–ª–µ–∑–∞–µ—Ç –ø–æ —à–∏—Ä–∏–Ω–µ
        lines = wrap_text(title, node_font, block_w - 20)

        # –≤—ã—Å–æ—Ç–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        if lines:
            lb = draw.textbbox((0, 0), lines[0], font=node_font)
            line_h = lb[3] - lb[1]
        else:
            line_h = 0

        line_spacing = 4
        total_h = len(lines) * line_h + max(0, (len(lines) - 1) * line_spacing)
        start_y = y1 + (block_h - total_h) // 2

        for i, line in enumerate(lines):
            lb = draw.textbbox((0, 0), line, font=node_font)
            lw = lb[2] - lb[0]
            tx = x1 + (block_w - lw) // 2
            ty = start_y + i * (line_h + line_spacing)
            draw.text((tx, ty), line, font=node_font, fill=(250, 250, 250, 255))

    # –õ–µ–≥–µ–Ω–¥–∞ –≤–Ω–∏–∑—É
    legend_y = img_h - margin_bottom + 10
    legend_x = margin_x

    box_w, box_h = 36, 20

    # –æ—Ç–∫—Ä—ã—Ç—ã–µ
    draw.rectangle(
        (legend_x, legend_y, legend_x + box_w, legend_y + box_h),
        fill=(30, 130, 70, 255),
    )
    txt = "‚Äî –æ—Ç–∫—Ä—ã—Ç—ã–µ –±–ª–æ–∫–∏"
    tb = draw.textbbox((0, 0), txt, font=node_font)
    draw.text(
        (legend_x + box_w + 10, legend_y - 2),
        txt,
        font=node_font,
        fill=(230, 230, 230, 255),
    )

    # –∑–∞–∫—Ä—ã—Ç—ã–µ
    legend_x2 = legend_x + 280
    draw.rectangle(
        (legend_x2, legend_y, legend_x2 + box_w, legend_y + box_h),
        fill=(35, 35, 70, 255),
    )
    txt2 = "‚Äî –µ—â—ë –Ω–µ –æ—Ç–∫—Ä—ã—Ç—ã"
    draw.text(
        (legend_x2 + box_w + 10, legend_y - 2),
        txt2,
        font=node_font,
        fill=(230, 230, 230, 255),
    )

    # --- —Å–æ—Ö—Ä–∞–Ω—è–µ–º ---
    base_dir = os.path.dirname(os.path.abspath(__file__))
    out_dir = os.path.join(base_dir, "role_trees")
    os.makedirs(out_dir, exist_ok=True)

    filename = f"career_{user_id}_{int(time.time())}.png"
    full_path = os.path.join(out_dir, filename)
    img.save(full_path, "PNG")

    return full_path
# ======= ELO / RANKS =======

RANKS = [
    (0, 250, "‚ö™ None", "#a8a8a8"),
    (251, 500, "ü•â Bronze I", "#cd7f32"),
    (501, 750, "ü•â Bronze II", "#cd7f32"),
    (751, 1000, "ü•â Bronze III", "#cd7f32"),
    (1001, 1250, "ü•à Silver I", "#c0c0c0"),
    (1251, 1500, "ü•à Silver II", "#c0c0c0"),
    (1501, 1750, "ü•à Silver III", "#c0c0c0"),
    (1751, 2000, "ü•à Silver IV", "#c0c0c0"),
    (2001, 2250, "ü•á Gold I", "#ffd700"),
    (2251, 2500, "ü•á Gold II", "#ffd700"),
    (2501, 2750, "ü•á Gold III", "#ffd700"),
    (2751, 3000, "ü•á Gold IV", "#ffd700"),
    (3001, 99999, "üíé Platinum", "#00eaff"),
]

async def get_player_position(user_id: int) -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id FROM users WHERE elo_rating IS NOT NULL ORDER BY elo_rating DESC"
        )
        rows = await cur.fetchall()
        ids = [r[0] for r in rows]
        return ids.index(user_id) + 1 if user_id in ids else None

def get_rank(elo: int) -> tuple[str, str]:
    for low, high, name, color in RANKS:
        if low <= elo <= high:
            return name, color
    return "‚ö™ None", "#a8a8a8"

async def notify_rank_if_changed(user_id: int, old_elo: int, new_elo: int) -> None:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–≥—Ä–æ–∫—É –õ–°, –µ—Å–ª–∏ –µ–≥–æ —Ä–∞–Ω–≥ –∏–∑–º–µ–Ω–∏–ª—Å—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ ELO.
    """
    try:
        old_rank, _ = get_rank(old_elo)
        new_rank, _ = get_rank(new_elo)
    except Exception:
        return

    if old_rank == new_rank:
        return

    text = (
        "üéñ <b>–¢–≤–æ–π —Ä–∞–Ω–≥ –∏–∑–º–µ–Ω–∏–ª—Å—è!</b>\n\n"
        f"–ë—ã–ª–æ: <b>{old_rank}</b>\n"
        f"–°—Ç–∞–ª–æ: <b>{new_rank}</b>\n"
        f"–¢–µ–∫—É—â–∏–π Elo: <code>{new_elo} BBP</code>"
    )
    try:
        await bot.send_message(user_id, text)
    except Exception:
        # –ò–≥—Ä–æ–∫ –º–æ–≥ –∑–∞–∫—Ä—ã—Ç—å –õ–°/–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –±–æ—Ç–∞ ‚Äì –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
        pass


def faction_tuple_list() -> Tuple[Tuple[str, str], ...]:
    return (
        ("hq", "–®—Ç–∞–±"),
        ("blackhole", "Black Hole"),
        ("armless", "Armless"),
        ("brainless", "Brainless"),
        ("burning", "Burning Assholes"),
        ("freshmeat", "Fresh Meat"),
        ("useless", "Useless cans"),
        ("reserve", "–†–µ–∑–µ—Ä–≤"),
        ("blue", "Blueberry"),
        ("water", "Watermelon"),
        ("recruit", "Fresh Meat"),
        ("reserve", "–†–µ–∑–µ—Ä–≤"),
        ("command", "–®—Ç–∞–±"),
    )


# Settings storage (for admin-editable texts)
CREATE_SETTINGS_SQL = """
CREATE TABLE IF NOT EXISTS bot_settings (
    key TEXT PRIMARY KEY,
    value TEXT
)
"""

async def set_setting(key: str, value: str) -> None:
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO bot_settings(key,value) VALUES(?,?) ON CONFLICT(key) DO UPDATE SET value=excluded.value", (key, value))
        await db.commit()

async def get_setting(key: str, default: str | None = None) -> str | None:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT value FROM bot_settings WHERE key=?", (key,)) as cur:
            row = await cur.fetchone()
            return row[0] if row else default
async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(CREATE_SETTINGS_SQL)
        await db.execute(CREATE_USERS_SQL)
        await db.execute(CREATE_USERS_ARCHIVE_SQL)
        await db.execute(CREATE_TOURNAMENT_HISTORY_SQL)
        await db.execute(CREATE_REMOVE_TABLE_SQL)
        await db.execute(CREATE_CW_WARS_SQL)
        await db.execute(CREATE_CW_REGS_SQL)
        await db.execute(CREATE_CW_PLAYER_STATS_SQL)  # <-- –ù–û–í–û–ï
        await db.execute(CREATE_USER_ROLES_SQL) 
        await db.execute(CREATE_MOD_ACTIONS_SQL)
        await db.execute(CREATE_RATING_CHANGES_SQL)
        await db.execute("PRAGMA journal_mode=WAL;")
        await db.execute("PRAGMA busy_timeout = 5000;")
        # Migrations
        for alter in [
            "ALTER TABLE users ADD COLUMN applied_at TEXT",
            "ALTER TABLE users ADD COLUMN cw_wins INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN cw_losses INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN reserve_until TEXT",
            "ALTER TABLE users ADD COLUMN birth_date TEXT",
            "ALTER TABLE users ADD COLUMN faction TEXT",
            "ALTER TABLE users ADD COLUMN clan_id INTEGER",
            "ALTER TABLE users ADD COLUMN clan_title TEXT",
            "ALTER TABLE users ADD COLUMN elo_rating INTEGER DEFAULT 1000",
            "ALTER TABLE users ADD COLUMN elo_rank TEXT DEFAULT 'None",
            "ALTER TABLE users ADD COLUMN cw_revives INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN cw_kills INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN cw_deaths INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN cw_capture_points INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN cw_mvp_count INTEGER DEFAULT 0",
            "ALTER TABLE users ADD COLUMN cw_mvp_list TEXT",
            "ALTER TABLE users ADD COLUMN current_role TEXT",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE users_archive ADD COLUMN archived_at TEXT",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE removal_checklist ADD COLUMN db_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN tg_done INTEGER DEFAULT 0",
            "ALTER TABLE removal_checklist ADD COLUMN discord_done INTEGER DEFAULT 0",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                pass
        for alter in [
            "ALTER TABLE cw_wars ADD COLUMN bb_score INTEGER",
            "ALTER TABLE cw_wars ADD COLUMN opp_score INTEGER",
        ]:
            try:
                await db.execute(alter)
            except Exception:
                # –∫–æ–ª–æ–Ω–∫–∞ —É–∂–µ –µ—Å—Ç—å ‚Äì –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                pass
        await db.commit()
    await ensure_clan_ids()

async def ensure_clan_ids():
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) FROM users")
        (max_clan_id,) = await cur.fetchone()
        cur = await db.execute("SELECT user_id FROM users WHERE clan_id IS NULL ORDER BY rowid")
        rows = await cur.fetchall()
        next_id = max_clan_id + 1
        changed = False
        for (uid,) in rows:
            await db.execute("UPDATE users SET clan_id=? WHERE user_id=?", (next_id, uid))
            next_id += 1
            changed = True
        if changed:
            await db.commit()

async def next_clan_id(db: aiosqlite.Connection) -> int:
    cur = await db.execute("SELECT COALESCE(MAX(clan_id), 0) + 1 FROM users")
    (nid,) = await cur.fetchone()
    return int(nid)

async def upsert_user(user_id: int, **fields):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id, clan_id FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if row:
            cols = ", ".join([f"{k}=?" for k in fields.keys()])
            vals = list(fields.values()) + [user_id]
            await db.execute(f"UPDATE users SET {cols} WHERE user_id=?", vals)
        else:
            cid = await next_clan_id(db)
            keys = ["user_id", "clan_id", *fields.keys()]
            placeholders = ",".join(["?"] * len(keys))
            vals = [user_id, cid, *fields.values()]
            await db.execute(
                f"INSERT INTO users ({','.join(keys)}) VALUES ({placeholders})",
                vals,
            )
        await db.commit()

async def get_user(user_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM users WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

# ======= ROLES DB HELPERS =======

async def get_user_roles(user_id: int) -> list[str]:
    """–°–ø–∏—Å–æ–∫ –∫–æ–¥–æ–≤ —Ä–æ–ª–µ–π, —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏–≥—Ä–æ–∫–æ–º."""
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT role_code FROM user_roles WHERE user_id=?",
            (user_id,),
        )
        rows = await cur.fetchall()
    return [r[0] for r in rows]

async def add_user_role(user_id: int, role_code: str) -> None:
    """–ü–æ–º–µ—Ç–∏—Ç—å —Ä–æ–ª—å –∫–∞–∫ –æ—Ç–∫—Ä—ã—Ç—É—é (idempotent)."""
    ts = datetime.utcnow().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT OR IGNORE INTO user_roles(user_id, role_code, opened_at) VALUES (?,?,?)",
            (user_id, role_code, ts),
        )
        await db.commit()

async def set_user_current_role(user_id: int, role_code: str) -> None:
    """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ä–æ–ª—å –∏ –ø–æ–º–µ—Ç–∏—Ç—å –µ—ë –∫–∞–∫ –æ—Ç–∫—Ä—ã—Ç—É—é."""
    await add_user_role(user_id, role_code)
    await upsert_user(user_id, current_role=role_code)

async def get_user_by_username(username: str) -> Optional[dict]:
    uname = username.lstrip("@")
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE (tg_link LIKE ?) OR (LOWER(nickname)=LOWER(?)) LIMIT 1",
            (f"%t.me/{uname}%", uname,)
        )
        row = await cur.fetchone()
        if not row:
            return None
        columns = [col[0] for col in cur.description]
        return dict(zip(columns, row))

async def search_users_by_nickname(q: str, limit: int = 10) -> List[dict]:
    q = q.strip()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT * FROM users WHERE nickname LIKE ? ORDER BY created_at DESC LIMIT ?",
            (f"%{q}%", limit)
        )
        rows = await cur.fetchall()
        columns = [col[0] for col in cur.description]
        return [dict(zip(columns, r)) for r in rows]

# ======= FSM =======
class RegStates(StatesGroup):
    waiting_phone = State()
    waiting_nickname = State()
    waiting_discord = State()
    waiting_steam = State()
    waiting_birthdate = State()
    waiting_tz = State()
    waiting_tg_link = State()



class TournamentHistory(StatesGroup):
    waiting_text = State()
    waiting_elo = State()

class AdminEdit(StatesGroup):
    waiting_value = State()

class EloEditState(StatesGroup):
    waiting_new_elo = State()

class CWStatsState(StatesGroup):
    waiting_score = State()
    waiting_revives = State()
    waiting_kills = State()
    waiting_deaths = State()
    waiting_caps = State()

class CWViewStatsState(StatesGroup):
    waiting_war_id = State()

class ReserveUntilState(StatesGroup):
    waiting_date = State()
class TrainingReason(StatesGroup):
    waiting_reason = State()

class ReserveRequestState(StatesGroup):
    waiting_reason = State()
    waiting_date = State()




# ======= BOT SETUP =======
logging.basicConfig(level=logging.INFO)
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher()



@dp.callback_query(F.data.startswith("hist:add:"))
async def on_hist_add(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid = call.data.split(":")
    await state.update_data(hist_target_id=int(uid))
    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∑–∞–ø–∏—Å–∏ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ —Ç—É—Ä–Ω–∏—Ä–æ–≤ (–æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º).")
    await state.set_state(TournamentHistory.waiting_text)
    await call.answer()

@dp.message(TournamentHistory.waiting_text)
async def on_hist_text(message: Message, state: FSMContext):
    data = await state.get_data()
    target_id = data.get("hist_target_id")
    if not target_id:
        await message.answer("–¶–µ–ª–µ–≤–æ–π –∏–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return
    text = message.text.strip()
    if not text:
        await message.answer("–ü—É—Å—Ç–∞—è –∑–∞–ø–∏—Å—å –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞.")
        return

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—Å—Ç –∑–∞–ø–∏—Å–∏ –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –∑–∞–ø—Ä–æ—Å—É ELO
    await state.update_data(hist_text=text)
    await message.answer(
        "–°–∫–æ–ª—å–∫–æ –æ—á–∫–æ–≤ ELO –ø—Ä–∏–±–∞–≤–∏—Ç—å –∏–≥—Ä–æ–∫—É? –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (0, 25, 100 –∏ —Ç.–ø.)."
    )
    await state.set_state(TournamentHistory.waiting_elo)

@dp.message(TournamentHistory.waiting_elo)
async def on_hist_elo(message: Message, state: FSMContext):
    data = await state.get_data()
    target_id = data.get("hist_target_id")
    text = data.get("hist_text")

    if not target_id or not text:
        await message.answer("–î–∞–Ω–Ω—ã–µ –¥–ª—è –∑–∞–ø–∏—Å–∏ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ—Ç–µ—Ä—è–Ω—ã, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
        await state.clear()
        return

    raw = message.text.strip()
    try:
        elo_delta = int(raw)
    except ValueError:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0, 25 –∏–ª–∏ 100).")
        return

    if elo_delta < 0:
        await message.answer("–ß–∏—Å–ª–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 0 –∏–ª–∏ –±–æ–ª—å—à–µ.")
        return

    # 1) –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å –≤ –∏—Å—Ç–æ—Ä–∏—é —Ç—É—Ä–Ω–∏—Ä–æ–≤
    await add_tournament_history_entry(target_id, message.from_user.id, text)

     # 2) –∏–∑–º–µ–Ω—è–µ–º ELO –∏–≥—Ä–æ–∫–∞
    # –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º —Å—Ç–∞—Ä—ã–π ELO, —á—Ç–æ–±—ã –æ—Ç—Å–ª–µ–¥–∏—Ç—å —Å–º–µ–Ω—É —Ä–∞–Ω–≥–∞
    prev_user = await get_user(target_id)
    old_elo = (prev_user.get("elo_rating") if prev_user else None) or 1000

    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET elo_rating = COALESCE(elo_rating, 1000) + ? WHERE user_id=?",
            (elo_delta, target_id),
        )
        await db.commit()

    # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞
    if elo_delta != 0:
        await log_rating_change(target_id, elo_delta, reason="tournament_history")

    # –£–∑–Ω–∞—ë–º –Ω–æ–≤—ã–π ELO –∏, –µ—Å–ª–∏ —Ä–∞–Ω–≥ –∏–∑–º–µ–Ω–∏–ª—Å—è, —É–≤–µ–¥–æ–º–ª—è–µ–º –∏–≥—Ä–æ–∫–∞
    new_user = await get_user(target_id)
    new_elo = (new_user.get("elo_rating") if new_user else None) or 1000
    await notify_rank_if_changed(target_id, old_elo, new_elo)

    await state.clear()

    # 3) –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
    user = await get_user(target_id)
    try:
        await message.answer(
            f"‚úÖ –ó–∞–ø–∏—Å—å –¥–æ–±–∞–≤–ª–µ–Ω–∞, ELO –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ +{elo_delta}.",
            reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id),
        )
        await message.answer(
            format_profile(user, history=await get_tournament_history(int(user.get("user_id"))))
        )
    except Exception:
        pass

@dp.message(EloEditState.waiting_new_elo)
async def on_elo_edit_value(message: Message, state: FSMContext):
    data = await state.get_data()
    target_id = data.get("elo_edit_user_id")
    if not target_id:
        await message.answer("–¶–µ–ª–µ–≤–æ–π –∏–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ –ø—Ä–æ—Ñ–∏–ª—å.")
        await state.clear()
        return

    raw = (message.text or "").strip()
    try:
        new_elo = int(raw)
    except ValueError:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 1000, 1250).")
        return

    # —Å—Ç–∞—Ä—ã–π —Ä–µ–π—Ç–∏–Ω–≥
    user = await get_user(target_id)
    old_elo = (user.get("elo_rating") if user and user.get("elo_rating") is not None else 1000)

    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET elo_rating = ? WHERE user_id = ?",
            (new_elo, target_id),
        )
        await db.commit()

    delta = new_elo - old_elo
    if delta != 0:
        await log_rating_change(target_id, delta, reason=f"admin_set:{message.from_user.id}")
    await log_mod_action(message.from_user.id, "–†—É—á–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞", target_id=target_id, extra=f"{old_elo}->{new_elo}")

    # —É–≤–µ–¥–æ–º–ª—è–µ–º –æ —Å–º–µ–Ω–µ —Ä–∞–Ω–≥–∞
    await notify_rank_if_changed(target_id, old_elo, new_elo)

    await state.clear()

    await message.answer(f"–†–µ–π—Ç–∏–Ω–≥ –∏–≥—Ä–æ–∫–∞ –æ–±–Ω–æ–≤–ª—ë–Ω: {old_elo} ‚Üí {new_elo} ({'+' if delta >= 0 else ''}{delta}).")

    # –ø—Ä–æ–±—É–µ–º –æ–±–Ω–æ–≤–∏—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É –ø—Ä–æ—Ñ–∏–ª—è, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –±—ã–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã
    panel_chat_id = data.get("elo_edit_panel_chat_id")
    panel_msg_id = data.get("elo_edit_panel_msg_id")
    try:
        updated_user = await get_user(target_id)
        await bot.edit_message_text(
            format_profile(updated_user, history=await get_tournament_history(int(updated_user.get("user_id")))),
            chat_id=panel_chat_id,
            message_id=panel_msg_id,
            reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id),
        )
    except Exception:
        # –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        pass

@dp.callback_query(F.data.startswith("hist:clear:"))
async def on_hist_clear(call: CallbackQuery):
    if call.from_user.id not in ADMIN_IDS:
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid = call.data.split(":")
    target_id = int(uid)
    await clear_tournament_history(target_id)
    user = await get_user(target_id)
    try:
        await call.message.edit_text(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id))
    except Exception:
        await call.message.answer(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id))
    await call.answer("–ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞.")

async def ensure_training_tables():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            """CREATE TABLE IF NOT EXISTS training_attendance(
                date TEXT NOT NULL,
                user_id INTEGER NOT NULL,
                response TEXT NOT NULL,   -- 'yes' | 'no' | 'late'
                reason TEXT,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                PRIMARY KEY(date, user_id)
            )"""
        )
        await db.commit()

def phone_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üì± –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–º–µ—Ä–æ–º",
    )

def subscription_check_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üîî –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_sub")
    return kb.adjust(1).as_markup()

def apply_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üì® –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É", callback_data="send_apply")
    return kb.adjust(1).as_markup()

def profile_admin_kb(user_id: int, actor_id: int | None = None) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="üéØ –í—ã–±—Ä–∞—Ç—å —Ñ—Ä–∞–∫—Ü–∏—é", callback_data=f"profile_choosefac:{user_id}")
    kb.button(text="üóë –£–¥–∞–ª–∏—Ç—å –∏–≥—Ä–æ–∫–∞", callback_data=f"remove:init:{user_id}")
    kb.row()
    kb.button(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit:init:{user_id}")
    kb.button(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=f"profile_refresh:{user_id}")
    kb.row()
    kb.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –≤ –∏—Å—Ç–æ—Ä–∏—é Elo", callback_data=f"elo:panel:{user_id}")
    if actor_id in (ADMIN_IDS | MODERATOR_IDS):
        kb.button(text="üå≥ –ö–∞—Ä—å–µ—Ä–∞ –∏–≥—Ä–æ–∫–∞", callback_data=f"career:user:{user_id}")
    if actor_id in ADMIN_IDS:
        kb.row()
        kb.button(text="‚ùå –£–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω–∞", callback_data=f"profile_remove:{user_id}")
    return kb.adjust(1).as_markup()
    if actor_id in ADMIN_IDS:
        kb.button(text="‚öñ–ò–∑–º–µ–Ω–∏—Ç—å —Ä–µ–π—Ç–∏–Ω–≥", callback_data=f"elo:edit:{user_id}")
        kb.button(text="üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –∏–≥—Ä–æ–∫–∞", callback_data=f"hist:clear:{user_id}")
    return kb.adjust(1).as_markup()



def format_cw_datetime(iso_str: str) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã/–≤—Ä–µ–º–µ–Ω–∏ –ö–í –≤ –≤–∏–¥ –î–î.–ú–ú.–ì–ì –ß–ß:–ú–ú."""
    try:
        dt = datetime.fromisoformat(iso_str)
        return dt.strftime("%d.%m.%y %H:%M")
    except Exception:
        return iso_str


def faction_choose_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("hq","–®—Ç–∞–±"),("blackhole","Black Hole")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("armless","Armless"),("brainless","Brainless")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("burning","Burning Assholes"),("freshmeat","Fresh Meat")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    for code, title in (("useless","Useless cans"),("reserve","–†–µ–∑–µ—Ä–≤")):
        kb.button(text=title, callback_data=f"facset:{user_id}:{code}")
    kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()

def rank_choose_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for idx, title in enumerate(CLAN_TITLES):
        kb.button(text=title, callback_data=f"rank:set:{user_id}:{idx}")
        kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()

def roles_choose_kb(user_id: int, opened: set[str], current_role: str | None) -> InlineKeyboardMarkup:
    """
    –î–ï–†–ï–í–û —Ä–æ–ª–µ–π.
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ:
    - —Ç–µ–∫—É—â—É—é —Ä–æ–ª—å
    - —Ä–æ–¥–∏—Ç–µ–ª–µ–π (‚¨Ü)
    - –¥–µ—Ç–µ–π (‚¨á)
    –ù–∞ –∫–Ω–æ–ø–∫–∞—Ö –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è: –æ—Ç–∫—Ä—ã—Ç–æ –ª–∏, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—É—â–µ–π.
    """

    kb = InlineKeyboardBuilder()

    # –ï—Å–ª–∏ —Ä–æ–ª–∏ –µ—â—ë –Ω–µ—Ç ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º —Å —Ä–µ–∫—Ä—É—Ç–∞
    if not current_role or current_role not in ROLE_TITLES:
        current_role = "recruit"

    parents = ROLE_PARENTS.get(current_role, [])
    children = ROLE_GRAPH.get(current_role, [])

    # === –†–æ–¥–∏—Ç–µ–ª–∏ (–¥–≤–∏–∂–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö) ===
    for code in parents:
        opened_mark = "üü© –æ—Ç–∫—Ä—ã—Ç–æ" if code in opened else "‚¨õ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ"
        kb.button(
            text=f"‚¨Ü {get_role_title(code)} ‚Äî {opened_mark}",
            callback_data=f"role:set:{user_id}:{code}",
        )
        kb.row()

    # === –¢–µ–∫—É—â–∞—è —Ä–æ–ª—å (–Ω–µ –∫–Ω–æ–ø–∫–∞ —Å–º–µ–Ω—ã) ===
    opened_mark = "üü© –æ—Ç–∫—Ä—ã—Ç–æ" if current_role in opened else "‚¨õ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ"
    kb.button(
        text=f"üîπ {get_role_title(current_role)} ‚Äî {opened_mark} (—Ç–µ–∫—É—â–∞—è)",
        callback_data=f"noop",
    )
    kb.row()

    # === –î–µ—Ç–∏ (–≤–Ω–∏–∑ –ø–æ –≤–µ—Ç–∫–µ) ===
    for code in children:
        opened_mark = "üü© –æ—Ç–∫—Ä—ã—Ç–æ" if code in opened else "‚¨õ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ"
        kb.button(
            text=f"‚¨á {get_role_title(code)} ‚Äî {opened_mark}",
            callback_data=f"role:set:{user_id}:{code}",
        )
        kb.row()

    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()

def approve_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ü—Ä–∏–Ω—è—Ç—å", callback_data=f"approve:{user_id}")
    kb.button(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject:{user_id}")
    return kb.adjust(1).as_markup()

def edit_menu_kb(user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–ù–∏–∫", callback_data=f"edit:field:{user_id}:nickname")
    kb.button(text="Discord", callback_data=f"edit:field:{user_id}:discord")
    kb.button(text="SteamID", callback_data=f"edit:field:{user_id}:steamid")
    kb.row()
    kb.button(text="–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è", callback_data=f"edit:field:{user_id}:birth_date")
    kb.button(text="–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å", callback_data=f"edit:field:{user_id}:timezone")
    kb.button(text="–õ–∏—á–Ω—ã–π TG", callback_data=f"edit:field:{user_id}:tg_link")
    kb.row()
    kb.button(text="–ó–≤–∞–Ω–∏–µ", callback_data=f"edit:rank:{user_id}")
    kb.button(text="–†–æ–ª–∏", callback_data=f"edit:roles:{user_id}")
    kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()
def pad_clan_id(v: Optional[int]) -> str:
    if not v:
        return "‚Äî"
    return f"{int(v):04d}"

def format_profile(user: dict, title: str = "–ü—Ä–æ—Ñ–∏–ª—å –∏–≥—Ä–æ–∫–∞", history: list | None = None, pos: int | None = None) -> str:
    lines = [f"<b>{title}</b>"]
    fields = [
        ("ClanID", pad_clan_id(user.get("clan_id"))),
        ("Telegram ID", user.get("user_id")),
        ("–ù–∏–∫", user.get("nickname")),
        ("Discord", user.get("discord")),
        ("SteamID", user.get("steamid")),
        ("–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è", user.get("birth_date")),
        ("–í–æ–∑—Ä–∞—Å—Ç", user.get("age")),
        ("–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å", user.get("timezone")),
        ("–õ–∏—á–Ω—ã–π TG", user.get("tg_link")),
        ("–§—Ä–∞–∫—Ü–∏—è", user.get("faction")),
        ("–ó–≤–∞–Ω–∏–µ", user.get("clan_title")),
        ("–†–æ–ª—å", get_role_title(user.get("current_role"))),
        ("–°—Ç–∞—Ç—É—Å", user.get("status")),
        ("–°–æ–∑–¥–∞–Ω", user.get("created_at")),
        ("–ó–∞—è–≤–∫–∞", user.get("applied_at")),
        ("–û–¥–æ–±—Ä–µ–Ω", user.get("approved_at")),
        ("–†–µ–∑–µ—Ä–≤ –¥–æ", user.get("reserve_until")),
    ]
    for k, v in fields:
        if v not in (None, "", "None"):
            lines.append(f"{k}: {v}")
    cw_wins = user.get("cw_wins") or 0
    cw_losses = user.get("cw_losses") or 0
    lines.append(f"‚öî<b>–ö–í: –ø–æ–±–µ–¥—ã/–ø–æ—Ä–∞–∂–µ–Ω–∏—è</b> ‚Äî {cw_wins}/{cw_losses}")

    # –ù–æ–≤—ã–µ –ö–í-—Å—Ç–∞—Ç—ã
    revives = user.get("cw_revives") or 0
    kills = user.get("cw_kills") or 0
    deaths = user.get("cw_deaths") or 0
    caps = user.get("cw_capture_points") or 0

    if deaths:
        kd = kills / deaths
        kd_str = f"{kd:.2f}"
    else:
        kd_str = "‚àû" if kills else "0"

    lines.append(f"üíä<b>–ü–æ–¥–Ω—è—Ç–∏—è —Å–æ—é–∑–Ω–∏–∫–æ–≤:</b> {revives}")
    lines.append(f"üó°<b>–£–±–∏–π—Å—Ç–≤–∞/‚ò†—Å–º–µ—Ä—Ç–∏:</b> {kills}/{deaths} (K/D: {kd_str})")
    lines.append(f"üß≤<b>–û—á–∫–∏ –∑–∞—Ö–≤–∞—Ç–∞ (—Å—É–º–º–∞):</b> {caps}")

    mvp_count = user.get("cw_mvp_count") or 0
    if mvp_count:
        lines.append(f"\n<b>üëëMVP –≤ –ö–í:</b> {mvp_count} —Ä–∞–∑(–∞)")
        mvp_list = (user.get("cw_mvp_list") or "").strip()
        if mvp_list:
            wars_str = ", ".join(mvp_list.split(","))
            lines.append(f"{wars_str}")

    # –¢–µ–∫—É—â–µ–µ –º–µ—Å—Ç–æ –≤ –∫–ª–∞–Ω–µ
    elo = user.get("elo_rating") or 1000
    elo_int = int(elo)
    rank_name, color = get_rank(elo)
    lines.append(f"\n<b>üèÖ Elo-—Ä–µ–π—Ç–∏–Ω–≥:</b> <code>{elo_int} BBP</code>")
    lines.append(f'<b>üéñ –†–∞–Ω–≥:</b> <b>{rank_name}</b>')
    if pos:
        lines.append(f"üìä –ú–µ—Å—Ç–æ –≤ –∫–ª–∞–Ω–µ: {pos}")

# –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ ‚Äî –∏—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–µ `history`
    if history:
        lines.append("\n<b>–ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤</b>")
        for created_at, entry_text in history:
            lines.append(f"- [{created_at.split('T')[0]}] {entry_text}")


    return "\n".join(lines)

# === –ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è Elo (–≥—Ä–∞—Ñ–∏–∫ + –¥–∞–Ω–Ω—ã–µ) ===

def format_elo_change_reason(reason: str) -> str:
    """
    –ü—Ä–∏–≤–æ–¥–∏–º reason –∏–∑ rating_changes –∫ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º–æ–º—É –≤–∏–¥—É.
    """
    r = (reason or "").strip()
    if not r:
        return "—Ä—É—á–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ"
    if r.startswith("cw:"):
        war_id = r.split(":", 1)[1] or "?"
        return f"–ö–í #{war_id}"
    if r.startswith("training:"):
        return "—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞"
    if r == "training_attendance":
        return "–ø–æ—Å–µ—â–µ–Ω–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏"
    if r.startswith("tournament:"):
        return "—Ç—É—Ä–Ω–∏—Ä"
    return r


async def get_elo_history_for_user(
    user_id: int,
    days: int = 7,
) -> tuple[list[tuple[datetime, int]], list[tuple[str, int, str]]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
      1) —Ç–æ—á–∫–∏ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞ Elo –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ `days` –¥–Ω–µ–π ([(datetime, elo), ...])
      2) –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ–Ω–µ–Ω–∏–π Elo –≤ –≤–∏–¥–µ [(—Å—Ç—Ä–æ–∫–∞_–¥–∞—Ç—ã, delta, human_reason), ...]
    """
    now = datetime.utcnow()
    start = now - timedelta(days=days)

    async with aiosqlite.connect(DB_PATH) as db:
        # –¢–µ–∫—É—â–∏–π Elo
        cur = await db.execute(
            "SELECT COALESCE(elo_rating, 1000) FROM users WHERE user_id = ?",
            (user_id,),
        )
        row = await cur.fetchone()
        current_elo = int(row[0] if row and row[0] is not None else 1000)

        # –ò–∑–º–µ–Ω–µ–Ω–∏—è –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ `days` –¥–Ω–µ–π
        cur = await db.execute(
            """
            SELECT delta, created_at
            FROM rating_changes
            WHERE user_id = ?
              AND datetime(created_at) >= datetime(?)
            ORDER BY datetime(created_at), id
            """,
            (user_id, start.isoformat()),
        )
        week_rows = await cur.fetchall()

        # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ–Ω–µ–Ω–∏–π –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
        cur = await db.execute(
            """
            SELECT delta, reason, created_at
            FROM rating_changes
            WHERE user_id = ?
            ORDER BY id DESC
            LIMIT 10
            """,
            (user_id,),
        )
        last_rows = await cur.fetchall()

    total_week_delta = sum(int(r[0]) for r in week_rows) if week_rows else 0
    base_elo = current_elo - total_week_delta

    # –¢–æ—á–∫–∏ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
    points: list[tuple[datetime, int]] = []
    current_value = base_elo
    points.append((start, current_value))

    for delta, created_at in week_rows:
        try:
            dt = datetime.fromisoformat(created_at)
        except Exception:
            dt = start
        current_value += int(delta)
        points.append((dt, current_value))

    # —Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ "—Å–µ–π—á–∞—Å"
    if not points or points[-1][0] < now:
        points.append((now, current_value))

    # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ–Ω–µ–Ω–∏–π ‚Äî —Å—Ä–∞–∑—É –≤ —É–¥–æ–±–Ω–æ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
    last_changes: list[tuple[str, int, str]] = []
    for delta, reason, created_at in last_rows:
        try:
            dt = datetime.fromisoformat(created_at)
            dt_str = dt.strftime("%d.%m.%Y %H:%M")
        except Exception:
            dt_str = str(created_at)
        last_changes.append(
            (dt_str, int(delta), format_elo_change_reason(reason or ""))
        )

    return points, last_changes


def generate_elo_history_image(
    user_id: int,
    nickname: str | None,
    points: list[tuple[datetime, int]],
) -> str:
    """
    –°—Ç—Ä–æ–∏—Ç –∫–∞—Ä—Ç–∏–Ω–∫—É-–≥—Ä–∞—Ñ–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è Elo –∑–∞ –Ω–µ–¥–µ–ª—é –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ PNG.
    """
    width, height = 900, 400

    base_dir = os.path.dirname(os.path.abspath(__file__))
    icons_dir = os.path.join(base_dir, "icons")

    # –§–æ–Ω ‚Äî –±–µ—Ä—ë–º profile_bg/top_bg, –µ—Å–ª–∏ –µ—Å—Ç—å
    try:
        bg_path = os.path.join(icons_dir, "top_bg.png")
        if os.path.exists(bg_path):
            img = Image.open(bg_path).convert("RGBA").resize((width, height))
        else:
            bg_path = os.path.join(icons_dir, "profile_bg.png")
            img = Image.open(bg_path).convert("RGBA").resize((width, height))
    except Exception:
        img = Image.new("RGBA", (width, height), (20, 10, 30, 255))

    draw = ImageDraw.Draw(img)

    # –®—Ä–∏—Ñ—Ç—ã
    try:
        title_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 32)
        label_font = ImageFont.truetype("DejaVuSans.ttf", 20)
    except Exception:
        title_font = label_font = ImageFont.load_default()

    if not points:
        # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π ‚Äî –ø–ª–æ—Å–∫–∞—è –ª–∏–Ω–∏—è
        now = datetime.utcnow()
        points = [(now - timedelta(days=7), 1000), (now, 1000)]

    times = [p[0] for p in points]
    values = [p[1] for p in points]

    t_min = min(times)
    t_max = max(times)
    v_min = min(values)
    v_max = max(values)

    # —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
    if t_min == t_max:
        t_min = t_min - timedelta(days=1)
        t_max = t_max + timedelta(days=1)
    if v_min == v_max:
        v_min -= 50
        v_max += 50

    left, right, top, bottom = 80, 40, 80, height - 60

    # –û—Å–∏
    draw.line((left, top, left, bottom), fill=(230, 230, 230), width=2)
    draw.line((left, bottom, width - right, bottom), fill=(230, 230, 230), width=2)

    # –ó–∞–≥–æ–ª–æ–≤–æ–∫
    title = f"–ò—Å—Ç–æ—Ä–∏—è Elo (7 –¥–Ω–µ–π) ‚Äî {nickname or user_id}"
    draw.text((left, 30), title, font=title_font, fill=(240, 240, 240))

    # Y: –º–∏–Ω–∏–º—É–º, —Å–µ—Ä–µ–¥–∏–Ω–∞, –º–∞–∫—Å–∏–º—É–º
    mid_v = int((v_min + v_max) / 2)
    for val in (int(v_min), mid_v, int(v_max)):
        y = bottom - (val - v_min) / (v_max - v_min) * (bottom - top)
        draw.line((left, y, width - right, y), fill=(60, 60, 90), width=1)
        label = str(val)
        bbox = draw.textbbox((0, 0), label, font=label_font)
        draw.text(
            (left - (bbox[2] - bbox[0]) - 8, y - (bbox[3] - bbox[1]) / 2),
            label,
            font=label_font,
            fill=(210, 210, 230),
        )

    # X: –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü –ø–µ—Ä–∏–æ–¥–∞
    total_sec = (t_max - t_min).total_seconds() or 1.0
    for dt in (t_min, t_max):
        x = left + (dt - t_min).total_seconds() / total_sec * (width - left - right)
        label = dt.strftime("%d.%m")
        bbox = draw.textbbox((0, 0), label, font=label_font)
        draw.text(
            (x - (bbox[2] - bbox[0]) / 2, bottom + 6),
            label,
            font=label_font,
            fill=(210, 210, 230),
        )

    # –õ–∏–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞
    prev_xy: tuple[float, float] | None = None
    for dt, val in points:
        x = left + (dt - t_min).total_seconds() / total_sec * (width - left - right)
        y = bottom - (val - v_min) / (v_max - v_min) * (bottom - top)
        if prev_xy is not None:
            draw.line((*prev_xy, x, y), fill=(255, 215, 0), width=3)
        prev_xy = (x, y)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º
    out_dir = os.path.join(base_dir, "elo_history")
    os.makedirs(out_dir, exist_ok=True)
    filename = f"elo_history_{user_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.png"
    full_path = os.path.join(out_dir, filename)
    img.save(full_path, "PNG")

    return full_path

def hex_to_rgb(hex_color: str) -> tuple[int, int, int]:
    """
    –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç HEX-—Ü–≤–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, "#ffd700") –≤ –∫–æ—Ä—Ç–µ–∂ RGB.
    """
    hex_color = (hex_color or "").lstrip("#")
    if len(hex_color) == 3:
        hex_color = "".join(ch * 2 for ch in hex_color)
    try:
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))  # type: ignore[return-value]
    except Exception:
        # –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π –ø–æ—á—Ç–∏-—á—ë—Ä–Ω—ã–π, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –ø—Ä–∏—à—ë–ª –∫—Ä–∏–≤–æ–π —Ü–≤–µ—Ç
        return (20, 20, 20)

def get_rank_badge_text(rank_name: str) -> str:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π –±–µ–π–¥–∂ —Ä–∞–Ω–≥–∞ (–±–µ–∑ —ç–º–æ–¥–∑–∏),
    —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–æ–≤ –≤ –∫–∞—Ä—Ç–∏–Ω–∫–µ.
    """
    if not rank_name:
        return "NONE"

    name = rank_name.lower()
    if "bronze" in name:
        return "BRZ"
    if "silver" in name:
        return "SLV"
    if "gold" in name:
        return "GLD"
    if "platinum" in name:
        return "PLT"
    if "diamond" in name:
        return "DIA"

    return "RANK"

def get_rank_icon_path(rank_name: str) -> str | None:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ PNG-–∏–∫–æ–Ω–∫–µ —Ä–∞–Ω–≥–∞ –∏–∑ –ø–∞–ø–∫–∏ icons —Ä—è–¥–æ–º —Å —Ñ–∞–π–ª–æ–º –±–æ—Ç–∞.
    Bronze I-III -> bronze.png, Silver I-IV -> silver.png, Gold I-IV -> gold.png, Platinum -> platinum.png.
    """
    base_dir = os.path.dirname(os.path.abspath(__file__))
    icons_dir = os.path.join(base_dir, "icons")

    name = (rank_name or "").lower()
    if "bronze" in name:
        filename = "bronze.png"
    elif "silver" in name:
        filename = "silver.png"
    elif "gold" in name:
        filename = "gold.png"
    elif "platinum" in name:
        filename = "platinum.png"
    else:
        return None

    path = os.path.join(icons_dir, filename)
    return path if os.path.exists(path) else None

def generate_profile_card_image(user: dict, history: list | None = None, pos: int | None = None) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç PNG-–∫–∞—Ä—Ç–∏–Ω–∫—É –ø—Ä–æ—Ñ–∏–ª—è –∏–≥—Ä–æ–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–º—É —Ñ–∞–π–ª—É.
    –§–æ–Ω –∏ –∞–∫—Ü–µ–Ω—Ç—ã –∑–∞–≤—è–∑–∞–Ω—ã –Ω–∞ —Ü–≤–µ—Ç —Ä–∞–Ω–≥–∞ –∏–∑ RANKS.
    """
    # –ë–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    nickname = user.get("nickname") or "–ë–µ–∑ –Ω–∏–∫–∞"
    clan_id = pad_clan_id(user.get("clan_id"))
    faction = user.get("faction") or "‚Äî"
    clan_title = user.get("clan_title") or "‚Äî"
    timezone_val = user.get("timezone") or "‚Äî"
    tg_id = user.get("user_id") or "-"
    elo = user.get("elo_rating") or 1000
    elo_int = int(elo)
    rank_name, rank_color = get_rank(elo)

    cw_wins = user.get("cw_wins") or 0
    cw_losses = user.get("cw_losses") or 0
    revives = user.get("cw_revives") or 0
    kills = user.get("cw_kills") or 0
    deaths = user.get("cw_deaths") or 0
    caps = user.get("cw_capture_points") or 0
    mvp_count = user.get("cw_mvp_count") or 0

    if deaths:
        kd = kills / deaths
        kd_str = f"{kd:.2f}"
    else:
        kd_str = "‚àû" if kills else "0"

    tournaments_count = len(history) if history else 0

    # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–æ–ª–æ—Ç–Ω–∞
    width, height = 900, 520
    rank_rgb = hex_to_rgb(rank_color)

    # –§–æ–Ω: –ø—Ä–æ–±—É–µ–º –≤–∑—è—Ç—å –≥–æ—Ç–æ–≤—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É, –∏–Ω–∞—á–µ ‚Äî —Å—Ç–∞—Ä—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
    try:
        img = Image.open("icons/profile_bg.png").convert("RGBA")
        img = img.resize((width, height))
    except Exception:
        img = Image.new("RGBA", (width, height))
        # –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω –æ—Ç —Ü–≤–µ—Ç–∞ —Ä–∞–Ω–≥–∞ –∫ —Ç—ë–º–Ω–æ–º—É
        for y in range(height):
            ratio = y / (height - 1)
            r = int(rank_rgb[0] * (1 - ratio) + 15 * ratio)
            g = int(rank_rgb[1] * (1 - ratio) + 15 * ratio)
            b = int(rank_rgb[2] * (1 - ratio) + 30 * ratio)
            for x in range(width):
                img.putpixel((x, y), (r, g, b))

    draw = ImageDraw.Draw(img)

    # –®—Ä–∏—Ñ—Ç—ã
    try:
        title_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 40)
        subtitle_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 26)
        text_font = ImageFont.truetype("DejaVuSans.ttf", 22)
    except Exception:
        # –µ—Å–ª–∏ ttf-—à—Ä–∏—Ñ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ
        title_font = ImageFont.load_default()
        subtitle_font = ImageFont.load_default()
        text_font = ImageFont.load_default()

    # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ø–∞–Ω–µ–ª—å
    content_margin = 40
    panel_x0 = content_margin
    panel_y0 = content_margin
    panel_x1 = width - content_margin
    panel_y1 = height - content_margin
    panel_fill = (10, 10, 20, 180)  # –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –ø–æ–¥–ª–æ–∂–∫–∞
    panel_outline = rank_rgb

    # –†–∏—Å—É–µ–º –ø–æ–¥–ª–æ–∂–∫—É –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Å–ª–æ–µ –∏ –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –ø–æ–≤–µ—Ä—Ö —Ñ–æ–Ω–∞
    panel_layer = Image.new("RGBA", img.size, (0, 0, 0, 0))
    panel_draw = ImageDraw.Draw(panel_layer)
    try:
        panel_draw.rounded_rectangle(
            (panel_x0, panel_y0, panel_x1, panel_y1),
            radius=30,
            fill=panel_fill,
            outline=panel_outline,
            width=4,
        )
    except Exception:
        # –µ—Å–ª–∏ rounded_rectangle –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        panel_draw.rectangle(
            (panel_x0, panel_y0, panel_x1, panel_y1),
            fill=panel_fill,
            outline=panel_outline,
            width=4,
        )

    img = Image.alpha_composite(img.convert("RGBA"), panel_layer)
    draw = ImageDraw.Draw(img)

    # –®–∞–ø–∫–∞
    y = panel_y0 + 30
    x = panel_x0 + 30

    # –í–º–µ—Å—Ç–æ —ç–º–æ–¥–∑–∏ –¥–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π –±–µ–π–¥–∂ (GLD, BRZ, ...),
    # —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–æ–≤
    rank_badge = get_rank_badge_text(rank_name)
    title_text = f"{nickname}"
    draw.text((x, y), title_text, font=title_font, fill=(255, 255, 255))

    y += 60
    draw.text(
        (x, y),
        f"–§—Ä–∞–∫—Ü–∏—è: {faction}",
        font=subtitle_font,
        fill=(220, 220, 220),
    )

    y += 32
    draw.text(
        (x, y),
        f"–ó–≤–∞–Ω–∏–µ: {clan_title}",
        font=subtitle_font,
        fill=(220, 220, 220),
    )

   # –ë–ª–æ–∫ Elo / —Ä–∞–Ω–≥–∞ –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É
    ELO_BLOCK_WIDTH = 340   # —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –ø–æ–¥ –∏–∫–æ–Ω–∫—É + —Ç–µ–∫—Å—Ç
    ELO_BLOCK_HEIGHT = 150  # –Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –±–ª–æ–∫–∞

    elo_block_x = panel_x1 - ELO_BLOCK_WIDTH - 20
    elo_block_y = panel_y0 + 80
    elo_box = (
        elo_block_x,
        elo_block_y,
        elo_block_x + ELO_BLOCK_WIDTH,
        elo_block_y + ELO_BLOCK_HEIGHT,
    )
    try:
        draw.rounded_rectangle(
            elo_box,
            radius=20,
            fill=(0, 0, 0, 160),
            outline=panel_outline,
            width=2,
        )
    except Exception:
        draw.rectangle(
            elo_box,
            fill=(0, 0, 0, 160),
            outline=panel_outline,
            width=2,
        )

    # –ü–æ–∑–∏—Ü–∏–∏ –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞
    padding = 4
    text_x = elo_block_x + padding + 90  # —Ç–µ–∫—Å—Ç —Å–ø—Ä–∞–≤–∞ –æ—Ç –∏–∫–æ–Ω–∫–∏
    text_y = elo_block_y + 20

    # –ò–∫–æ–Ω–∫–∞ —Ä–∞–Ω–≥–∞
    icon_path = get_rank_icon_path(rank_name)
    if icon_path and os.path.exists(icon_path):
        try:
            icon = Image.open(icon_path).convert("RGBA")

            ICON_SIZE = 96  # —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è –∏–∫–æ–Ω–∫–∞
            icon = icon.resize((ICON_SIZE, ICON_SIZE), Image.LANCZOS)

            # –¶–µ–Ω—Ç—Ä—É–µ–º –∏–∫–æ–Ω–∫—É –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –±–ª–æ–∫–∞ Elo
            icon_x = elo_block_x + padding
            icon_y = elo_block_y + (ELO_BLOCK_HEIGHT - ICON_SIZE) // 2

            img.paste(icon, (icon_x, icon_y), icon)
        except Exception:
            # –µ—Å–ª–∏ —Å –∏–∫–æ–Ω–∫–æ–π —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ ‚Äî –ø—Ä–æ—Å—Ç–æ —Ä–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç –±–µ–∑ –Ω–µ—ë
            pass

    # –¢–µ–∫—Å—Ç Elo –∏ —Ä–∞–Ω–≥–∞
    draw.text((text_x, text_y), f"Elo: {elo_int} BBP", font=subtitle_font, fill=(255, 255, 255))
    text_y += 40

    # –£–±–∏—Ä–∞–µ–º —ç–º–æ–¥–∑–∏ –∏–∑ rank_name, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—É—é —á–∞—Å—Ç—å
    if " " in rank_name:
        clean_rank = rank_name.split(" ", 1)[1]
    else:
        clean_rank = rank_name

    draw.text((text_x, text_y), f"–†–∞–Ω–≥: {clean_rank}", font=text_font, fill=(255, 255, 255))
    text_y += 32

    pos_str = f"#{pos}" if pos else "‚Äî"
    draw.text(
        (text_x, text_y),
        f"–ú–µ—Å—Ç–æ –≤ –∫–ª–∞–Ω–µ: {pos_str}",
        font=text_font,
        fill=(220, 220, 220),
    )

    # –ë–ª–æ–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ö–í
    stats_x = panel_x0 + 30
    stats_y = panel_y0 + 150
    draw.text((stats_x, stats_y), "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ö–í", font=subtitle_font, fill=(255, 255, 255))
    stats_y += 40
    draw.text(
        (stats_x, stats_y),
        f"–ü–æ–±–µ–¥—ã / –ü–æ—Ä–∞–∂–µ–Ω–∏—è: {cw_wins} / {cw_losses}",
        font=text_font,
        fill=(220, 220, 220),
    )
    stats_y += 30
    draw.text(
        (stats_x, stats_y),
        f"K/D: {kills}/{deaths} ({kd_str})",
        font=text_font,
        fill=(220, 220, 220),
    )
    stats_y += 30
    draw.text(
        (stats_x, stats_y),
        f"–ü–æ–¥–Ω—è—Ç–∏—è —Å–æ—é–∑–Ω–∏–∫–æ–≤: {revives}",
        font=text_font,
        fill=(220, 220, 220),
    )
    stats_y += 30
   # –û—á–∫–∏ –∑–∞—Ö–≤–∞—Ç–∞
    draw.text(
        (stats_x, stats_y),
        f"–û—á–∫–∏ –∑–∞—Ö–≤–∞—Ç–∞ (—Å—É–º–º–∞): {caps}",
        font=text_font,
        fill=(220, 220, 220),
    )

    # –ß—É—Ç—å –Ω–∏–∂–µ ‚Äî —Å—Ç—Ä–æ–∫–∞ MVP —Å –∏–∫–æ–Ω–∫–æ–π
    stats_y += 40
    mvp_icon_size = 32
    mvp_icon_offset_y = -4  # –ø–æ–¥—Ä–æ–≤–Ω—è—Ç—å –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ —Å —Ç–µ–∫—Å—Ç–æ–º

    icon_x = stats_x
    icon_y = stats_y

    try:
        mvp_icon = Image.open("icons/mvp.png").convert("RGBA")
        mvp_icon = mvp_icon.resize((mvp_icon_size, mvp_icon_size))
        img.paste(mvp_icon, (icon_x, icon_y + mvp_icon_offset_y), mvp_icon)
    except Exception:
        # fallback: –µ—Å–ª–∏ –∏–∫–æ–Ω–∫–∏ –Ω–µ—Ç, —Ä–∏—Å—É–µ–º —ç–º–æ–¥–∑–∏
        draw.text(
            (icon_x, icon_y),
            "üëë",
            font=text_font,
            fill=(220, 220, 220),
        )

    mvp_text_x = icon_x + mvp_icon_size + 8
    mvp_line = f"MVP –≤ –ö–í: {mvp_count} —Ä–∞–∑(–∞)" if mvp_count else "MVP –≤ –ö–í: ‚Äî"
    draw.text(
        (mvp_text_x, stats_y),
        mvp_line,
        font=text_font,
        fill=(220, 220, 220),
    )

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É —Ä—è–¥–æ–º —Å main.py –≤ –ø–∞–ø–∫—É profile_cards

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É —Ä—è–¥–æ–º —Å main.py –≤ –ø–∞–ø–∫—É profile_cards
    base_dir = os.path.dirname(os.path.abspath(__file__))
    out_dir = os.path.join(base_dir, "profile_cards")
    os.makedirs(out_dir, exist_ok=True)

    filename = f"profile_{tg_id}.png"
    full_path = os.path.join(out_dir, filename)
    img.save(full_path, "PNG")

    return full_path

def generate_top_leaderboard_image(entries: list[tuple[int, str, int, int, str]]) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é PNG-–∫–∞—Ä—Ç–∏–Ω–∫—É –¢–û–ü-20 –∏–≥—Ä–æ–∫–æ–≤.
    entries: —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (place, nickname, elo, delta_elo, rank_name)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–º—É —Ñ–∞–π–ª—É.
    """
    width = 900
    row_height = 40
    header_height = 140
    footer_height = 40
    rows_count = max(len(entries), 1)
    height = header_height + row_height * rows_count + footer_height

    base_dir = os.path.dirname(os.path.abspath(__file__))
    icons_dir = os.path.join(base_dir, "icons")

    # –§–æ–Ω: —Å–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å top_bg.png, –∑–∞—Ç–µ–º profile_bg.png, –∏–Ω–∞—á–µ ‚Äî –æ–¥–Ω–æ—Ç–æ–Ω–Ω—ã–π
    try:
        bg_path = os.path.join(icons_dir, "top_bg.png")
        if os.path.exists(bg_path):
            img = Image.open(bg_path).convert("RGBA").resize((width, height))
        else:
            bg_path = os.path.join(icons_dir, "profile_bg.png")
            img = Image.open(bg_path).convert("RGBA").resize((width, height))
    except Exception:
        img = Image.new("RGBA", (width, height), (20, 10, 30, 255))

    draw = ImageDraw.Draw(img)

    # –®—Ä–∏—Ñ—Ç—ã
    try:
        title_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 42)
        header_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 26)
        row_font = ImageFont.truetype("DejaVuSans.ttf", 24)
    except Exception:
        title_font = header_font = row_font = ImageFont.load_default()

    # –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –ø–∞–Ω–µ–ª—å
    margin = 30
    panel_x0 = margin
    panel_y0 = margin
    panel_x1 = width - margin
    panel_y1 = height - margin

    panel_layer = Image.new("RGBA", img.size, (0, 0, 0, 0))
    panel_draw = ImageDraw.Draw(panel_layer)
    panel_fill = (10, 10, 20, 200)
    panel_outline = (140, 80, 255)

    try:
        panel_draw.rounded_rectangle(
            (panel_x0, panel_y0, panel_x1, panel_y1),
            radius=30,
            fill=panel_fill,
            outline=panel_outline,
            width=3,
        )
    except Exception:
        panel_draw.rectangle(
            (panel_x0, panel_y0, panel_x1, panel_y1),
            fill=panel_fill,
            outline=panel_outline,
            width=3,
        )

    img = Image.alpha_composite(img, panel_layer)
    draw = ImageDraw.Draw(img)

    # –ó–∞–≥–æ–ª–æ–≤–æ–∫ (—á—É—Ç—å –≤—ã—à–µ, —á—Ç–æ–±—ã –≤—Å—è —Ç–∞–±–ª–∏—Ü–∞ –ø–æ–ø–∞–ª–∞ –≤ —Ä–∞–º–∫—É)
    title = "–¢–û–ü-20 –∏–≥—Ä–æ–∫–æ–≤ –∫–ª–∞–Ω–∞"
    title_x = panel_x0 + 40
    title_y = panel_y0 + 20  # –±—ã–ª–æ ~+30, –ø–æ–¥–Ω—è–ª–∏ –±–ª–∏–∂–µ –∫ –≤–µ—Ä—Ö—É –ø–∞–Ω–µ–ª–∏
    draw.text((title_x, title_y), title, font=title_font, fill=(255, 255, 255))

    # –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∫–æ–ª–æ–Ω–æ–∫
    col_y = title_y + 55  # –±—ã–ª–æ +70, –ø–æ–¥–Ω–∏–º–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –≤—ã—à–µ
    col_no_x = panel_x0 + 40
    col_rank_x = col_no_x + 60
    col_name_x = col_rank_x + 90   # —Å–º–µ—â–∞–µ–º "–ù–∏–∫" –ø—Ä–∞–≤–µ–µ
    col_elo_x = panel_x1 - 260
    col_delta_x = panel_x1 - 130

    draw.text((col_no_x, col_y), "‚Ññ", font=header_font, fill=(200, 200, 255))
    draw.text((col_rank_x, col_y), "–†–∞–Ω–≥", font=header_font, fill=(200, 200, 255))
    draw.text((col_name_x, col_y), "–ù–∏–∫", font=header_font, fill=(200, 200, 255))
    draw.text((col_elo_x, col_y), "ELO", font=header_font, fill=(200, 200, 255))
    draw.text((col_delta_x, col_y), "Œî ELO", font=header_font, fill=(200, 200, 255))

    # –ò–∫–æ–Ω–∫–∏ —Å—Ç—Ä–µ–ª–æ–∫
    up_icon = down_icon = None
    try:
        up_path = os.path.join(icons_dir, "up.png")
        down_path = os.path.join(icons_dir, "down.png")
        icon_size = (24, 24)

        if os.path.exists(up_path):
            up_icon = Image.open(up_path).convert("RGBA").resize(icon_size, Image.LANCZOS)
        if os.path.exists(down_path):
            down_icon = Image.open(down_path).convert("RGBA").resize(icon_size, Image.LANCZOS)
    except Exception:
        up_icon = down_icon = None

    # –°—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã (–ë–ï–ó –±–µ–ª–æ–π –∑–∞–ª–∏–≤–∫–∏ –¥–ª—è —á—ë—Ç–Ω—ã—Ö —Å—Ç—Ä–æ–∫)
    y = col_y + 30   # –±—ã–ª–æ +40, –ø–æ–¥–Ω–∏–º–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –±–ª–∏–∂–µ –∫ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º
    for place, nickname, elo, delta, rank_name in entries:
        # –ù–æ–º–µ—Ä –º–µ—Å—Ç–∞
        draw.text((col_no_x, y), f"{place}", font=row_font, fill=(230, 230, 230))

        # –ò–∫–æ–Ω–∫–∞ —Ä–∞–Ω–≥–∞
        rank_icon_path = get_rank_icon_path(rank_name)
        if rank_icon_path:
            try:
                rank_icon = Image.open(rank_icon_path).convert("RGBA").resize((40, 40), Image.LANCZOS)
                img.paste(rank_icon, (col_rank_x, y), rank_icon)
            except Exception:
                # –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ ‚Äî —Ä–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π –±–µ–π–¥–∂
                badge = get_rank_badge_text(rank_name)
                draw.text((col_rank_x, y), badge, font=row_font, fill=(180, 180, 255))
        else:
            # –§–æ–ª–ª–±–µ–∫, –µ—Å–ª–∏ –∏–∫–æ–Ω–∫–∏ –Ω–µ—Ç
            badge = get_rank_badge_text(rank_name)
            draw.text((col_rank_x, y), badge, font=row_font, fill=(180, 180, 255))

        # –ù–∏–∫ (–æ–±—Ä–µ–∑–∞–µ–º —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–µ)
        nick_text = nickname or "‚Äî"
        if len(nick_text) > 24:
            nick_text = nick_text[:21] + "..."
        draw.text((col_name_x, y), nick_text, font=row_font, fill=(255, 255, 255))

        # –¢–µ–∫—É—â–∏–π ELO
        draw.text((col_elo_x, y), f"{elo}", font=row_font, fill=(230, 230, 230))

        # –ò–∑–º–µ–Ω–µ–Ω–∏–µ ELO
        if delta > 0:
            delta_str = f"+{delta}"
            delta_color = (180, 255, 180)
        elif delta < 0:
            delta_str = str(delta)
            delta_color = (255, 180, 180)
        else:
            delta_str = "0"
            delta_color = (220, 220, 220)

        draw.text((col_delta_x, y), delta_str, font=row_font, fill=delta_color)

        # –°—Ç—Ä–µ–ª–∫–∞ –æ–∫–æ–ª–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        arrow_x = col_delta_x - 32
        arrow_y = y - 2
        if delta > 0:
            if up_icon is not None:
                img.paste(up_icon, (arrow_x, arrow_y), up_icon)
            else:
                draw.text((arrow_x, y), "‚Üë", font=row_font, fill=(0, 255, 0))
        elif delta < 0:
            if down_icon is not None:
                img.paste(down_icon, (arrow_x, arrow_y), down_icon)
            else:
                draw.text((arrow_x, y), "‚Üì", font=row_font, fill=(255, 0, 0))

        y += row_height

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É
    out_dir = os.path.join(base_dir, "leaderboards")
    os.makedirs(out_dir, exist_ok=True)
    filename = f"top20_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.png"
    full_path = os.path.join(out_dir, filename)
    img.save(full_path, "PNG")

    return full_path

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É
    out_dir = os.path.join(base_dir, "leaderboards")
    os.makedirs(out_dir, exist_ok=True)
    filename = f"top20_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.png"
    full_path = os.path.join(out_dir, filename)
    img.save(full_path, "PNG")

    return full_path

def generate_cw_result_image(
    war: dict,
    bb_score: int,
    opp_score: int,
    mvp_name: str | None = None,
) -> str:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–∞—Ä—Ç–æ—á–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ö–í (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ —Å Pillow 10+).
    """
    from datetime import datetime
    import os
    import re
    from PIL import Image, ImageDraw, ImageFont

    base_dir = os.path.dirname(os.path.abspath(__file__))
    icons_dir = os.path.join(base_dir, "icons")

    width, height = 1280, 720

    # --- —Ñ–æ–Ω ---
    try:
        bg_path = os.path.join(icons_dir, "backkw.png")
        if os.path.exists(bg_path):
            img = Image.open(bg_path).convert("RGBA").resize((width, height))
        else:
            img = Image.new("RGBA", (15, 0, 35, 255))
    except Exception:
        img = Image.new("RGBA", (15, 0, 35, 255))

    draw = ImageDraw.Draw(img)

    # --- —à—Ä–∏—Ñ—Ç—ã ---
    try:
        title_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 52)
        score_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 90)
        name_font = ImageFont.truetype("DejaVuSans-Bold.ttf", 32)
        small_font = ImageFont.truetype("DejaVuSans.ttf", 24)
        tiny_font = ImageFont.truetype("DejaVuSans.ttf", 20)
    except Exception:
        title_font = score_font = name_font = small_font = tiny_font = ImageFont.load_default()

    # --- —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ø–∞–Ω–µ–ª—å ---
    panel_margin_x, panel_margin_y = 70, 60
    panel_x0 = panel_margin_x
    panel_y0 = panel_margin_y
    panel_x1 = width - panel_margin_x
    panel_y1 = height - panel_margin_y

    panel_layer = Image.new("RGBA", img.size, (0, 0, 0, 0))
    panel_draw = ImageDraw.Draw(panel_layer)
    try:
        panel_draw.rounded_rectangle(
            (panel_x0, panel_y0, panel_x1, panel_y1),
            radius=40,
            fill=(5, 0, 20, 200),
            outline=(150, 90, 255, 255),
            width=3,
        )
    except Exception:
        panel_draw.rectangle(
            (panel_x0, panel_y0, panel_x1, panel_y1),
            fill=(5, 0, 20, 200),
            outline=(150, 90, 255, 255),
            width=3,
        )
    img = Image.alpha_composite(img, panel_layer)
    draw = ImageDraw.Draw(img)

    # --- BB vs OPPONENT ---
    opponents = (war.get("opponents") or "").strip() or "BB vs ?"
    bb_tag = "BB"
    enemy_tag = "OPPONENT"

    low = opponents.lower()
    if "vs" in low:
        left, right = opponents.split("vs", 1)
        left = left.strip()
        right = right.strip()
        if left:
            bb_tag = left
        if right:
            enemy_tag = right
    else:
        enemy_tag = opponents

    title = f"{bb_tag} vs {enemy_tag}"
    title_bbox = draw.textbbox((0, 0), title, font=title_font)
    title_w = title_bbox[2] - title_bbox[0]
    title_h = title_bbox[3] - title_bbox[1]
    title_x = panel_x0 + (panel_x1 - panel_x0 - title_w) // 2
    title_y = panel_y0 + 18
    draw.text((title_x, title_y), title, font=title_font, fill=(230, 220, 255))

    # --- –ª–æ–≥–æ—Ç–∏–ø—ã –∫–ª–∞–Ω–æ–≤ + —Å—á—ë—Ç –º–µ–∂–¥—É –Ω–∏–º–∏ ---
    def load_logo(filename: str, size: int) -> Image.Image | None:
        path = os.path.join(icons_dir, filename)
        try:
            if os.path.exists(path):
                im = Image.open(path).convert("RGBA")
                im = im.resize((size, size), Image.LANCZOS)
                return im
        except Exception:
            return None
        return None

    logo_size = 150
    bb_logo = load_logo("logo.png", logo_size)           # –ª–æ–≥–æ—Ç–∏–ø BB
    opp_logo = load_logo("opponent.png", logo_size)

    score_text = f"{bb_score} : {opp_score}"
    score_bbox = draw.textbbox((0, 0), score_text, font=score_font)
    score_w = score_bbox[2] - score_bbox[0]
    score_h = score_bbox[3] - score_bbox[1]

    band_top = title_y + title_h + 40
    mid_x = (panel_x0 + panel_x1) // 2

    logo_margin = 60
    logo_offset = score_w / 2 + logo_margin + logo_size / 2

    logo_center_y = band_top + logo_size / 2
    logos_y = int(logo_center_y - logo_size / 2)
    score_y = int(logo_center_y - score_h / 2)

    left_center_x = int(mid_x - logo_offset)
    right_center_x = int(mid_x + logo_offset)

    # –ª–æ–≥–æ—Ç–∏–ø—ã –±–µ–∑ –ø–æ–¥–ª–æ–∂–µ–∫
    if bb_logo is not None:
        img.paste(bb_logo, (left_center_x - logo_size // 2, logos_y), bb_logo)
    if opp_logo is not None:
        img.paste(opp_logo, (right_center_x - logo_size // 2, logos_y), opp_logo)

    # —Å–∞–º —Å—á—ë—Ç
    score_x = mid_x - score_w // 2
    draw.text((score_x, score_y), score_text, font=score_font, fill=(245, 230, 255))

    # --- –ù–ò–ñ–ï –ø–æ–¥ –ª–æ–≥–æ—Ç–∏–ø–∞–º–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –ø–∏—à–µ–º (–Ω–∏ "376 –æ—á–∫–æ–≤", –Ω–∏ "–ü–æ–±–µ–¥–∞ ...") ---

    # --- –±–ª–æ–∫ MVP (—á—É—Ç—å –≤—ã—à–µ –∏ –∫—Ä—É–ø–Ω–µ–µ, –±–µ–∑ TG –Ω–∏–∫–∞) ---
    # —Ä–µ–∂–µ–º —Ç–µ–ª–µ–≥—Ä–∞–º-–Ω–∏–∫ –≤ —Ñ–æ—Ä–º–∞—Ç–µ " (@xxx)" –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏
    if mvp_name:
        mvp_clean = re.sub(r"\s*\(@[^)]*\)\s*$", "", mvp_name.strip())
    else:
        mvp_clean = "‚Äî"

    mvp_block_x = panel_x0 + 40
    # –ø–æ–¥–Ω–∏–º–µ–º MVP –≤—ã—à–µ, –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É
    mvp_block_y = panel_y1 - 190
    mvp_icon_size = 60  # –±—ã–ª–æ 48

    try:
        mvp_icon_path = os.path.join(icons_dir, "mvp.png")
        if os.path.exists(mvp_icon_path):
            mvp_icon = Image.open(mvp_icon_path).convert("RGBA")
            mvp_icon = mvp_icon.resize((mvp_icon_size, mvp_icon_size), Image.LANCZOS)
        else:
            mvp_icon = None
    except Exception:
        mvp_icon = None

    if mvp_icon is not None:
        img.paste(mvp_icon, (mvp_block_x, mvp_block_y), mvp_icon)
    else:
        draw.text(
            (mvp_block_x, mvp_block_y),
            "üëë",
            font=name_font,
            fill=(230, 220, 255),
        )

    mvp_text = f"MVP: {mvp_clean}"
    max_mvp_width = (panel_x1 - panel_x0) // 2
    if draw.textlength(mvp_text, font=name_font) > max_mvp_width:
        while len(mvp_text) > 5 and draw.textlength(mvp_text + "...", font=name_font) > max_mvp_width:
            mvp_text = mvp_text[:-1]
        mvp_text += "..."

    mvp_text_x = mvp_block_x + mvp_icon_size + 14
    mvp_text_y = mvp_block_y + 8
    draw.text(
        (mvp_text_x, mvp_text_y),
        mvp_text,
        font=name_font,   # –∫—Ä—É–ø–Ω–µ–µ, —á–µ–º small_font
        fill=(230, 220, 255),
    )

    # --- –±–ª–æ–∫ –∫–∞—Ä—Ç—ã —Å–ø—Ä–∞–≤–∞ –≤–Ω–∏–∑—É ---
    map_name = (war.get("map") or "").strip() or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–∞—Ä—Ç–∞"
    map_block_width = 420
    map_block_height = 200
    map_block_x0 = panel_x1 - map_block_width - 40
    map_block_y0 = panel_y1 - map_block_height - 40
    map_block_x1 = map_block_x0 + map_block_width
    map_block_y1 = map_block_y0 + map_block_height

    # –≤–Ω–µ—à–Ω–∏–π –±–ª–æ–∫
    map_layer = Image.new("RGBA", img.size, (0, 0, 0, 0))
    map_draw = ImageDraw.Draw(map_layer)
    try:
        map_draw.rounded_rectangle(
            (map_block_x0, map_block_y0, map_block_x1, map_block_y1),
            radius=25,
            fill=(15, 5, 45, 220),
            outline=(160, 100, 255, 255),
            width=2,
        )
    except Exception:
        map_draw.rectangle(
            (map_block_x0, map_block_y0, map_block_x1, map_block_y1),
            fill=(15, 5, 45, 220),
            outline=(160, 100, 255, 255),
            width=2,
        )
    img = Image.alpha_composite(img, map_layer)
    draw = ImageDraw.Draw(img)

    # –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ä–∞–º–∫–∞ –ø–æ–¥ –∫–∞—Ä—Ç–∏–Ω–∫—É –∫–∞—Ä—Ç—ã (–∑–∞–∫—Ä—É–≥–ª—ë–Ω–Ω—ã–µ —É–≥–ª—ã)
    inner_margin_x = 20
    inner_margin_top = 15
    text_area_height = 40  # –º–µ—Å—Ç–æ —Å–Ω–∏–∑—É –ø–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã

    inner_x0 = map_block_x0 + inner_margin_x
    inner_x1 = map_block_x1 - inner_margin_x
    inner_y0 = map_block_y0 + inner_margin_top
    inner_y1 = map_block_y1 - text_area_height

    inner_w = inner_x1 - inner_x0
    inner_h = inner_y1 - inner_y0

    lower_map = map_name.lower()
    map_logo_file = None
    map_logo_map = {
        "skorpo": "skorpo.png",
        "narva": "narva.png",
        "gorodok": "gorodok.png",
        "mutaha": "mutaha.png",
        "fallujah": "fallujah.png",
        "chora": "chora.png",
        "logar": "logar.png",
    }
    for key, filename in map_logo_map.items():
        if key in lower_map:
            map_logo_file = filename
            break

    map_logo = None
    if map_logo_file is not None:
        try:
            logo_path = os.path.join(icons_dir, map_logo_file)
            if os.path.exists(logo_path):
                map_logo = Image.open(logo_path).convert("RGBA")
        except Exception:
            map_logo = None

    if map_logo is not None:
        logo = map_logo.copy()
        logo.thumbnail((inner_w, inner_h), Image.LANCZOS)

        inner_img = Image.new("RGBA", (inner_w, inner_h), (10, 5, 35, 255))
        lx = (inner_w - logo.size[0]) // 2
        ly = (inner_h - logo.size[1]) // 2
        inner_img.paste(logo, (lx, ly), logo)

        mask = Image.new("L", (inner_w, inner_h), 0)
        mask_draw = ImageDraw.Draw(mask)
        try:
            mask_draw.rounded_rectangle(
                (0, 0, inner_w, inner_h),
                radius=20,
                fill=255,
            )
        except Exception:
            mask_draw.rectangle((0, 0, inner_w, inner_h), fill=255)

        img.paste(inner_img, (inner_x0, inner_y0), mask)

    # –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã –ø–æ —Ü–µ–Ω—Ç—Ä—É –≤–Ω–∏–∑—É –±–ª–æ–∫–∞
    max_map_text_width = map_block_width - 40
    map_line = map_name
    if draw.textlength(map_line, font=small_font) > max_map_text_width:
        while len(map_line) > 5 and draw.textlength(map_line + "...", font=small_font) > max_map_text_width:
            map_line = map_line[:-1]
        map_line += "..."

    map_text_bbox = draw.textbbox((0, 0), map_line, font=small_font)
    map_text_w = map_text_bbox[2] - map_text_bbox[0]
    map_text_h = map_text_bbox[3] - map_text_bbox[1]

    map_text_x = map_block_x0 + (map_block_width - map_text_w) // 2
    map_text_y = map_block_y1 - text_area_height + (text_area_height - map_text_h) // 2

    draw.text(
        (map_text_x, map_text_y),
        map_line,
        font=small_font,
        fill=(230, 220, 255),
    )

    # --- —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç ---
    out_dir = os.path.join(base_dir, "cw_results")
    os.makedirs(out_dir, exist_ok=True)
    war_id = war.get("id") or "x"
    filename = f"cw_{war_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.png"
    full_path = os.path.join(out_dir, filename)
    img.save(full_path, "PNG")

    return full_path
def display_name(user: dict | None, fallback_fullname: str | None = None) -> str:
    try:
        nick = (user.get("nickname") if user else None) or (fallback_fullname or "")
    except Exception:
        nick = fallback_fullname or ""
    uname = None
    try:
        tl = (user or {}).get("tg_link")
        if tl:
            tl = tl.strip()
            if tl.startswith("https://t.me/") or tl.startswith("http://t.me/") or tl.startswith("t.me/"):
                uname = tl.split("t.me/")[-1].strip("/ ")
            elif tl.startswith("@"):
                uname = tl[1:]
    except Exception:
        uname = None
    return f"{nick} (@{uname})" if uname else nick


async def CW_delete_war(war_id: int) -> bool:
    # explicit delete of registrations to avoid SQLite FK pragma surprises
    async with aiosqlite.connect(DB_PATH) as db:
        try:
            await db.execute("DELETE FROM cw_registrations WHERE war_id=?", (war_id,))
            await db.execute("DELETE FROM cw_wars WHERE id=?", (war_id,))
            await db.commit()
            return True
        except Exception:
            return False
# ======= CLAN WAR (CW) HELPERS =======
async def CW_create_war(opponents: str, starts_at_iso: str, map_: str, team_size: int, rules: str, server: str) -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "INSERT INTO cw_wars(opponents, starts_at, map, team_size, rules, server) VALUES (?,?,?,?,?,?)",
            (opponents.strip(), starts_at_iso, map_.strip(), int(team_size), rules.strip(), server.strip())
        )
        await db.commit()
        return cur.lastrowid

async def CW_get_war(war_id: int) -> Optional[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM cw_wars WHERE id=?", (war_id,))
        row = await cur.fetchone()
        if not row:
            return None
        cols = [d[0] for d in cur.description]
        return dict(zip(cols, row))

async def CW_list_active() -> list:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM cw_wars WHERE status='scheduled' ORDER BY datetime(starts_at) ASC")
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
        return [dict(zip(cols, r)) for r in rows]

async def CW_list_finished(limit: int = 20) -> list:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT * FROM cw_wars WHERE status='finished' ORDER BY datetime(starts_at) DESC LIMIT ?", (limit,))
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
        return [dict(zip(cols, r)) for r in rows]

async def CW_player_stats_for_war(war_id: int) -> list[dict]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ö–í —Å –ø–æ–¥—Ä–æ–±–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π.
    –ë–µ—Ä—ë–º –≤—Å–µ—Ö –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞ –ö–í (cw_registrations) –∏ LEFT JOIN
    –∫ –Ω–∏–º —Ç–∞–±–ª–∏—Ü—É cw_player_stats. –ï—Å–ª–∏ –ø–æ –∫–æ–º—É-—Ç–æ –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π –≤
    cw_player_stats, —Å—Ç–∞–≤–∏–º –Ω—É–ª–∏, –Ω–æ –∏–≥—Ä–æ–∫ –≤—Å—ë —Ä–∞–≤–Ω–æ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü—É.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT r.user_id,
                   COALESCE(s.revives, 0)       AS revives,
                   COALESCE(s.kills, 0)         AS kills,
                   COALESCE(s.deaths, 0)        AS deaths,
                   COALESCE(s.caps, 0)          AS caps,
                   COALESCE(s.elo_delta, 0.0)   AS elo_delta,
                   u.nickname
            FROM cw_registrations AS r
            LEFT JOIN cw_player_stats AS s
                ON s.war_id = r.war_id AND s.user_id = r.user_id
            LEFT JOIN users AS u
                ON u.user_id = r.user_id
            WHERE r.war_id = ?
            ORDER BY COALESCE(s.elo_delta, 0.0) DESC
            """,
            (war_id,),
        )
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
        return [dict(zip(cols, row)) for row in rows]

async def CW_registrations(war_id: int) -> list[int]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id FROM cw_registrations WHERE war_id=? ORDER BY created_at ASC", (war_id,))
        rows = await cur.fetchall()
        return [r[0] for r in rows]

async def CW_is_registered(war_id: int, user_id: int) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT 1 FROM cw_registrations WHERE war_id=? AND user_id=?", (war_id, user_id))
        return await cur.fetchone() is not None

async def CW_register(war_id: int, user_id: int) -> tuple[bool, str]:
    war = await CW_get_war(war_id)
    if not war or war.get("status") != "scheduled":
        return False, "–ö–í –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ."
    regs = await CW_registrations(war_id)
    if user_id in regs:
        return False, "–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã."
    if len(regs) >= int(war["team_size"]):
        return False, "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–æ–º–∞–Ω–¥—ã."
    async with aiosqlite.connect(DB_PATH) as db:
        try:
            await db.execute(
                "INSERT INTO cw_registrations(war_id, user_id, created_at) VALUES (?,?,?)",
                (war_id, user_id, datetime.utcnow().isoformat())
            )
            await db.commit()
        except Exception:
            return False, "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è."
    return True, "–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ –ö–í."

async def CW_unregister(war_id: int, user_id: int) -> None:
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM cw_registrations WHERE war_id=? AND user_id=?", (war_id, user_id))
        await db.commit()

async def CW_finish(
    war_id: int,
    winner_label: str,
    per_player_stats=None,
    bb_score: int | None = None,
    opp_score: int | None = None,
) -> bool:
    war = await CW_get_war(war_id)
    if not war or war.get("status") != "scheduled":
        return False

    regs = await CW_registrations(war_id)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE cw_wars "
            "SET winner=?, status='finished', "
            "    bb_score=COALESCE(?, bb_score), "
            "    opp_score=COALESCE(?, opp_score) "
            "WHERE id=?",
            (winner_label, bb_score, opp_score, war_id),
        )

        mvp_user_id = None
        mvp_elo_gain = None

        for uid in regs:
            before = await get_user(uid)
            old_elo = (before.get("elo_rating") if before else None) or 1000

            # --- –±–∞–∑–æ–≤—ã–π ELO ---
            if winner_label == "Blackberry":
                if old_elo < 1500:
                    base_delta = 100
                elif old_elo < 2000:
                    base_delta = 50
                else:
                    base_delta = 25
                cw_win_inc = 1
                cw_loss_inc = 0
            else:
                if old_elo >= 3000:
                    base_delta = -100
                elif old_elo >= 2000:
                    base_delta = -50
                else:
                    base_delta = -25
                cw_win_inc = 0
                cw_loss_inc = 1

            # --- —Å—Ç–∞—Ç—ã –∏–∑ per_player_stats ---
            stats_for_user = (per_player_stats or {}).get(str(uid)) or {}
            revives = int(stats_for_user.get("revives", 0) or 0)
            kills   = int(stats_for_user.get("kills", 0) or 0)
            deaths  = int(stats_for_user.get("deaths", 0) or 0)
            caps    = int(stats_for_user.get("caps", 0) or 0)

            # --- –ª–∏—á–Ω—ã–π ELO —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–æ–±–µ–¥–µ BB ---
            personal_elo = 0.0
            if winner_label == "Blackberry":
                personal_elo += revives * 0.5
                kd_diff = kills - deaths
                if kd_diff > 0:
                    personal_elo += kd_diff
                personal_elo += caps * 0.0025

            total_delta = base_delta + personal_elo

            # –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            await db.execute(
                """
                UPDATE users
                SET
                    cw_wins            = COALESCE(cw_wins, 0) + ?,
                    cw_losses          = COALESCE(cw_losses, 0) + ?,
                    cw_revives         = COALESCE(cw_revives, 0) + ?,
                    cw_kills           = COALESCE(cw_kills, 0) + ?,
                    cw_deaths          = COALESCE(cw_deaths, 0) + ?,
                    cw_capture_points  = COALESCE(cw_capture_points, 0) + ?,
                    elo_rating         = COALESCE(elo_rating, 1000) + ?
                WHERE user_id = ?
                """,
                (
                    cw_win_inc,
                    cw_loss_inc,
                    revives,
                    kills,
                    deaths,
                    caps,
                    total_delta,
                    uid,
                ),
            )

            # --- –Ω–æ–≤—ã–π ELO –∏ –ª–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–µ–π—Ç–∏–Ω–≥–∞ (–£–ñ–ï –í–ù–£–¢–†–ò –¶–ò–ö–õ–ê) ---
            cur = await db.execute(
                "SELECT COALESCE(elo_rating, 1000) FROM users WHERE user_id = ?",
                (uid,),
            )
            row = await cur.fetchone()
            new_elo = row[0] if row and row[0] is not None else 1000

            delta = new_elo - old_elo
            if delta != 0:
                await db.execute(
                    """
                    INSERT INTO rating_changes(user_id, delta, reason, created_at)
                    VALUES (?, ?, ?, ?)
                    """,
                    (
                        int(uid),
                        int(delta),
                        f"cw:{war_id}",
                        datetime.utcnow().isoformat(),
                    ),
                )

            await notify_rank_if_changed(uid, old_elo, new_elo)

            # --- –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä–æ–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ –ö–í (–¢–û–ñ–ï –í–ù–£–¢–†–ò –¶–ò–ö–õ–ê) ---
            await db.execute(
                """
                INSERT INTO cw_player_stats
                    (war_id, user_id, revives, kills, deaths, caps, elo_delta)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (war_id, uid, revives, kills, deaths, caps, total_delta),
            )

            # MVP-–∫–∞–Ω–¥–∏–¥–∞—Ç
            if winner_label == "Blackberry" and per_player_stats:
                if mvp_elo_gain is None or total_delta > mvp_elo_gain:
                    mvp_elo_gain = total_delta
                    mvp_user_id = uid

        # –ø–æ—Å–ª–µ —Ü–∏–∫–ª–∞ ‚Äî –æ–¥–∏–Ω UPDATE –ø–æ MVP
        if winner_label == "Blackberry" and mvp_user_id is not None:
            await db.execute(
                """
                UPDATE users
                SET
                    cw_mvp_count = COALESCE(cw_mvp_count, 0) + 1,
                    cw_mvp_list = CASE
                        WHEN cw_mvp_list IS NULL OR cw_mvp_list = '' THEN ?
                        ELSE cw_mvp_list || ',' || ?
                    END
                WHERE user_id = ?
                """,
                (str(war_id), str(war_id), mvp_user_id),
            )

        await db.commit()

    return True

# ======= HELPERS =======
async def is_subscribed(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(CHANNEL_USERNAME, user_id)
        return member.status in ("member", "administrator", "creator")
    except Exception as e:
        logging.exception("Failed to check subscription: %r", e)
        return False

def reviewer_ids() -> List[int]:
    return sorted(set(ADMIN_IDS) | set(MODERATOR_IDS))

async def send_application_to_all(text: str, user_id: int):
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, text, reply_markup=approve_kb(user_id))
        except Exception as e:
            logging.warning("Cannot DM reviewer %s: %r", rid, e)

async def notify_review_outcome(user_id: int, outcome: str):
    label = "‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ" if outcome == "approved" else "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ"
    for rid in reviewer_ids():
        try:
            await bot.send_message(rid, f"{label}: –∑–∞—è–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <code>{user_id}</code> —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.")
        except Exception:
            pass

async def send_to_moderation(text: str, reply_markup: Optional[InlineKeyboardMarkup] = None):
    if MODERATION_CHAT_ID:
        try:
            await bot.send_message(MODERATION_CHAT_ID, text, reply_markup=reply_markup)
        except Exception:
            pass
async def notify_staff(text: str):
    sent = False
    try:
        await send_to_moderation(text)
        sent = True
    except Exception:
        sent = False
    # –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –õ–° –≤—Å–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º
    try:
        for rid in reviewer_ids():
            try:
                await bot.send_message(rid, text)
            except Exception:
                pass
    except Exception:
        pass

async def create_invite_link() -> Optional[ChatInviteLink]:
    try:
        link = await bot.create_chat_invite_link(
            chat_id=CLAN_CHAT_ID,
            name=f"Onboarding {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            creates_join_request=False,
            expire_date=None,
            member_limit=1,
        )
        return link
    except Exception as e:
        logging.exception("Cannot create invite link: %r", e)
        return None
async def log_mod_action(actor_id: int, action: str, target_id: int | None = None, extra: str | None = None) -> None:
    """
    –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏–π –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü—É mod_actions.
    action ‚Äî –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è (–Ω–∞ —Ä—É—Å—Å–∫–æ–º).
    """
    try:
        if actor_id in ADMIN_IDS:
            role = "admin"
        elif actor_id in MODERATOR_IDS:
            role = "moderator"
        else:
            role = "user"
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO mod_actions(actor_id, actor_role, action, target_id, extra, created_at) VALUES (?,?,?,?,?,?)",
                (actor_id, role, action, target_id, (extra or ""), datetime.utcnow().isoformat()),
            )
            await db.commit()
    except Exception as e:
        logging.warning("Failed to log mod action: %r", e)

async def log_rating_change(user_id: int, delta: int, reason: str | None = None) -> None:
    """
    –õ–æ–≥–∏—Ä—É–µ–º –ª—é–±–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞ –∏–≥—Ä–æ–∫–∞ –≤ —Ç–∞–±–ª–∏—Ü—É rating_changes.
    delta ‚Äî –Ω–∞ —Å–∫–æ–ª—å–∫–æ –∏–∑–º–µ–Ω–∏–ª—Å—è —Ä–µ–π—Ç–∏–Ω–≥ (–º–æ–∂–µ—Ç –±—ã—Ç—å + –∏–ª–∏ -).
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO rating_changes(user_id, delta, reason, created_at) VALUES (?,?,?,?)",
                (int(user_id), int(delta), reason or "", datetime.utcnow().isoformat()),
            )
            await db.commit()
    except Exception as e:
        logging.warning("Failed to log rating change for %s: %r", user_id, e)



# ======= Removal checklist (manual for items 1 and 3) =======
async def ensure_removal_record(user_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id) VALUES(?) ON CONFLICT(user_id) DO NOTHING", (user_id,))
        await db.commit()

def removal_kb(user_id: int, done_db: bool, done_tg: bool, done_discord: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text=("‚úÖ 1. –ò–∑ —Ç–∞–±–ª–∏—Ü—ã –æ—Ç–º–µ—á–µ–Ω–æ" if done_db else "1. –û—Ç–º–µ—Ç–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã"), callback_data=f"remove:dbdone:{user_id}")
    kb.button(text=("‚úÖ 2. –ò–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞" if done_tg else "2. –£–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞"), callback_data=f"remove:tg:{user_id}")
    kb.row()
    kb.button(text=("‚úÖ 3. –ò–∑ Discord –æ—Ç–º–µ—á–µ–Ω–æ" if done_discord else "3. –û—Ç–º–µ—Ç–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ Discord"), callback_data=f"remove:discdone:{user_id}")
    kb.row()
    if done_db and done_tg and done_discord:
        kb.button(text="üßπ –ó–∞–≤–µ—Ä—à–∏—Ç—å ‚Äî —Å—Ç–µ—Ä–µ—Ç—å –∏–∑ –±–∞–∑—ã", callback_data=f"remove:final:{user_id}")
        kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –ø—Ä–æ—Ñ–∏–ª—é", callback_data=f"profile_back:{user_id}")
    return kb.adjust(1).as_markup()

async def removal_state(user_id: int) -> tuple[bool, bool, bool]:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT db_done, tg_done, discord_done FROM removal_checklist WHERE user_id=?", (user_id,))
        row = await cur.fetchone()
    if row:
        return bool(row[0]), bool(row[1]), bool(row[2])
    return False, False, False

def removal_text(user: Optional[dict], done_db: bool, done_tg: bool, done_discord: bool) -> str:
    title = "<b>–£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ ‚Äî —á–µ–∫-–ª–∏—Å—Ç</b>"
    if user:
        header = f"ClanID: <code>{pad_clan_id(user.get('clan_id'))}</code> | ID: <code>{user.get('user_id')}</code> | –ù–∏–∫: {user.get('nickname') or '-'}"
    else:
        header = f"ID: <code>{user}</code>"
    def mark(b): return "‚úÖ" if b else "‚òê"
    lines = [
        title,
        header,
        "",
        f"{mark(done_db)} 1) –ü—Ä–æ–≤–µ—Ä–∏—Ç—å: –∏–≥—Ä–æ–∫ —É–¥–∞–ª—ë–Ω –∏–∑ —Ç–∞–±–ª–∏—Ü—ã –ë–î (–æ—Ç–º–µ—á–∞–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é –∫–Ω–æ–ø–∫–æ–π ¬´–í—ã–ø–æ–ª–Ω–µ–Ω–æ (—Ç–∞–±–ª–∏—Ü–∞)¬ª).",
        f"{mark(done_tg)} 2) –£–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞ Telegram (–≤—ã–ø–æ–ª–Ω—è–µ—Ç –±–æ—Ç –ø–æ –∫–Ω–æ–ø–∫–µ).",
        f"{mark(done_discord)} 3) –ü—Ä–æ–≤–µ—Ä–∏—Ç—å: –∏–≥—Ä–æ–∫ —É–¥–∞–ª—ë–Ω –∏–∑ Discord (–æ—Ç–º–µ—á–∞–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é –∫–Ω–æ–ø–∫–æ–π ¬´–í—ã–ø–æ–ª–Ω–µ–Ω–æ (Discord)¬ª).",
    ]
    return "\n".join(lines)


def _not_empty(v):
    return bool(v and str(v).strip())

async def is_profile_complete(user_id: int) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT nickname, discord, steamid, birth_date, timezone, tg_link FROM users WHERE user_id=?",
            (user_id,)
        )
        row = await cur.fetchone()
    if not row:
        return False
    nickname, discord, steamid, birth_date, timezone, tg_link = row
    return all([_not_empty(nickname), _not_empty(discord), _not_empty(steamid),
                _not_empty(birth_date), _not_empty(timezone), _not_empty(tg_link)])

# ======= HANDLERS =======
@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    user = await get_user(message.from_user.id)
    if user and user.get("status") in (Status.APPROVED, Status.JOINED):
        await message.answer("–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /profile, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–∞–Ω–Ω—ã–µ.")
        return

    await upsert_user(
        message.from_user.id,
        status=Status.NEW.value,
        created_at=datetime.utcnow().isoformat(),
    )
    await ensure_clan_ids()
    await ensure_joined_if_member(message.from_user.id)
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –∫–ª–∞–Ω–∞ Blackberry. –î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
        reply_markup=phone_kb(),
    )
    await state.set_state(RegStates.waiting_phone)

@dp.message(RegStates.waiting_phone, F.contact)
async def got_phone(message: Message, state: FSMContext):
    phone = message.contact.phone_number
    await state.update_data(phone=phone)
    await message.answer("–û—Ç–ª–∏—á–Ω–æ! –í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫(—Ä–µ–∞–ª—å–Ω–æ–µ –∏–º—è): –ü—Ä–∏–º–µ—Ä: Keech(–ê–ª–µ–∫—Å–∞–Ω–¥—Ä)", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_nickname)

@dp.message(RegStates.waiting_phone)
async def need_phone(message: Message):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞.", reply_markup=phone_kb())

@dp.message(RegStates.waiting_nickname)
async def got_nick(message: Message, state: FSMContext):
    await state.update_data(nickname=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ Discord:")
    await state.set_state(RegStates.waiting_discord)

@dp.message(RegStates.waiting_discord)
async def got_discord(message: Message, state: FSMContext):
    await state.update_data(discord=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ SteamID:(–í–∫–ª–∞–¥–∫–∞ –û–± –∞–∫–∫–∞—É–Ω—Ç–µ)")
    await state.set_state(RegStates.waiting_steam)

@dp.message(RegStates.waiting_steam)
async def got_steam(message: Message, state: FSMContext):
    steam = (message.text or "").strip()
    if not (steam.isdigit() and len(steam) == 17):
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π SteamID. –£–∫–∞–∂–∏—Ç–µ —Ä–æ–≤–Ω–æ 17 —Ü–∏—Ñ—Ä, –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –¥—Ä—É–≥–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤.")
        # –æ—Å—Ç–∞—ë–º—Å—è –Ω–∞ —Ç–æ–º –∂–µ —à–∞–≥–µ
        await state.set_state(RegStates.waiting_steam)
        return
    await state.update_data(steamid=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è (–≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì):")
    await state.set_state(RegStates.waiting_birthdate)

@dp.message(RegStates.waiting_birthdate)
async def got_birthdate(message: Message, state: FSMContext):
    text = message.text.strip()
    try:
        birth_date = datetime.strptime(text, "%d.%m.%Y").date()
        if birth_date > date.today():
            raise ValueError("future")
    except Exception:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –∫–∞–∫ –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 15.08.1995).")
        return

    today = date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))

    await state.update_data(birth_date=birth_date.isoformat(), age=age)
    await message.answer(f"‚úÖ –ü—Ä–∏–Ω—è—Ç–æ. –í–∞—à –≤–æ–∑—Ä–∞—Å—Ç: {age}.\n–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å:", reply_markup=tz_choice_kb())
    await state.set_state(RegStates.waiting_tz)

def tz_choice_kb() -> ReplyKeyboardMarkup:
    # –ö–Ω–æ–ø–∫–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ, –æ—Ç MSK-3 –¥–æ MSK+7
    rows = [[KeyboardButton(text=label)] for label in ["MSK-3","MSK-2","MSK-1","MSK","MSK+1","MSK+2","MSK+3","MSK+4","MSK+5","MSK+6","MSK+7"]]
    return ReplyKeyboardMarkup(
        keyboard=rows,
        resize_keyboard=True,
        one_time_keyboard=True,
        input_field_placeholder="–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å"
    )

@dp.message(RegStates.waiting_tz)
async def got_tz(message: Message, state: FSMContext):
    choice = (message.text or "").strip()
    allowed = ["MSK-3","MSK-2","MSK-1","MSK","MSK+1","MSK+2","MSK+3","MSK+4","MSK+5","MSK+6","MSK+7"]
    if choice not in allowed:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ.", reply_markup=tz_choice_kb())
        return
    await state.update_data(timezone=choice)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∞—à –ª–∏—á–Ω—ã–π Telegram (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://t.me/username –∏–ª–∏ @username):", reply_markup=ReplyKeyboardRemove())
    await state.set_state(RegStates.waiting_tg_link)

@dp.message(RegStates.waiting_tg_link)

@dp.message(RegStates.waiting_tg_link)
async def got_tg_link(message: Message, state: FSMContext):
    data = await state.update_data(tg_link=message.text.strip())
    data = await state.get_data()

    await upsert_user(
        message.from_user.id,
        phone=data.get("phone"),
        nickname=data.get("nickname"),
        discord=data.get("discord"),
        steamid=data.get("steamid"),
        age=data.get("age"),
        birth_date=data.get("birth_date"),
        timezone=data.get("timezone"),
        tg_link=data.get("tg_link"),
        status=Status.PENDING_CHANNEL.value,
    )
    await ensure_clan_ids()

    preview = (
        f"<b>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ</b>\n"
        f"–ù–∏–∫: {data.get('nickname')}\n"
        f"Discord: {data.get('discord')}\n"
        f"SteamID: {data.get('steamid')}\n"
        f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {data.get('birth_date')}\n"
        f"–í–æ–∑—Ä–∞—Å—Ç (–ø–æ –¥–∞—Ç–µ): {data.get('age')}\n"
        f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {data.get('timezone')}\n"
        f"–õ–∏—á–Ω—ã–π TG: {data.get('tg_link')}\n\n"
        f"–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π: {CHANNEL_USERNAME}"
    )

    await message.answer(preview)
    await message.answer(
        "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
        reply_markup=subscription_check_kb(),
    )
    await state.clear()

# Subscription
@dp.callback_query(F.data == "check_sub")
async def on_check_sub(call: CallbackQuery):
    uid = call.from_user.id
    if await is_subscribed(uid):
        await upsert_user(uid, status=Status.PENDING_REVIEW.value)
        await call.message.edit_text(
            "–ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞—è–≤–∫—É –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ.",
            reply_markup=apply_kb(),
        )
    else:
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @SquadBlackBerry", show_alert=True)

# Send application to ALL reviewers in DMs
@dp.callback_query(F.data == "send_apply")
async def on_send_apply(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not user or user.get("status") != Status.PENDING_REVIEW.value:
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É.", show_alert=True)
        return

    await upsert_user(uid, applied_at=datetime.utcnow().isoformat())
    user = await get_user(uid)
    clan_id = pad_clan_id(user.get("clan_id"))

    text = (
        f"<b>–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –≤ –∫–ª–∞–Ω</b>\n"
        f"ClanID: <code>{clan_id}</code>\n"
        f"Telegram ID: <code>{uid}</code>\n"
        f"–ù–∏–∫: {user.get('nickname')}\n"
        f"Discord: {user.get('discord')}\n"
        f"SteamID: {user.get('steamid')}\n"
        f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {user.get('birth_date') or '-'}\n"
        f"–í–æ–∑—Ä–∞—Å—Ç: {user.get('age') or '-'}\n"
        f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {user.get('timezone')}\n"
        f"–õ–∏—á–Ω—ã–π TG: {user.get('tg_link')}\n"
        f"–§—Ä–∞–∫—Ü–∏—è: {user.get('faction') or '‚Äî (–≤—ã–±–µ—Ä–∏—Ç–µ –≤ –ø—Ä–æ—Ñ–∏–ª–µ –∏–≥—Ä–æ–∫–∞)'}\n"
    )
    await send_application_to_all(text, uid)
    await call.message.edit_text("–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –û–∂–∏–¥–∞–π—Ç–µ —Ä–µ—à–µ–Ω–∏—è.")

# ======= Moderation/Profile flow =======
@dp.message(Command("player"))
async def cmd_player(message: Message, command: Command):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /player <user_id | @username | —á–∞—Å—Ç—å –Ω–∏–∫–∞>")
        return
    query = args[1].strip()

    target_user: Optional[dict] = None
    if query.isdigit():
        target_user = await get_user(int(query))
    if not target_user and query.startswith("@"):
        target_user = await get_user_by_username(query)
    if not target_user:
        matches = await search_users_by_nickname(query, limit=10)
        if len(matches) == 1:
            target_user = matches[0]
        elif len(matches) > 1:
            lines = ["–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:"]
            for u in matches:
                lines.append(f"‚Ä¢ {u.get('nickname') or '-'} ‚Äî ClanID: {pad_clan_id(u.get('clan_id'))} ‚Äî ID: <code>{u['user_id']}</code> ‚Äî —Ñ—Ä–∞–∫—Ü–∏—è: {u.get('faction') or '-'}")
            lines.append("\n–£—Ç–æ—á–Ω–∏—Ç–µ: /player <ID>")
            await message.answer("\n".join(lines))
            return

    if not target_user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ –∏ –ø–æ–∑–∏—Ü–∏—è –ø–æ Elo
    user_id_int = int(target_user.get("user_id"))
    history = await get_tournament_history(user_id_int)
    pos = await get_player_position(user_id_int)

    # –ö–∞—Ä—Ç–∏–Ω–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è (—Ç–∞ –∂–µ –ª–æ–≥–∏–∫–∞, —á—Ç–æ –∏ –≤ /profile)
    image_path = generate_profile_card_image(target_user, history=history, pos=pos)

    elo = target_user.get("elo_rating") or 1000
    rank_name, _ = get_rank(elo)

    caption_lines = [
        "<b>–ü—Ä–æ—Ñ–∏–ª—å –∏–≥—Ä–æ–∫–∞</b>",
        f"üèÖ Elo: <code>{elo} BBP</code>",
        f"üéñ –†–∞–Ω–≥: <b>{rank_name}</b>",
    ]
    if pos:
        caption_lines.append(f"üìä –ú–µ—Å—Ç–æ –≤ –∫–ª–∞–Ω–µ: <b>#{pos}</b>")

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ –ø–æ–¥ –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± Elo
    if history:
        caption_lines.append("")
        caption_lines.append("<b>üèÜ –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤</b>")
        for created_at, entry_text in history:
            # created_at –º–æ–∂–µ—Ç –±—ã—Ç—å datetime –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π
            if isinstance(created_at, str):
                date_str = created_at.split("T")[0]
            else:
                date_str = str(created_at)[:10]
            caption_lines.append(f"- [{date_str}] {entry_text}")

    # –°–Ω–∞—á–∞–ª–∞ —à–ª—ë–º –∫–∞—Ä—Ç–∏–Ω–∫—É –ø—Ä–æ—Ñ–∏–ª—è
    await message.answer_photo(
        photo=FSInputFile(image_path),
        caption="\n".join(caption_lines),
    )

    # –ó–∞—Ç–µ–º ‚Äî —Ç–µ–∫—Å—Ç–æ–≤—É—é –∞–¥–º–∏–Ω-–∫–∞—Ä—Ç–æ—á–∫—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ (–∫–∞–∫ –∏ –±—ã–ª–æ)
    await message.answer(
        format_profile(target_user, history=history),
        reply_markup=profile_admin_kb(target_user["user_id"], actor_id=message.from_user.id),
    )

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ –∏ –ø–æ–∑–∏—Ü–∏—è –ø–æ Elo
    history = await get_tournament_history(int(target_user.get("user_id")))
    pos = await get_player_position(int(target_user.get("user_id")))

    # –ö–∞—Ä—Ç–∏–Ω–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è (—Ç–∞ –∂–µ, —á—Ç–æ –∏ –≤ /profile)
    image_path = generate_profile_card_image(target_user, history=history, pos=pos)

    elo = target_user.get("elo_rating") or 1000
    rank_name, _ = get_rank(elo)
    caption_lines = [
        "<b>–ü—Ä–æ—Ñ–∏–ª—å –∏–≥—Ä–æ–∫–∞</b>",
        f"üèÖ Elo: <code>{elo} BBP</code>",
        f"üéñ –†–∞–Ω–≥: <b>{rank_name}</b>",
    ]
    if pos:
        caption_lines.append(f"üìä –ú–µ—Å—Ç–æ –≤ –∫–ª–∞–Ω–µ: <b>#{pos}</b>")

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ –ø–æ–¥ –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –±–ª–æ–∫–∞ Elo
    if history:
        caption_lines.append("")
        caption_lines.append("<b>üèÜ –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤</b>")
        for created_at, entry_text in history:
            date_str = created_at.split("T")[0] if isinstance(created_at, str) else str(created_at)[:10]
            caption_lines.append(f"- [{date_str}] {entry_text}")

    await message.answer_photo(
        photo=FSInputFile(image_path),
        caption="\n".join(caption_lines),
    )

    # –¢–µ–∫—Å—Ç–æ–≤–∞—è –∞–¥–º–∏–Ω-–∫–∞—Ä—Ç–æ—á–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –∫–∞–∫ –±—ã–ª–∞
    await message.answer(
        format_profile(target_user, history=history),
        reply_markup=profile_admin_kb(target_user["user_id"], actor_id=message.from_user.id),
    )

@dp.callback_query(F.data.startswith("career:user:"))
async def on_career_user(call: CallbackQuery):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–µ—Ä–µ–≤–æ —Ä–æ–ª–µ–π –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤/–∞–¥–º–∏–Ω–æ–≤.
    –ö–Ω–æ–ø–∫–∞ ¬´–ö–∞—Ä—å–µ—Ä–∞ –∏–≥—Ä–æ–∫–∞¬ª –≤ –∞–¥–º–∏–Ω—Å–∫–æ–π –∫–∞—Ä—Ç–æ—á–∫–µ.
    """
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    try:
        _, _, uid_str = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return

    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    opened = set(await get_user_roles(target_id))
    current_role = user.get("current_role")
    image_path = generate_role_tree_image(
        user_id=target_id,
        opened_roles=opened,
        current_role=current_role,
    )

    caption = f"üå≥ –ö–∞—Ä—å–µ—Ä–∞ –∏–≥—Ä–æ–∫–∞ {display_name(user)}.\n–ó–µ–ª—ë–Ω—ã–º –≤—ã–¥–µ–ª–µ–Ω—ã —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –±–ª–æ–∫–∏."
    await call.message.answer_photo(
        photo=FSInputFile(image_path),
        caption=caption,
    )
    await call.answer()

@dp.callback_query(F.data.startswith("profile_refresh:"))
async def on_profile_refresh(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id))
    except Exception:
        pass
    await call.answer("–ü—Ä–æ—Ñ–∏–ª—å –æ–±–Ω–æ–≤–ª—ë–Ω.")

@dp.callback_query(F.data.startswith("profile_choosefac:"))
async def on_profile_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    text = format_profile(user, title="–í—ã–±–æ—Ä —Ñ—Ä–∞–∫—Ü–∏–∏")
    try:
        await call.message.edit_text(text + "\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ñ—Ä–∞–∫—Ü–∏—é:", reply_markup=faction_choose_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("elo:edit:"))
async def on_elo_edit(call: CallbackQuery, state: FSMContext):
    # –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã
    if call.from_user.id not in ADMIN_IDS:
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    try:
        _, _, uid_str = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return

    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    current_elo = (user.get("elo_rating") if user.get("elo_rating") is not None else 1000)
    await state.update_data(
        elo_edit_user_id=target_id,
        elo_edit_panel_chat_id=call.message.chat.id,
        elo_edit_panel_msg_id=call.message.message_id,
    )
    await call.message.answer(
        f"–¢–µ–∫—É—â–∏–π —Ä–µ–π—Ç–∏–Ω–≥ –∏–≥—Ä–æ–∫–∞: {current_elo}.\n"
        f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ä–µ–π—Ç–∏–Ω–≥ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ)."
    )
    await state.set_state(EloEditState.waiting_new_elo)
    await call.answer()

@dp.callback_query(F.data.startswith("profile_back:"))
async def on_profile_back(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    try:
        await call.message.edit_text(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("facset:"))
async def on_profile_set_faction(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, uid_str, code = call.data.split(":")
        target_id = int(uid_str)
        title = {"hq":"–®—Ç–∞–±","blackhole":"Black Hole","armless":"Armless","brainless":"Brainless",
                 "burning":"Burning Assholes","freshmeat":"Fresh Meat","useless":"Useless cans","reserve":"–†–µ–∑–µ—Ä–≤"}.get(code)
        if not title:
            raise ValueError("unknown faction code")
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return
    # –ï—Å–ª–∏ –Ω–µ —Ä–µ–∑–µ—Ä–≤ ‚Äî –∫–∞–∫ —Ä–∞–Ω—å—à–µ
    if code != "reserve":
        await upsert_user(target_id, faction=title)
        await send_faction_notice(target_id, title)
        user = await get_user(target_id)
        try:
            await call.message.edit_text(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id))
        except Exception:
            pass
        await call.answer(f"–§—Ä–∞–∫—Ü–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {title}")
        return
    # –î–ª—è —Ä–µ–∑–µ—Ä–≤–∞ ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–∞—Ç—É
    await state.update_data(reserve_user_id=target_id,
                            panel_chat_id=call.message.chat.id,
                            panel_msg_id=call.message.message_id)
    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É, –¥–æ –∫–æ—Ç–æ—Ä–æ–π –∏–≥—Ä–æ–∫ –±—É–¥–µ—Ç –≤ —Ä–µ–∑–µ—Ä–≤–µ, –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 25.12.2025):")
    await state.set_state(ReserveUntilState.waiting_date)
    await call.answer()


@dp.callback_query(F.data.startswith("edit:init:"))
async def on_edit_init(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return
    text = format_profile(user, title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è")
    try:
        await call.message.edit_text(text + "\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=edit_menu_kb(target_id))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("edit:rank:"))
async def on_edit_rank(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, _, uid_str = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return

    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    text = format_profile(user, title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–≤–∞–Ω–∏—è")
    try:
        await call.message.edit_text(
            text + "\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∑–≤–∞–Ω–∏–µ:",
            reply_markup=rank_choose_kb(target_id),
        )
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("edit:roles:"))
async def on_edit_roles(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, _, uid_str = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return

    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    opened_list = await get_user_roles(target_id)
    opened = set(opened_list)
    current_role = user.get("current_role")

    text = format_profile(user, title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–ª–µ–π")
    try:
        await call.message.edit_text(
            text + "\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å (–æ—Ç–∫—Ä—ã—Ç–æ/–Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ):",
            reply_markup=roles_choose_kb(target_id, opened, current_role),
        )
    except Exception:
        # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –Ω–µ –ø–∞–¥–∞–µ–º
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("role:set:"))
async def on_role_set(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    try:
        _, _, uid_str, role_code = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)
        return

    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    current_role = user.get("current_role") or "recruit"

      # –†–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã: —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∏ –¥–æ—á–µ—Ä–Ω–∏–π —Å–ª–æ–π
    allowed = set(ROLE_GRAPH.get(current_role, []))          # –¥–µ—Ç–∏
    allowed.update(ROLE_PARENTS.get(current_role, []))       # —Ä–æ–¥–∏—Ç–µ–ª–∏
    allowed.add(current_role)                                # —Ç–µ–∫—É—â–∞—è (—Ä–∞–∑—Ä–µ—à–∞–µ–º –ø–æ–≤—Ç–æ—Ä)

    if role_code not in allowed:
        await call.answer("–ü–µ—Ä–µ—Ö–æ–¥ –∑–∞–ø—Ä–µ—â—ë–Ω –±–ª–æ–∫-—Å—Ö–µ–º–æ–π.", show_alert=True)
        return

    # –°–ø–µ—Ü–ª–æ–≥–∏–∫–∞: –º—É–ª—å—Ç–∏–∫–ª–∞—Å—Å –ª—ë–≥–∫–∏—Ö —Å–ø–µ—Ü–æ–≤ ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç—ã 3 –±–∞–∑–æ–≤—ã—Ö –∫–ª–∞—Å—Å–∞
    if role_code == "light_multiclass":
        opened_now = set(await get_user_roles(target_id))
        required_light = {"light_mg", "light_gp", "light_marksman"}
        if not required_light.issubset(opened_now):
            await call.answer(
                "–ú—É–ª—å—Ç–∏–∫–ª–∞—Å—Å –ª—ë–≥–∫–∏—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤ –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ä–æ–ª—è—Ö:\n"
                "–õ—ë–≥–∫–∏–π –ø—É–ª–µ–º–µ—Ç, –ì–ü –∏ –ú–∞—Ä–∫—Å–º–∞–Ω.",
                show_alert=True,
            )
            return

    # –°–ø–µ—Ü–ª–æ–≥–∏–∫–∞: –º—É–ª—å—Ç–∏–∫–ª–∞—Å—Å —Ç—è–∂—ë–ª—ã—Ö —Å–ø–µ—Ü–æ–≤ ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã—Ç—ã 4 –±–∞–∑–æ–≤—ã—Ö –∫–ª–∞—Å—Å–∞
    if role_code == "heavy_multiclass":
        opened_now = set(await get_user_roles(target_id))
        required_heavy = {"heavy_mg", "heavy_sapper", "heavy_tandem", "heavy_sniper"}
        if not required_heavy.issubset(opened_now):
            await call.answer(
                "–ú—É–ª—å—Ç–∏–∫–ª–∞—Å—Å —Ç—è–∂—ë–ª—ã—Ö —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–æ–≤ –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ä–æ–ª—è—Ö:\n"
                "–¢—è–∂—ë–ª—ã–π –ø—É–ª–µ–º–µ—Ç, –°–∞–ø–µ—Ä, –¢–∞–Ω–¥–µ–º –∏ –°–Ω–∞–π–ø–µ—Ä.",
                show_alert=True,
            )
            return

    # –°–ø–µ—Ü–ª–æ–≥–∏–∫–∞ –¥–ª—è –∫–Ω–æ–ø–æ–∫-–ø–µ—Ä–µ–≤–æ–¥–æ–≤ (–ø–µ—Ö–æ—Ç–∞ / —Ç–µ—Ö–Ω–∏–∫–∞ / —Å–ø–µ—Ü—ã / –º–µ–¥–∏–∫–∏)
    transfer_target = await get_transfer_target(target_id, role_code)
    if transfer_target:
        role_code = transfer_target

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–æ–ª—å
    await set_user_current_role(target_id, role_code)
    opened = set(await get_user_roles(target_id))

    # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é
    try:
        updated_user = await get_user(target_id)
        await call.message.edit_text(
            format_profile(updated_user, title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–ª–µ–π"),
            reply_markup=roles_choose_kb(target_id, opened, role_code),
        )
    except Exception:
        pass

    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    try:
        await bot.send_message(
            target_id,
            f"üéñ –í–∞—à–∞ —Ä–æ–ª—å –∏–∑–º–µ–Ω–µ–Ω–∞: <b>{get_role_title(role_code)}</b>",
        )
    except Exception:
        pass

    await call.answer("–†–æ–ª—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")

@dp.callback_query(F.data.startswith("rank:set:"))
async def on_rank_set(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, _, uid_str, idx_str = call.data.split(":")
        target_id = int(uid_str)
        idx = int(idx_str)
        if idx < 0 or idx >= len(CLAN_TITLES):
            raise ValueError("bad idx")
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return

    title = CLAN_TITLES[idx]

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–≤–∞–Ω–∏–µ –≤ –ë–î
    await upsert_user(target_id, clan_title=title)
    user = await get_user(target_id)

    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫—É –æ –Ω–æ–≤–æ–º –∑–≤–∞–Ω–∏–∏
    try:
        await bot.send_message(
            target_id,
            f'üí•–¢–≤–æ–µ –∑–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–æ. –¢–µ–ø–µ—Ä—å —Ç—ã <b>{title}</b>!',
        )
    except Exception:
        pass

    # –õ–æ–≥ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—Å–∫–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è
    try:
        await log_mod_action(
            actor_id=call.from_user.id,
            action="–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∑–≤–∞–Ω–∏—è",
            target_id=target_id,
            extra=f"–ù–æ–≤–æ–µ –∑–≤–∞–Ω–∏–µ: {title}",
        )
    except Exception:
        pass

    # –û–±–Ω–æ–≤–ª—è–µ–º –∞–¥–º–∏–Ω—Å–∫—É—é –∫–∞—Ä—Ç–æ—á–∫—É –ø—Ä–æ—Ñ–∏–ª—è
    if user:
        try:
            await call.message.edit_text(
                format_profile(
                    user,
                    history=await get_tournament_history(int(user.get("user_id"))),
                ),
                reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id),
            )
        except Exception:
            try:
                await call.message.answer(
                    format_profile(
                        user,
                        history=await get_tournament_history(int(user.get("user_id"))),
                    ),
                    reply_markup=profile_admin_kb(target_id, actor_id=call.from_user.id),
                )
            except Exception:
                pass

    await call.answer(f"–ó–≤–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {title}")

@dp.callback_query(F.data.startswith("edit:field:"))
async def on_edit_field(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str, field = call.data.split(":")
    target_id = int(uid_str)
    allowed = {"nickname","discord","steamid","birth_date","timezone","tg_link"}
    if field not in allowed:
        await call.answer("–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –ø–æ–ª–µ.", show_alert=True)
        return
    prompts = {
        "nickname": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –Ω–∏–∫ (—Ä–µ–∞–ª—å–Ω–æ–µ –∏–º—è):",
        "discord": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π Discord:",
        "steamid": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π SteamID:",
        "birth_date": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì:",
        "timezone": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å (–Ω–∞–ø—Ä–∏–º–µ—Ä, GMT+3 –∏–ª–∏ Europe/Moscow):",
        "tg_link": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∞—à Telegram (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://t.me/username):",
    }
    await state.update_data(edit_user_id=target_id, edit_field=field, edit_message_id=call.message.message_id, chat_id=call.message.chat.id)
    await call.message.answer(prompts[field])
    await state.set_state(AdminEdit.waiting_value)
    await call.answer()

@dp.message(AdminEdit.waiting_value)
async def on_edit_value(message: Message, state: FSMContext):
    data = await state.get_data()
    target_id = data.get("edit_user_id")
    field = data.get("edit_field")
    if not target_id or not field:
        await message.answer("–°–µ—Å—Å–∏—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å —Å–Ω–æ–≤–∞.")
        await state.clear()
        return
    value = (message.text or "").strip()
    updates = {}
    if field == "birth_date":
        from datetime import datetime, date as _date
        try:
            bdate = datetime.strptime(value, "%d.%m.%Y").date()
            if bdate > _date.today():
                raise ValueError("future")
        except Exception:
            await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∫–∞–∫ –î–î.–ú–ú.–ì–ì–ì–ì.")
            return
        today = _date.today()
        age = today.year - bdate.year - ((today.month, today.day) < (bdate.month, bdate.day))
        updates["birth_date"] = bdate.isoformat()
        updates["age"] = age
    else:
        updates[field] = value

    await upsert_user(target_id, **updates)
    user = await get_user(target_id)
    await message.answer("‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–æ.")
    try:
        await bot.edit_message_text(
            chat_id=data.get("chat_id"),
            message_id=data.get("edit_message_id"),
            text=format_profile(user, history=await get_tournament_history(int(user.get("user_id")))),
            reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id)
        )
    except Exception:
        await message.answer(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id))

    # Log change
    try:
        who = message.from_user.full_name
        field_ru = {
            "nickname": "–ù–∏–∫",
            "discord": "Discord",
            "steamid": "SteamID",
            "birth_date": "–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è",
            "timezone": "–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å",
            "tg_link": "–õ–∏—á–Ω—ã–π TG",
        }.get(field, field)
        log_text = (f"‚úèÔ∏è <b>–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è</b>\n"
                    f"–ö–µ–º: {who} (ID: <code>{message.from_user.id}</code>)\n"
                    f"–ò–≥—Ä–æ–∫ ID: <code>{target_id}</code>\n"
                    f"–ü–æ–ª–µ: {field_ru} ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–æ.")
        await send_to_moderation(log_text)
        await log_mod_action(message.from_user.id, "–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –∏–≥—Ä–æ–∫–∞", target_id=target_id, extra=field_ru)
    except Exception:
        pass

    await state.clear()

# ======= Removal flow (manual items 1 & 3) =======
@dp.callback_query(F.data.startswith("remove:init:"))
async def on_remove_init(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    await ensure_removal_record(target_id)
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:dbdone:"))
async def on_remove_dbdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, db_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET db_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("–û—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ (—Ç–∞–±–ª–∏—Ü–∞).")

@dp.callback_query(F.data.startswith("remove:tg:"))
async def on_remove_tg(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    try:
        await bot.ban_chat_member(CLAN_CHAT_ID, target_id)
        await bot.unban_chat_member(CLAN_CHAT_ID, target_id)
        ok = True
    except Exception as e:
        logging.warning("Failed to remove from chat: %r", e)
        ok = False
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, tg_done) VALUES(?,?) ON CONFLICT(user_id) DO UPDATE SET tg_done=?", (target_id, 1 if ok else 0, 1 if ok else 0))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("–£–¥–∞–ª—ë–Ω –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞." if ok else "–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∏–∑ –∫–ª–∞–Ω-—á–∞—Ç–∞.")

@dp.callback_query(F.data.startswith("remove:discdone:"))
async def on_remove_discdone(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("INSERT INTO removal_checklist(user_id, discord_done) VALUES(?,1) ON CONFLICT(user_id) DO UPDATE SET discord_done=1", (target_id,))
        await db.commit()
    user = await get_user(target_id)
    done_db, done_tg, done_disc = await removal_state(target_id)
    text = removal_text(user, done_db, done_tg, done_disc)
    try:
        await call.message.edit_text(text, reply_markup=removal_kb(target_id, done_db, done_tg, done_disc))
    except Exception:
        pass
    await call.answer("–û—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ (Discord).")

# ======= Approve/Reject (DM) =======
@dp.callback_query(F.data.startswith("approve:"))
async def on_approve(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ–¥–æ–±—Ä—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω–∞ —Ä–∞–Ω–µ–µ.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ —Ä–∞–Ω–µ–µ.", show_alert=True)
        return

    faction = user.get("faction") or "Fresh Meat"
    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat(), faction=faction)
    await set_user_current_role(target_id, "recruit")  # ‚Üê –ù–û–í–ê–Ø –°–¢–†–û–ö–ê
    await ensure_joined_if_member(target_id)

    link = await create_invite_link()
    if not link:
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞ –≤ —á–∞—Ç–µ –∫–ª–∞–Ω–∞.", show_alert=True)
        return

    await bot.send_message(
        target_id,
        f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞!\n–§—Ä–∞–∫—Ü–∏—è: {faction}\n–°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ —á–∞—Ç –∫–ª–∞–Ω–∞: {link.invite_link}",
    )

    try:
        await call.message.edit_text(call.message.text + "\n\n‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ")
    except Exception:
        pass
    await call.answer("–û–¥–æ–±—Ä–µ–Ω–æ ‚úÖ")
    await notify_review_outcome(target_id, "approved")
    await log_mod_action(call.from_user.id, "–û–¥–æ–±—Ä–µ–Ω–∞ –∑–∞—è–≤–∫–∞", target_id=target_id)
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ç—ç–≥—É –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º —Å–µ—Ä–≤–µ—Ä–∞–º
    await bot.send_message(
        target_id,
        "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–≥ –≤ –∏–≥—Ä–µ: [BBr]\n"
        "–ü–æ –≤–æ–ø—Ä–æ—Å–∞–º –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ —Å–≤–æ–µ–º—É –∫–æ–º–∞–Ω–¥–∏—Ä—É: Gocha(@bagman7)\n\n"
        "–ù–∞–∑–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –ø–∞—Ä–æ–ª–∏ –æ—Ç –Ω–∏—Ö\n"
        "Blackberry | Training - Blackberries #1 0106\n"
        "Blackberry | Training- Strawberries #2 7848\n"
        "Blackberry | Training- Blueberries #3 9723\n"
        "Blackberry | Training- Cranberries #4 8831\n\n"
        "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è:\n"
        "–ò–ù–§–û Blackberry: https://t.me/+sL9VacfwkxYyYmUy\n"
        "–î–Ω–µ–≤–Ω–∏–∫ Blackberry: https://t.me/+QZJOj-3aiXowYjEy\n"
    )

@dp.callback_query(F.data.startswith("reject:"))
async def on_reject(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –º–æ–≥—É—Ç –æ—Ç–∫–ª–æ–Ω—è—Ç—å –∑–∞—è–≤–∫–∏.", show_alert=True)
        return

    target_id = int(call.data.split(":")[1])
    user = await get_user(target_id)
    if not user:
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    if user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
        await call.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω/–≤—Å—Ç—É–ø–∏–ª.", show_alert=True)
        return
    if user.get("status") == Status.REJECTED.value:
        await call.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ —Ä–∞–Ω–µ–µ.", show_alert=True)
        return

    await upsert_user(target_id, status=Status.REJECTED.value)
    await bot.send_message(target_id, "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ.")

    try:
        await call.message.edit_text(call.message.text + "\n\n‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ")
    except Exception:
        pass
    await call.answer("–û—Ç–∫–ª–æ–Ω–µ–Ω–æ ‚ùå")
    await notify_review_outcome(target_id, "rejected")
    await log_mod_action(call.from_user.id, "–û—Ç–∫–ª–æ–Ω–µ–Ω–∞ –∑–∞—è–≤–∫–∞", target_id=target_id)

# ======= Profile & Join Announce =======
@dp.message(or_f(F.text == "/profile", F.text == "profile"))
async def cmd_profile(message: Message):
    user = await get_user(message.from_user.id)
    if not user:
        await message.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start")
        return

    import asyncio  # –æ—Å—Ç–∞–≤–ª—è–µ–º, –∫–∞–∫ –∏ –±—ã–ª–æ, —á—Ç–æ–±—ã –Ω–µ –≤—ã–∫–∏–¥—ã–≤–∞—Ç—å –ª–∏—à–Ω–∏–π –∫–æ–¥

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ –∏ –ø–æ–∑–∏—Ü–∏—è –ø–æ Elo
    history = await get_tournament_history(message.from_user.id)
    pos = await get_player_position(user.get("user_id"))

   # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –ø—Ä–æ—Ñ–∏–ª—è
    image_path = generate_profile_card_image(user, history=history, pos=pos)

    # –ü–æ–¥–ø–∏—Å—å –ø–æ–¥ –∫–∞—Ä—Ç–∏–Ω–∫–æ–π ‚Äî –∫–æ—Ä–æ—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ + –∏—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤
    elo = user.get("elo_rating") or 1000
    elo_int = int(elo)
    rank_name, _ = get_rank(elo)
    caption_lines = [
        "<b>–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å</b>",
        f"üèÖ Elo: <code>{elo_int} BBP</code>",
        f"üéñ –†–∞–Ω–≥: <b>{rank_name}</b>",
    ]
    if pos:
        caption_lines.append(f"üìä –ú–µ—Å—Ç–æ –≤ –∫–ª–∞–Ω–µ: <b>#{pos}</b>")

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ —Å—Ä–∞–∑—É –ø–æ–¥ –±–ª–æ–∫–æ–º Elo
    if history:
        caption_lines.append("")
        caption_lines.append("<b>üèÜ –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤</b>")
        for created_at, entry_text in history:
            date_str = created_at.split("T")[0] if isinstance(created_at, str) else str(created_at)[:10]
            caption_lines.append(f"- [{date_str}] {entry_text}")

    photo = FSInputFile(image_path)
    kb = InlineKeyboardBuilder()
    kb.button(text="üìà –ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π", callback_data="elo_history")
    kb.button(text="üå≥ –ú–æ—è –∫–∞—Ä—å–µ—Ä–∞", callback_data="career:self")
    await message.answer_photo(
        photo=photo,
        caption="\n".join(caption_lines),
        reply_markup=kb.adjust(1).as_markup(),
    )

@dp.callback_query(F.data == "elo_history")
async def on_elo_history(call: CallbackQuery):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–∞—Ä—Ç–∏–Ω–∫—É —Å –¥–∏–Ω–∞–º–∏–∫–æ–π Elo –∑–∞ –Ω–µ–¥–µ–ª—é –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ–Ω–µ–Ω–∏–π.
    –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ inline-–∫–Ω–æ–ø–∫–µ.
    """
    user = await get_user(call.from_user.id)
    if not user:
        await call.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start", show_alert=True)
        return

    user_id = int(user.get("user_id") or call.from_user.id)

    # –¢–æ—á–∫–∏ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞ –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ–Ω–µ–Ω–∏–π
    points, last_changes = await get_elo_history_for_user(user_id, days=7)

    image_path = generate_elo_history_image(
        user_id=user_id,
        nickname=user.get("nickname"),
        points=points,
    )

@dp.callback_query(F.data == "career:self")
async def on_career_self(call: CallbackQuery):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–µ—Ä–µ–≤–æ —Ä–æ–ª–µ–π —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞.
    –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ /profile –ø–æ –∫–Ω–æ–ø–∫–µ ¬´–ú–æ—è –∫–∞—Ä—å–µ—Ä–∞¬ª.
    """
    user = await get_user(call.from_user.id)
    if not user:
        await call.answer("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start", show_alert=True)
        return

    user_id = int(user.get("user_id") or call.from_user.id)
    opened = set(await get_user_roles(user_id))
    current_role = user.get("current_role")

    image_path = generate_role_tree_image(
        user_id=user_id,
        opened_roles=opened,
        current_role=current_role,
    )

    await call.message.answer_photo(
        photo=FSInputFile(image_path),
        caption="üå≥ –í–∞—à–∞ –∫–∞—Ä—å–µ—Ä–∞ –≤ –∫–ª–∞–Ω–µ.\n–ó–µ–ª—ë–Ω—ã–º –≤—ã–¥–µ–ª–µ–Ω—ã —É–∂–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –±–ª–æ–∫–∏.",
    )
    await call.answer()

    lines: list[str] = ["<b>üìà –ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è Elo –∑–∞ 7 –¥–Ω–µ–π</b>"]

    if last_changes:
        lines.append("")
        lines.append("<b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∏–∑–º–µ–Ω–µ–Ω–∏–π:</b>")
        for dt_str, delta, reason in last_changes:
            sign = "+" if delta >= 0 else ""
            lines.append(f"‚Ä¢ {dt_str} ‚Äî {sign}{delta} ({reason})")
    else:
        lines.append("")
        lines.append("–ò–∑–º–µ–Ω–µ–Ω–∏—è —Ä–µ–π—Ç–∏–Ω–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")

    await call.message.answer_photo(
        photo=FSInputFile(image_path),
        caption="\n".join(lines),
    )
    await call.answer()

@dp.message(F.chat.id == CLAN_CHAT_ID, F.new_chat_members)
async def on_user_joined_clan(message: Message):
    for member in message.new_chat_members:
        uid = member.id
        user = await get_user(uid)
        if user and user.get("status") in (Status.APPROVED.value, Status.JOINED.value):
            now_iso = datetime.utcnow().isoformat()
            first_join = not user.get("joined_at")
            if first_join:
                await upsert_user(uid, status=Status.JOINED.value, joined_at=now_iso)
                user = await get_user(uid)
            nickname = user.get("nickname") or member.full_name
            tg_username = None
            try:
                if getattr(member, "username", None):
                    tg_username = f"@{member.username}"
            except Exception:
                tg_username = None
            if not tg_username and user:
                link = user.get("tg_link")
                if link:
                    l = link.strip()
                    if l.startswith("https://t.me/") or l.startswith("http://t.me/") or l.startswith("t.me/"):
                        uname = l.split("t.me/")[-1].strip("/ ")
                        if uname:
                            tg_username = f"@{uname}"
                    elif l.startswith("@"):
                        tg_username = l
            announce = (
                f"<b>{nickname}</b> ({tg_username}) –≤—Å—Ç—É–ø–∏–ª –≤ –Ω–∞—à –∫–ª–∞–Ω!" if tg_username
                else f"<b>{nickname}</b> –≤—Å—Ç—É–ø–∏–ª –≤ –Ω–∞—à –∫–ª–∞–Ω!"
            )
            await bot.send_message(CLAN_CHAT_ID, announce)
            clanid = pad_clan_id(user.get("clan_id"))
            join_text = (
                f"<b>–£—á–∞—Å—Ç–Ω–∏–∫ –≤—Å—Ç—É–ø–∏–ª –≤ –∫–ª–∞–Ω</b>\n"
                f"ClanID: <code>{clanid}</code>\n"
                f"Telegram ID: <code>{uid}</code>\n"
                f"–ù–∏–∫: {nickname}\n"
                f"Discord: {user.get('discord') or '-'}\n"
                f"SteamID: {user.get('steamid') or '-'}\n"
                f"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è: {user.get('birth_date') or '-'}\n"
                f"–í–æ–∑—Ä–∞—Å—Ç: {user.get('age') or '-'}\n"
                f"–§—Ä–∞–∫—Ü–∏—è: {user.get('faction') or '-'}\n"
                f"–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {user.get('timezone') or '-'}\n"
                f"–õ–∏—á–Ω—ã–π TG: {user.get('tg_link') or '-'}\n"
                f"–î–∞—Ç–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {user.get('joined_at') or now_iso}"
            )
            await send_to_moderation(join_text)


@dp.message(F.new_chat_members)
async def on_user_joined_any(message: Message):
    if message.chat.id != CLAN_CHAT_ID:
        return
    await on_user_joined_clan(message)

# ======= Help & Stats =======
@dp.message(or_f(F.text == "/help", F.text == "help"))
async def cmd_help(message: Message):
    await message.answer(
        """–ö–æ–º–∞–Ω–¥—ã:
/start ‚Äî —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
/profile ‚Äî –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å
/player <user_id | @username | —á–∞—Å—Ç—å –Ω–∏–∫–∞> ‚Äî –ø—Ä–æ—Ñ–∏–ª—å –∏–≥—Ä–æ–∫–∞ (–¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤, –≤—ã–±–æ—Ä —Ñ—Ä–∞–∫—Ü–∏–∏/—É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è)
/stats ‚Äî –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã (–¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤/–∞–¥–º–∏–Ω–æ–≤)
"""
    )

async def get_stats(start: Optional[datetime], end: Optional[datetime]) -> str:
    params_created: list = []
    params_applied: list = []
    params_approved: list = []
    params_joined: list = []
    params_deleted: list = []
    def range_cond(col: str, params_list: list):
        c = []
        if start:
            c.append(f"date({col}) >= date(?)")
            params_list.append(start.isoformat())
        if end:
            c.append(f"date({col}) <= date(?)")
            params_list.append(end.isoformat())
        return (" AND ".join(c)) if c else "1=1"
    cond_created = range_cond("created_at", params_created)
    cond_applied = range_cond("applied_at", params_applied)
    cond_approved = range_cond("approved_at", params_approved)
    cond_joined = range_cond("joined_at", params_joined)
    cond_deleted = range_cond("created_at", params_deleted)
    async with aiosqlite.connect(DB_PATH) as db:
        new_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE {cond_created}", params_created)).fetchone())[0]
        applied_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE applied_at IS NOT NULL AND {cond_applied}", params_applied)).fetchone())[0]
        approved_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE approved_at IS NOT NULL AND {cond_approved}", params_approved)).fetchone())[0]
        joined_cnt = (await (await db.execute(f"SELECT COUNT(1) FROM users WHERE joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone())[0]
        total = (await (await db.execute("SELECT COUNT(1) FROM users")).fetchone())[0]
        pending = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.PENDING_REVIEW.value,))).fetchone())[0]
        approved_not_joined = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.APPROVED.value,))).fetchone())[0]
        joined_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.JOINED.value,))).fetchone())[0]
        rejected_total = (await (await db.execute("SELECT COUNT(1) FROM users WHERE status=?", (Status.REJECTED.value,))).fetchone())[0]
        deleted_cnt_row = await (await db.execute(f"SELECT COUNT(1) FROM mod_actions WHERE action = ? AND {cond_deleted}", ["–£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –∏–∑ –±–∞–∑—ã", *params_deleted])).fetchone()
        deleted_cnt = deleted_cnt_row[0] if deleted_cnt_row else 0
        avg_age_row = await (await db.execute(f"SELECT AVG(age) FROM users WHERE age IS NOT NULL AND joined_at IS NOT NULL AND {cond_joined}", params_joined)).fetchone()
        avg_age = round(avg_age_row[0], 1) if avg_age_row and avg_age_row[0] is not None else None
        tz_rows = await (await db.execute(
            f"SELECT timezone, COUNT(1) c FROM users WHERE joined_at IS NOT NULL AND timezone IS NOT NULL AND {cond_joined} GROUP BY timezone ORDER BY c DESC LIMIT 5",
            params_joined,
        )).fetchall()
    lines = ["<b>–ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Ç—á—ë—Ç—ã</b>"]
    if start or end:
        lines.append(f"–ü–µ—Ä–∏–æ–¥: {start.date() if start else '‚Äî'} ‚Äî {end.date() if end else '‚Äî'}")
    lines += [
        f"–ù–æ–≤—ã—Ö —Å—Ç–∞—Ä—Ç–æ–≤ /start: <b>{new_cnt}</b>",
        f"–ó–∞—è–≤–æ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: <b>{applied_cnt}</b>",
        f"–û–¥–æ–±—Ä–µ–Ω–æ: <b>{approved_cnt}</b>",
        f"–í—Å—Ç—É–ø–∏–ª–æ: <b>{joined_cnt}</b>",
        f"–£–¥–∞–ª–µ–Ω–æ –∏–∑ –±–∞–∑—ã: <b>{deleted_cnt}</b>",
        f"–ü–æ–∫–∏–Ω—É–ª–æ –∫–ª–∞–Ω: <b>{deleted_cnt}</b>",
        "",
        "<b>–í–æ—Ä–æ–Ω–∫–∞ (–≤—Å–µ–≥–æ):</b>",
        f"–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}",
        f"–ù–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏: {pending}",
        f"–û–¥–æ–±—Ä–µ–Ω—ã (–Ω–µ –≤—Å—Ç—É–ø–∏–ª–∏): {approved_not_joined}",
        f"–í—Å—Ç—É–ø–∏–ª–∏: {joined_total}",
        f"–û—Ç–∫–ª–æ–Ω–µ–Ω—ã: {rejected_total}",
    ]
    if avg_age is not None:
        lines.append(f"–°—Ä–µ–¥–Ω–∏–π –≤–æ–∑—Ä–∞—Å—Ç (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ –≤ –ø–µ—Ä–∏–æ–¥): {avg_age}")
    if tz_rows:
        lines.append("–¢–æ–ø –ø–æ —á–∞—Å–æ–≤—ã–º –ø–æ—è—Å–∞–º (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ):")
        for tz, c in tz_rows:
            lines.append(f"‚Ä¢ {tz}: {c}")
    return "\n".join(lines)

def period_bounds(key: str):
    now = datetime.utcnow()
    if key == "today":
        start = datetime(now.year, now.month, now.day)
        end = now
    elif key == "7d":
        end = now
        start = now - timedelta(days=7)
    elif key == "30d":
        end = now
        start = now - timedelta(days=30)
    else:
        start = None
        end = None
    return start, end

def stats_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–°–µ–≥–æ–¥–Ω—è", callback_data="stats:today")
    kb.button(text="7 –¥–Ω–µ–π", callback_data="stats:7d")
    kb.button(text="30 –¥–Ω–µ–π", callback_data="stats:30d")
    kb.button(text="–ó–∞ –≤—Å—ë –≤—Ä–µ–º—è", callback_data="stats:all")
    kb.button(text="CSV (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ 30–¥)", callback_data="export:joined:30d")
    kb.button(text="CSV (–≤—Å–µ –∑–∞ 30–¥)", callback_data="export:all:30d")
    return kb.adjust(1).as_markup()

@dp.message(F.text == "/stats")
async def cmd_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ—Ç—á—ë—Ç–∞:", reply_markup=stats_kb())

@dp.callback_query(F.data.startswith("stats:"))
async def on_stats(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    key = call.data.split(":")[1]
    start, end = period_bounds(key)
    text = await get_stats(start, end)
    await call.message.edit_text(text, reply_markup=stats_kb())

async def export_csv(kind: str, start: Optional[datetime], end: Optional[datetime]) -> str:
    cond_col = {"joined": "joined_at", "all": "created_at"}[kind]
    params = []
    where = []
    if start:
        where.append(f"date({cond_col}) >= date(?)")
        params.append(start.isoformat())
    if end:
        where.append(f"date({cond_col}) <= date(?)")
        params.append(end.isoformat())
    if kind == "joined":
        where.append("joined_at IS NOT NULL")
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT clan_id, user_id, nickname, discord, steamid, age, birth_date, timezone, tg_link, phone, faction, status, created_at, applied_at, approved_at, joined_at FROM users WHERE {where}".format(where=where_sql),
            params,
        )
        rows = await cur.fetchall()
        cols = [d[0] for d in cur.description]
    fname = f"bb_report_{kind}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
    import csv
    with open(fname, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(cols)
        writer.writerows(rows)
    return fname

@dp.callback_query(F.data.startswith("export:"))
async def on_export(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    _, kind, key = call.data.split(":")
    start, end = period_bounds(key)
    path = await export_csv(kind, start, end)
    await bot.send_document(call.from_user.id, FSInputFile(path))
    await call.answer("CSV –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")


def username_from_tglink(link: str | None) -> str:
    if not link:
        return "‚Äî"
    link = link.strip()
    if link.startswith("https://t.me/") or link.startswith("http://t.me/") or link.startswith("t.me/"):
        uname = link.split("t.me/")[-1].strip("/ ")
        if uname:
            return "@" + uname
    if link.startswith("@"):
        return link
    return "‚Äî"
# ======= Players list (admins/mods) =======

async def fetch_joined_players(limit: int = 2000):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT clan_id, nickname, tg_link FROM users WHERE status=? ORDER BY clan_id ASC",
            ("joined",)
        )
        return await cur.fetchall()

def format_players_brief(rows) -> str:
    lines = ["<b>–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ –∫–ª–∞–Ω–∞</b>"]
    if not rows:
        lines.append("‚Äî –ø–æ–∫–∞ –ø—É—Å—Ç–æ ‚Äî")
    else:
        for clan_id, nickname, tg_link in rows:
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            nick = username_from_tglink(tg_link)
            name = nickname or "‚Äî"
            lines.append(f"{cid} ‚Äî –ù–∏–∫: {nick} ‚Äî –ò–º—è: {name}")
    return "\n".join(lines)
PAGE_SIZE = 10


def training_kb(date_str: str) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="–î–∞", callback_data=f"train:yes:{date_str}")
    kb.button(text="–ù–µ—Ç", callback_data=f"train:no:{date_str}")
    kb.button(text="–û–ø–æ–∑–¥–∞—é", callback_data=f"train:late:{date_str}")
    return kb.adjust(1).as_markup()

def players_nav_kb(filter_type: str, filter_value: str, page: int, has_prev: bool, has_next: bool) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    if has_prev:
        kb.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"players:{filter_type}:{filter_value}:{page-1}")
    if has_next:
        kb.button(text="–î–∞–ª–µ–µ ‚ñ∂Ô∏è", callback_data=f"players:{filter_type}:{filter_value}:{page+1}")
    kb.row()
    kb.button(text=("‚Ä¢ –í—Å–µ" if filter_type=="all" else "–í—Å–µ"), callback_data="players:all::1")
    kb.button(text=("‚Ä¢ –í—Å—Ç—É–ø–∏–ª–∏" if filter_type=="joined" else "–í—Å—Ç—É–ø–∏–ª–∏"), callback_data="players:joined::1")
    kb.button(text=("‚Ä¢ –§—Ä–∞–∫—Ü–∏–∏" if filter_type=="faction" else "–§—Ä–∞–∫—Ü–∏–∏"), callback_data=f"players:choose_faction::{page}")
    return kb.adjust(1).as_markup()


def players_factions_kb(page: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for code, title in (("hq","–®—Ç–∞–±"),("blackhole","Black Hole")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("armless","Armless"),("brainless","Brainless")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("burning","Burning Assholes"),("freshmeat","Fresh Meat")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    for code, title in (("useless","Useless cans"),("reserve","–†–µ–∑–µ—Ä–≤")):
        kb.button(text=title, callback_data=f"players:faction:{title}:1")
    kb.row()
    kb.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ (–≤—Å–µ)", callback_data="players:all::1")
    return kb.adjust(1).as_markup()

async def fetch_players(filter_type: str, filter_value: str, page: int):
    offset = (page-1)*PAGE_SIZE
    where = []
    params = []
    where.append("(status IS NULL OR status != ?)")
    params.append("removed")
    if filter_type == "joined":
        where.append("status = ?")
        params.append("joined")
    elif filter_type == "faction" and filter_value:
        where.append("faction = ?")
        params.append(filter_value)
    where_sql = " AND ".join(where) if where else "1=1"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(f"SELECT COUNT(1) FROM users WHERE {where_sql}", params)
        total = (await cur.fetchone())[0]
        cur = await db.execute(
            f"""SELECT clan_id, user_id, nickname, faction, status
                FROM users
                WHERE {where_sql}
                ORDER BY created_at DESC
                LIMIT ? OFFSET ?""",
            params + [PAGE_SIZE, offset]
        )
        rows = await cur.fetchall()
    has_next = (offset + PAGE_SIZE) < total
    has_prev = page > 1
    return rows, has_prev, has_next, total

def format_players_list(rows, page: int, total: int, filter_type: str, filter_value: str) -> str:
    title_map = {
        "all": "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (–≤—Å–µ, –∫—Ä–æ–º–µ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö)",
        "joined": "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ)",
        "faction": f"–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (—Ñ—Ä–∞–∫—Ü–∏—è: {filter_value})" if filter_value else "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤ (–ø–æ —Ñ—Ä–∞–∫—Ü–∏–∏)"
    }
    lines = [f"<b>{title_map.get(filter_type, '–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤')}</b>"]
    lines.append(f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page} ‚Ä¢ –≤—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {total}")
    if not rows:
        lines.append("‚Äî –ø—É—Å—Ç–æ ‚Äî")
    else:
        for idx, (clan_id, user_id, nickname, faction, status) in enumerate(rows, 1):
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            nick = nickname or "-"
            fac = faction or "-"
            st = status or "-"
            lines.append(f"{idx:>2}. {cid} ‚Äî {nick} ({fac}) ‚Äî {st} ‚Äî ID: <code>{user_id}</code>")
    lines.append("\n–û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å: /player <ID>")
    return "\n".join(lines)


@dp.message(Command("players"))
async def cmd_players(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT COUNT(1) FROM users WHERE status=?", ("joined",))
        total_joined = (await cur.fetchone())[0]

        cur = await db.execute(
            """
            SELECT COALESCE(NULLIF(TRIM(faction), ''), '‚Äî') AS fac, COUNT(1) AS c
            FROM users
            WHERE status = 'joined'
            GROUP BY fac
            ORDER BY c DESC, fac ASC
            """
        )
        faction_rows = await cur.fetchall()

        # ---- –ù–û–í–´–ô –ë–õ–û–ö: –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –∑–≤–∞–Ω–∏—è–º (clan_title) ----
        cur = await db.execute(
            """
            SELECT COALESCE(NULLIF(TRIM(clan_title), ''), '‚Äî') AS title, COUNT(1) AS c
            FROM users
            WHERE status = 'joined'
            GROUP BY title
            ORDER BY c DESC, title ASC
            """
        )
        rank_rows = await cur.fetchall()
        # ---- –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –ë–õ–û–ö–ê ----

        cur = await db.execute(
            """
            SELECT clan_id, user_id, nickname, tg_link, discord, steamid, age, birth_date, timezone, faction, joined_at
            FROM users
            WHERE status = 'joined'
            ORDER BY clan_id ASC
            """
        )
        csv_rows = await cur.fetchall()
        csv_cols = [d[0] for d in cur.description]

    lines = [f"<b>–ò–≥—Ä–æ–∫–∏ –∫–ª–∞–Ω–∞ (–≤—Å—Ç—É–ø–∏–≤—à–∏–µ)</b>", f"–í—Å–µ–≥–æ: <b>{total_joined}</b>"]
    if faction_rows:
        lines.append("–ü–æ —Ñ—Ä–∞–∫—Ü–∏—è–º:")
        for fac, c in faction_rows:
            lines.append(f"‚Ä¢ {fac}: {c}")

    # ---- –ù–û–í–´–ô –ë–õ–û–ö: –≤—ã–≤–æ–¥ –ø–æ –∑–≤–∞–Ω–∏—è–º ----
    if rank_rows:
        lines.append("")  # –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
        lines.append("–ü–æ –∑–≤–∞–Ω–∏—è–º:")
        for title, c in rank_rows:
            lines.append(f"‚Ä¢ {title}: {c}")
    # ---- –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –ë–õ–û–ö–ê ----

    await message.answer("\n".join(lines))

    fname = f"clan_joined_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
    with open(fname, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(csv_cols)
        writer.writerows(csv_rows)
    try:
        await message.answer_document(FSInputFile(fname), caption="–°–æ—Å—Ç–∞–≤ –∫–ª–∞–Ω–∞ (joined) ‚Äî CSV")
    except Exception:
        pass

@dp.callback_query(F.data.startswith("players:choose_faction"))
async def on_players_choose_faction(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    await call.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ—Ä–∞–∫—Ü–∏—é:", reply_markup=players_factions_kb(1))
    await call.answer()


    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –æ —Å–º–µ–Ω–µ —Ñ—Ä–∞–∫—Ü–∏–∏

    await send_faction_notice(uid, faction)

@dp.callback_query(F.data.startswith("players:"))
async def on_players_list(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã", show_alert=True)
        return
    try:
        _, ftype, fvalue, page_str = call.data.split(":", 3)
        page = int(page_str or "1")
        ftype = ftype or "all"
        fvalue = fvalue or ""
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.", show_alert=True)
        return
    rows, has_prev, has_next, total = await fetch_players(ftype, fvalue, page)
    text = format_players_list(rows, page, total, ftype, fvalue)
    try:
        await call.message.edit_text(text, reply_markup=players_nav_kb(ftype, fvalue, page, has_prev, has_next))
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data.startswith("remove:final:"))
async def on_remove_final(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    _, _, uid_str = call.data.split(":")
    target_id = int(uid_str)
    # check all steps complete
    done_db, done_tg, done_disc = await removal_state(target_id)
    if not (done_db and done_tg and done_disc):
        await call.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —Ç—Ä–∏ —à–∞–≥–∞ —á–µ–∫-–ª–∏—Å—Ç–∞.", show_alert=True)
        return
    # hard delete from users and archive
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM users WHERE user_id=?", (target_id,))
        await db.execute("DELETE FROM users_archive WHERE user_id=?", (target_id,))
        await db.execute("DELETE FROM removal_checklist WHERE user_id=?", (target_id,))
        await db.commit()
    await call.answer("–ò–≥—Ä–æ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª—ë–Ω –∏–∑ –±–∞–∑—ã –±–æ—Ç–∞.", show_alert=True)
    await log_mod_action(call.from_user.id, "–£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –∏–∑ –±–∞–∑—ã", target_id=target_id)
    try:
        await call.message.edit_text("<b>–£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.</b> –ò–≥—Ä–æ–∫ —Å—Ç–µ—Ä—ë–Ω –∏–∑ –±–∞–∑—ã.")
    except Exception:
        pass


async def ensure_joined_if_member(user_id: int):
    """Promote to JOINED only if user is member of chat AND already APPROVED."""
    try:
        user = await get_user(user_id)
        if not user:
            return
        member = await bot.get_chat_member(CLAN_CHAT_ID, user_id)
        if member.status in ("member", "administrator", "creator") and user.get("status") == Status.APPROVED.value:
            updates = {"status": Status.JOINED.value}
            if not user.get("joined_at"):
                from datetime import datetime
                updates["joined_at"] = datetime.utcnow().isoformat()
            await upsert_user(user_id, **updates)
    except Exception:
        pass


async def send_evening_training_poll():
    # Moscow date for the poll
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    date_str = today.isoformat()
    text = f"–ë—É–¥–µ—à—å —Å–µ–≥–æ–¥–Ω—è –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?\n–î–∞—Ç–∞: <b>{date_str}</b>"
    kb = training_kb(date_str)
    # send only to users without today's response
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT u.user_id FROM users u
            WHERE u.status = ?
              AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
              AND NOT EXISTS (
                SELECT 1 FROM training_attendance t
                WHERE t.user_id = u.user_id AND t.date = ?
              )
            """,
            ("joined", date_str)
        )
        ids = [r[0] for r in await cur.fetchall()]
    for uid in ids:
        try:
            await bot.send_message(uid, text, reply_markup=kb)
        except Exception:
            continue

async def check_training_inactive_3days():
    # Find users who have no answers for the last 3 days (MSK)
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    days = [(today - timedelta(days=i)).isoformat() for i in range(0, 3)]
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT u.user_id, u.nickname, u.tg_link FROM users u
            WHERE u.status = ?
              AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
              AND u.user_id NOT IN (
                SELECT DISTINCT user_id FROM training_attendance
                WHERE date IN (?,?,?)
              )
            """,
            ("joined", days[0], days[1], days[2])
        )
        rows = await cur.fetchall()
    if not rows:
        return

    lines: list[str] = []
    for uid, nickname, tg_link in rows:
        user = {"user_id": uid, "nickname": nickname, "tg_link": tg_link}
        try:
            disp = display_name(user)
        except Exception:
            disp = None
        if not disp:
            disp = nickname or tg_link or str(uid)
        lines.append(f'–ò–≥—Ä–æ–∫ "{disp}" –Ω–µ –≤—ã—Ö–æ–¥–∏—Ç –Ω–∞ —Å–≤—è–∑—å –≤ —Ç–µ—á–µ–Ω–∏–µ 3-—Ö –¥–Ω–µ–π')

    text = "\n".join(lines)
    await notify_staff(text)

async def adjust_training_elo_for_training(user_id: int, delta: int) -> None:
    """
    –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ ELO –∑–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏.
    –ù–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ—Ç –∏–≥—Ä–æ–∫–æ–≤ –≤–æ —Ñ—Ä–∞–∫—Ü–∏–∏ '–†–µ–∑–µ—Ä–≤'.
    """
    user = await get_user(user_id)
    if not user:
        return
    # –ù–µ —Ç—Ä–æ–≥–∞–µ–º —Ñ—Ä–∞–∫—Ü–∏—é "–†–µ–∑–µ—Ä–≤"
    if user.get("faction") == "–†–µ–∑–µ—Ä–≤":
        return

    old_elo = (user.get("elo_rating") if user.get("elo_rating") is not None else 1000)

    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            """
            UPDATE users
            SET elo_rating = COALESCE(elo_rating, 1000) + ?
            WHERE user_id = ?
            """,
            (delta, user_id),
        )
        await db.commit()

    # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞ –∑–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É
    await log_rating_change(user_id, delta, reason="training_attendance")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–º–µ–Ω–∏–ª—Å—è –ª–∏ —Ä–∞–Ω–≥
    updated = await get_user(user_id)
    if updated:
        new_elo = (updated.get("elo_rating") if updated.get("elo_rating") is not None else 1000)
        await notify_rank_if_changed(user_id, old_elo, new_elo)

async def save_training_response(user_id: int, date_str: str, response: str, reason: str | None):
    now_iso = datetime.utcnow().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO training_attendance(date,user_id,response,reason,created_at,updated_at) VALUES(?,?,?,?,?,?) "
            "ON CONFLICT(date,user_id) DO UPDATE SET response=excluded.response, reason=excluded.reason, updated_at=excluded.updated_at",
            (date_str, user_id, response, reason, now_iso, now_iso)
        )
        await db.commit()

async def apply_training_attendance_elo(user_id: int, date_str: str, new_response: str) -> None:
    """
    –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –º–µ–Ω—è–µ—Ç ELO –∑–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–º–µ–Ω—ã —Å—Ç–∞—Ç—É—Å–∞.

    –ü—Ä–∞–≤–∏–ª–∞:
    - –ó–∞ 'yes' –¥–∞—ë—Ç—Å—è +10 ELO, –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏:
        * —Ä–∞–Ω—å—à–µ –Ω–µ –±—ã–ª–æ 'yes' –Ω–∞ —ç—Ç—É –¥–∞—Ç—É
        * –∏ —Å—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω—ë–Ω –¥–æ 20:00 –ø–æ –ú–æ—Å–∫–≤–µ –≤ –¥–µ–Ω—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏.
    - –ï—Å–ª–∏ –±—ã–ª 'yes', –∞ —Å—Ç–∞–ª 'no' –∏–ª–∏ 'late' ‚Äî —Å–Ω–∏–º–∞–µ–º 10 ELO (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤—Ä–µ–º–µ–Ω–∏).
    - –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –º–µ–∂–¥—É 'no' <-> 'late' –∏–ª–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –æ—Ç–≤–µ—Ç ELO –Ω–µ —Ç—Ä–æ–≥–∞—é—Ç.
    """
    # –£–∑–Ω–∞—ë–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –æ—Ç–≤–µ—Ç (–µ—Å–ª–∏ –±—ã–ª)
    prev_response: str | None = None
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT response FROM training_attendance WHERE date=? AND user_id=?",
            (date_str, user_id),
        )
        row = await cur.fetchone()
        if row:
            prev_response = row[0]

    # –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è ‚Äî ELO –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
    if prev_response == new_response:
        return

    delta = 0

    # –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ø–æ –ú–æ—Å–∫–≤–µ
    msk = ZoneInfo("Europe/Moscow")
    now_msk = datetime.now(msk)
    today_str = now_msk.date().isoformat()
    cutoff_hour = 20  # 20:00 –ø–æ –ú–æ—Å–∫–≤–µ

    # –ü–µ—Ä–µ—Ö–æ–¥ –≤ "–î–∞"
    if new_response == "yes" and prev_response != "yes":
        # –ù–∞—á–∏—Å–ª—è–µ–º ELO —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–µ—á—å –ø—Ä–æ —Å–µ–≥–æ–¥–Ω—è—à–Ω—é—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É
        # –∏ –æ—Ç–≤–µ—Ç/—Å–º–µ–Ω–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–¥–µ–ª–∞–Ω—ã –¥–æ 20:00 –ø–æ –ú–æ—Å–∫–≤–µ
        if date_str == today_str and now_msk.hour < cutoff_hour:
            delta = 10

    # –£—Ö–æ–¥ –∏–∑ "–î–∞" –≤ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π —Å—Ç–∞—Ç—É—Å
    elif prev_response == "yes" and new_response in ("no", "late"):
        # –í—Å–µ–≥–¥–∞ —Å–Ω–∏–º–∞–µ–º 10, –µ—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –ø–µ—Ä–µ–¥—É–º–∞–ª –∏ –±–æ–ª—å—à–µ –Ω–µ "–î–∞"
        delta = -10

    if delta != 0:
        await adjust_training_elo_for_training(user_id, delta)

async def send_daily_training_poll():
    # Moscow date for the poll
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    date_str = today.isoformat()
    text = f"–ë—É–¥–µ—à—å —Å–µ–≥–æ–¥–Ω—è –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ?\n–î–∞—Ç–∞: <b>{date_str}</b>"
    kb = training_kb(date_str)
    # send to all active users (exclude removed)
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT user_id FROM users WHERE status = ? AND (faction IS NULL OR faction != '–†–µ–∑–µ—Ä–≤')", ("joined",))
        ids = [r[0] for r in await cur.fetchall()]
    for uid in ids:
        try:
            await bot.send_message(uid, text, reply_markup=kb)
        except Exception:
            continue

async def apply_training_noresponse_penalties():
    """
    –®—Ç—Ä–∞—Ñ -10 ELO –∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–π –æ–ø—Ä–æ—Å –∑–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å.
    –ù–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ—Ç –∏–≥—Ä–æ–∫–æ–≤ –≤–æ —Ñ—Ä–∞–∫—Ü–∏–∏ '–†–µ–∑–µ—Ä–≤'.
    """
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    date_str = today.isoformat()

    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT u.user_id
            FROM users u
            WHERE u.status = ?
              AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
              AND NOT EXISTS (
                SELECT 1
                FROM training_attendance t
                WHERE t.user_id = u.user_id AND t.date = ?
              )
            """,
            ("joined", date_str),
        )
        rows = await cur.fetchall()

    for (uid,) in rows:
        try:
            await adjust_training_elo_for_training(uid, -10)
        except Exception:
            # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –Ω–µ —Ä–æ–Ω—è–µ–º –≤—Å—é –∑–∞–¥–∞—á—É –∏–∑-–∑–∞ –æ–¥–Ω–æ–π –æ—à–∏–±–∫–∏
            continue

@dp.callback_query(F.data.startswith("train:"))
async def on_training_answer(call: CallbackQuery, state: FSMContext):
    # –°–†–ê–ó–£ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º callback, —á—Ç–æ–±—ã –Ω–µ —Å–ª–æ–≤–∏—Ç—å timeout
    try:
        await call.answer()
    except TelegramBadRequest:
        pass

    try:
        _, choice, date_str = call.data.split(":")
    except ValueError:
        return

    uid = call.from_user.id

    if choice == "yes":
        # –°–Ω–∞—á–∞–ª–∞ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º ELO –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
        await apply_training_attendance_elo(uid, date_str, "yes")
        # –ó–∞—Ç–µ–º —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π –æ—Ç–≤–µ—Ç
        await save_training_response(uid, date_str, "yes", None)
        try:
            await call.message.edit_text(f"–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>–î–∞</b> –Ω–∞ {date_str}")
        except TelegramBadRequest:
            try:
                await call.message.answer(f"–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>–î–∞</b> –Ω–∞ {date_str}")
            except Exception:
                pass
        return

    # 'no' –∏ 'late' ‚Äî –ø—Ä–æ—Å–∏–º –ø—Ä–∏—á–∏–Ω—É
    await state.update_data(train_choice=choice, train_date=date_str, train_chat_id=call.message.chat.id, train_msg_id=call.message.message_id)
    try:
        await call.message.answer("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É:")
    except TelegramBadRequest:
        try:
            await bot.send_message(uid, "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É:")
        except Exception:
            pass
    await state.set_state(TrainingReason.waiting_reason)

@dp.message(TrainingReason.waiting_reason)
async def on_training_reason(message: Message, state: FSMContext):
    data = await state.get_data()
    uid = message.from_user.id
    reason = (message.text or "").strip()
    if not reason:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É —Ç–µ–∫—Å—Ç–æ–º.")
        return

    choice = data.get("train_choice")
    date_str = data.get("train_date")

    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º ELO –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
    if choice in ("no", "late"):
        await apply_training_attendance_elo(uid, date_str, choice)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–≤–µ—Ç –≤ –∂—É—Ä–Ω–∞–ª –ø–æ—Å–µ—â–∞–µ–º–æ—Å—Ç–∏
    await save_training_response(uid, date_str, choice, reason)

    label = "–ù–µ—Ç" if choice == "no" else "–û–ø–æ–∑–¥–∞—é"
    await message.answer(f"–û—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>{label}</b> ({reason}) –Ω–∞ {date_str}")

    # Optionally remove keyboard from original poll to avoid duplicate clicks
    try:
        await bot.edit_message_reply_markup(
            chat_id=data.get("train_chat_id"),
            message_id=data.get("train_msg_id"),
            reply_markup=None,
        )
    except Exception:
        pass

    await state.clear()

async def fetch_training_stats(date_from: str, date_to: str | None = None):
    async with aiosqlite.connect(DB_PATH) as db:
        if not date_to or date_to == date_from:
            cur = await db.execute(
                "SELECT response, COUNT(*) FROM training_attendance WHERE date=? GROUP BY response",
                (date_from,)
            )
            agg = {row[0]: row[1] for row in await cur.fetchall()}
            cur = await db.execute(
                "SELECT user_id, response, reason FROM training_attendance WHERE date=? AND response IN ('no','late')",
                (date_from,)
            )
            details = await cur.fetchall()
            return {"single": True, "date": date_from, "agg": agg, "details": details}
        else:
            cur = await db.execute(
                "SELECT date, response, COUNT(*) FROM training_attendance WHERE date BETWEEN ? AND ? GROUP BY date, response ORDER BY date ASC",
                (date_from, date_to)
            )
            rows = await cur.fetchall()
            return {"single": False, "rows": rows}




@dp.message(Command("train_stats"))  # /train_stats [YYYY-MM-DD] or /train_stats YYYY-MM-DD YYYY-MM-DD
async def cmd_train_stats(message: Message):
    # Access: keep same as before ‚Äî only admins (or add moderators if needed)
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    # Parse arguments
    tail = (message.text or "").split(maxsplit=1)
    dates = []
    if len(tail) > 1:
        dates = [t for t in tail[1].strip().split() if t]

    from zoneinfo import ZoneInfo
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date().isoformat()

    def valid_date(s: str) -> bool:
        try:
            datetime.strptime(s, "%Y-%m-%d")
            return True
        except Exception:
            return False

    # Decide mode
    if len(dates) == 0:
        date_from = today
        date_to = None
    elif len(dates) == 1 and valid_date(dates[0]):
        date_from = dates[0]
        date_to = None
    elif len(dates) >= 2 and valid_date(dates[0]) and valid_date(dates[1]):
        date_from = dates[0]
        date_to = dates[1]
    else:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /train_stats [YYYY-MM-DD] –∏–ª–∏ /train_stats YYYY-MM-DD YYYY-MM-DD")
        return

    # SINGLE-DAY: show detailed stats incl. '–ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏' and CSV
    if not date_to:
        date_str = date_from
        async with aiosqlite.connect(DB_PATH) as db:
            # aggregate yes/no/late (—Ç–æ–ª—å–∫–æ –Ω–µ-–†–µ–∑–µ—Ä–≤)
            cur = await db.execute(
                """
                SELECT t.response, COUNT(*)
                FROM training_attendance t
                JOIN users u ON u.user_id = t.user_id
                WHERE t.date = ?
                  AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
                GROUP BY t.response
                """,
                (date_str,),
            )
            agg = {row[0]: row[1] for row in await cur.fetchall()}

            # details for no/late (—Ç–æ–ª—å–∫–æ –Ω–µ-–†–µ–∑–µ—Ä–≤)
            cur = await db.execute(
                """
                SELECT t.user_id, t.response, t.reason
                FROM training_attendance t
                JOIN users u ON u.user_id = t.user_id
                WHERE t.date = ?
                  AND t.response IN ('no','late')
                  AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
                """,
                (date_str,),
            )
            details = await cur.fetchall()

            # yes responders with role (—Ç–æ–ª—å–∫–æ –Ω–µ-–†–µ–∑–µ—Ä–≤) ‚Äî –¥–ª—è —Å–ø–∏—Å–∫–∞ –¶–ú–î/–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞
            cur = await db.execute(
                """
                SELECT t.user_id, u.nickname, u.tg_link, u.current_role
                FROM training_attendance t
                JOIN users u ON u.user_id = t.user_id
                WHERE t.date = ?
                  AND t.response = 'yes'
                  AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
                """,
                (date_str,),
            )
            yes_rows = await cur.fetchall()

            # joined users (—Ç–æ–ª—å–∫–æ –Ω–µ-–†–µ–∑–µ—Ä–≤)
            cur = await db.execute(
                """
                SELECT user_id, nickname, tg_link
                FROM users
                WHERE status = ?
                  AND (faction IS NULL OR faction != '–†–µ–∑–µ—Ä–≤')
                """,
                ("joined",),
            )
            joined_users = await cur.fetchall()
            all_joined_ids = {u[0] for u in joined_users}

            # answered set (—Ç–æ–ª—å–∫–æ –Ω–µ-–†–µ–∑–µ—Ä–≤, –¥–ª—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏)
            cur = await db.execute(
                """
                SELECT DISTINCT t.user_id
                FROM training_attendance t
                JOIN users u ON u.user_id = t.user_id
                WHERE t.date = ?
                  AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
                """,
                (date_str,),
            )
            answered_ids = {r[0] for r in await cur.fetchall()}

        not_answered = [(uid, nick, link) for uid, nick, link in joined_users if uid not in answered_ids]
        total_joined = len(all_joined_ids)
        not_answered_count = len(not_answered)

        text_lines = [
            f"<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –∑–∞ {date_str}</b>",
            f"‚úÖ –î–∞: {agg.get('yes', 0)}",
            f"‚ùå –ù–µ—Ç: {agg.get('no', 0)}",
            f"‚è∞ –û–ø–æ–∑–¥–∞—é: {agg.get('late', 0)}",
            f"‚ÅâÔ∏è –ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏: {not_answered_count} –∏–∑ {total_joined}",
        ]

        # --- NEW: –¶–ú–î –∏ –ö–æ–º–∞–Ω–¥–∏—Ä—ã –æ—Ç—Ä—è–¥–∞, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ "–î–∞" ---
        cmd_yes: list[str] = []
        squad_yes: list[str] = []

        for uid, nick, link, role in (yes_rows or []):
            role_title = get_role_title(role) if role is not None else ""
            disp = nick or username_from_tglink(link) or str(uid)

            if "–¶–ú–î" in (role_title or ""):
                cmd_yes.append(disp)
            if "–ö–æ–º–∞–Ω–¥–∏—Ä –æ—Ç—Ä—è–¥–∞" in (role_title or ""):
                squad_yes.append(disp)

        if cmd_yes or squad_yes:
            text_lines.append("")
            if cmd_yes:
                text_lines.append("<b>–¶–ú–î (–æ—Ç–≤–µ—Ç–∏–ª–∏ –î–∞)</b>")
                for name in cmd_yes:
                    text_lines.append(f"‚Ä¢ {name}")
            if squad_yes:
                text_lines.append("<b>–ö–æ–º–∞–Ω–¥–∏—Ä—ã –æ—Ç—Ä—è–¥–∞ (–æ—Ç–≤–µ—Ç–∏–ª–∏ –î–∞)</b>")
                for name in squad_yes:
                    text_lines.append(f"‚Ä¢ {name}")
        # --- END NEW ---

        # append reasons list (grouped)
        if details:
            text_lines.append("")
            text_lines.append("<b>–ü—Ä–∏—á–∏–Ω—ã (–ù–µ—Ç/–û–ø–æ–∑–¥–∞—é)</b>")
    async with aiosqlite.connect(DB_PATH) as db:
        for uid, resp, reason in details:
            label = "‚ùå –ù–µ—Ç" if resp == "no" else "‚è∞ –û–ø–æ–∑–¥–∞—é"
            reason = reason or "‚Äî"
            cur = await db.execute("SELECT nickname, tg_link FROM users WHERE user_id=?", (uid,))
            row = await cur.fetchone()
            if row and row[0]:
                disp = row[0]
            else:
                # fallback to @username from tg_link
                uname = username_from_tglink(row[1]) if row else None
                disp = uname if uname and uname != "‚Äî" else str(uid)
            text_lines.append(f"{label}: {disp}: {reason}")


        # –†–∞–∑–±–∏–≤–∞–µ–º –¥–ª–∏–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å "Bad Request: message is too long"
        _full_text = "\n".join(text_lines)
        _max = 3900  # –∑–∞–ø–∞—Å –æ—Ç –ª–∏–º–∏—Ç–∞ Telegram ~4096
        _buf = []
        _len = 0
        for _line in _full_text.splitlines():
            if _len + len(_line) + 1 > _max:
                await message.answer("\n".join(_buf) if _buf else ".")
                _buf = [_line]
                _len = len(_line) + 1
            else:
                _buf.append(_line)
                _len += len(_line) + 1
        if _buf:
            await message.answer("\n".join(_buf))
        # Build and send CSV with not answered
        import csv
        csv_name = f"not_answered_{date_str}.csv"
        with open(csv_name, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["Nickname", "Username (tg_link)"])
            for uid, nick, link in not_answered:
                uname = username_from_tglink(link)
                writer.writerow([nick or "-", uname or "-"])
        try:
            await message.answer_document(FSInputFile(csv_name), caption="–ù–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ (CSV)")
        except Exception:
            try:
                await bot.send_document(message.chat.id, FSInputFile(csv_name))
            except Exception:
                pass
        return

    # RANGE MODE: aggregate by day and print per-day lines (kept old style)
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT t.date, t.response, COUNT(*)
            FROM training_attendance t
            JOIN users u ON u.user_id = t.user_id
            WHERE t.date BETWEEN ? AND ?
              AND (u.faction IS NULL OR u.faction != '–†–µ–∑–µ—Ä–≤')
            GROUP BY t.date, t.response
            ORDER BY t.date ASC
            """,
            (date_from, date_to),
        )
        rows = await cur.fetchall()

    lines = [f"<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –∑–∞ –ø–µ—Ä–∏–æ–¥ {date_from} ‚Äî {date_to}</b>"]
    cur_d = None
    agg_d = {}
    def push_day(d):
        if not agg_d: return
        lines.append(f"{d}: –î–∞ {agg_d.get('yes',0)} ‚Ä¢ –ù–µ—Ç {agg_d.get('no',0)} ‚Ä¢ –û–ø–æ–∑–¥–∞—é {agg_d.get('late',0)}")

    for d, resp, cnt in rows:
        if d != cur_d:
            if cur_d is not None:
                push_day(cur_d)
            cur_d = d
            agg_d = {}
        agg_d[resp] = cnt
    if cur_d is not None:
        push_day(cur_d)
    await message.answer("\n".join(lines))


@dp.message(Command("new"))
async def cmd_new_users(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    limit = 100
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, clan_id, nickname, created_at FROM users WHERE status = ? ORDER BY created_at DESC LIMIT ?",
            ("new", limit)
        )
        rows = await cur.fetchall()

    # Build text
    lines = ["<b>–ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (status=new)</b>"]
    if not rows:
        lines.append("‚Äî —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî")
    else:
        for uid, clan_id, nickname, created_at in rows:
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            name = nickname or "-"
            lines.append(f"ClanID: {cid} ‚Ä¢ ID: <code>{uid}</code> ‚Ä¢ –ù–∏–∫: {name} ‚Ä¢ –°–æ–∑–¥–∞–Ω: {created_at or '-'}")
        lines.append("\\n–ß—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å: –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É –∫–∞—Ä—Ç–æ—á–∫–∏.")
    text = "\\n".join(lines)

    # Build keyboard
    kb = InlineKeyboardBuilder()
    for uid, clan_id, nickname, created_at in rows:
        kb.button(text=f"üóë –£–¥–∞–ª–∏—Ç—å {nickname or uid}", callback_data=f"newdel:{uid}")
    markup = kb.adjust(1).as_markup()

    try:
        await message.answer(text, reply_markup=markup)
    except Exception:
        await message.answer(text)

@dp.callback_query(F.data.startswith("newdel:"))
async def on_new_user_delete(call: CallbackQuery):
    if call.from_user.id not in ADMIN_IDS:
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return
    try:
        _, uid_str = call.data.split(":")
        target_id = int(uid_str)
    except Exception:
        await call.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.", show_alert=True)
        return
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute("SELECT status FROM users WHERE user_id=?", (target_id,))
        row = await cur.fetchone()
        if not row or row[0] != "new":
            await call.answer("–£–¥–∞–ª—è—Ç—å –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º new.", show_alert=True)
            return
        await db.execute("DELETE FROM users WHERE user_id=?", (target_id,))
        try:
            await db.execute("DELETE FROM users_archive WHERE user_id=?", (target_id,))
        except Exception:
            pass
        try:
            await db.execute("DELETE FROM removal_checklist WHERE user_id=?", (target_id,))
        except Exception:
            pass
        try:
            await db.execute("DELETE FROM training_attendance WHERE user_id=?", (target_id,))
        except Exception:
            pass
        await db.commit()
    try:
        await call.message.edit_text("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω –∏–∑ –±–∞–∑—ã (status=new). –û–±–Ω–æ–≤–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥–æ–π /new.")
    except Exception:
        pass
    await call.answer("–£–¥–∞–ª—ë–Ω.")


async def check_recruit_promotion_candidates():
    from datetime import datetime, timedelta
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    threshold = (today - timedelta(days=14)).isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, nickname, tg_link, joined_at FROM users "
            "WHERE status = ? AND faction = ? AND joined_at IS NOT NULL AND date(joined_at) <= date(?)",
            ("joined", "Fresh Meat", threshold)
        )
        rows = await cur.fetchall()
    for uid, nickname, tg_link, joined_at in rows:
        user = { "user_id": uid, "nickname": nickname, "tg_link": tg_link, "joined_at": joined_at }
        text = f"–ò–≥—Ä–æ–∫ {display_name(user)} –≤ –∫–ª–∞–Ω–µ 14 –¥–Ω–µ–π –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–æ—Å—Ç–∞–≤."
        try:
            await notify_staff(text)
        except Exception:
            for rid in reviewer_ids():
                try:
                    await bot.send_message(rid, text)
                except Exception:
                    pass

async def check_birthdays_today():
    from datetime import datetime
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date()
    mm = f"{today.month:02d}"; dd = f"{today.day:02d}"
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, nickname, tg_link, birth_date FROM users "
            "WHERE status = ? AND birth_date IS NOT NULL",
            ("joined",)
        )
        rows = await cur.fetchall()
    for uid, nickname, tg_link, birth_date in rows:
        try:
            bmm = birth_date[5:7]; bdd = birth_date[8:10]
        except Exception:
            continue
        if bmm == mm and bdd == dd:
            user = { "user_id": uid, "nickname": nickname, "tg_link": tg_link }
            text = f"–ò–≥—Ä–æ–∫ {display_name(user)} —Å–µ–≥–æ–¥–Ω—è –æ—Ç–º–µ—á–∞–µ—Ç –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è!"
            try:
                await notify_staff(text)
            except Exception:
                for rid in reviewer_ids():
                    try:
                        await bot.send_message(rid, text)
                    except Exception:
                        pass

async def send_faction_notice(user_id: int, faction: str):
    if faction != "–†–µ–∑–µ—Ä–≤":
        texts = {
            "–®—Ç–∞–±": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢—ã –∏–∑–±—Ä–∞–Ω–æ –ë–æ–≥–æ–º, —Å—É–¥—å–±–æ–π –∏ –ö–∏—á–µ–º. –¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è: –®—Ç–∞–±. –ü–æ–º–Ω–∏, —Ç—ã –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–µ–Ω –∑–∞ –ª—é–¥–µ–π.",
            "Black Hole": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Black Hole! –¢—ã - —ç–ª–∏—Ç–∞ –∫–ª–∞–Ω–∞. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Chidori(@Bigchungusik)",
            "Armless": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Armless. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Lazy(@lazyprogramer)",
            "Brainless": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Brainless. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Zerox(@Sadz3ro)",
            "Burning Assholes": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Burning Assholes. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Fluffy_Racc00n(@Fluffy_Racc00n)",
            "Useless cans": "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢–≤–æ—è —Ñ—Ä–∞–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ Useless Cans. –¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Gadler(@Gadler0)",
        }
        text = texts.get(faction)
        if not text:
            return
        try:
            await bot.send_message(user_id, text)
        except Exception:
            pass
        return
    # –î–ª—è –†–µ–∑–µ—Ä–≤–∞ ‚Äî –ø—Ä–æ–±—É–µ–º –≤–∫–ª—é—á–∏—Ç—å –¥–∞—Ç—É
    user = await get_user(user_id)
    until_iso = (user or {}).get("reserve_until")
    msg = None
    if until_iso:
        try:
            d = datetime.strptime(until_iso, "%Y-%m-%d").date()
            msg = f"–¢—ã –ø–µ—Ä–µ–≤–µ–¥—ë–Ω –≤ —Ä–µ–∑–µ—Ä–≤ –∫–ª–∞–Ω–∞ –¥–æ {d.strftime('%d.%m.%Y')}. –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ! –î–ª—è —ç—Ç–æ–≥–æ —Ç—ã –º–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å –ª—é–±–æ–º—É –∏–∑ HR."
        except Exception:
            pass
    if not msg:
        msg = "–¢—ã –ø–µ—Ä–µ–≤–µ–¥—ë–Ω –≤ —Ä–µ–∑–µ—Ä–≤ –∫–ª–∞–Ω–∞. –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ! –î–ª—è —ç—Ç–æ–≥–æ —Ç—ã –º–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å –ª—é–±–æ–º—É –∏–∑ HR."
    try:
        await bot.send_message(user_id, msg)
    except Exception:
        pass



# ==== Manual moderation commands (/accept, /reject) ====

@dp.message(Command("accept"))
async def cmd_accept(message: Message):
    # Only admins/moderators
    try:
        allowed = set(ADMIN_IDS) | set(MODERATOR_IDS)
    except Exception:
        allowed = set(ADMIN_IDS)
    if message.from_user.id not in allowed:
        await message.answer("‚õî –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.")
        return

    parts = (message.text or "").strip().split()
    if len(parts) < 2 or not parts[1].isdigit():
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /accept <tg_id>")
        return

    target_id = int(parts[1])
    user = await get_user(target_id)
    if not user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –±–æ—Ç–∞.")
        return

    # Already processed states
    st = user.get("status")
    if st == Status.REJECTED.value:
        await message.answer("–ó–∞—è–≤–∫–∞ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ä–∞–Ω–µ–µ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")
        return
    if st in (Status.APPROVED.value, Status.JOINED.value):
        await message.answer("–≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω –∏–ª–∏ –≤—Å—Ç—É–ø–∏–ª.")
        return

    # Optional: check profile completeness if —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞
    try:
        ok = await is_profile_complete(target_id)
    except Exception:
        ok = True
    if not ok:
        await message.answer("–ê–Ω–∫–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∞ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é ‚Äî –æ–¥–æ–±—Ä–µ–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")
        return

    # Set APPROVED and default faction if empty
    faction = user.get("faction") or "Fresh Meat"
    await upsert_user(target_id, status=Status.APPROVED.value, approved_at=datetime.utcnow().isoformat(), faction=faction)
    await set_user_current_role(target_id, "recruit")  # ‚Üê –ù–û–í–ê–Ø –°–¢–†–û–ö–ê
    await ensure_joined_if_member(target_id)

    link = await create_invite_link()
    if not link:
        await message.answer("–û–¥–æ–±—Ä–µ–Ω–æ, –Ω–æ —Å—Å—ã–ª–∫—É —Å–æ–∑–¥–∞—Ç—å –Ω–µ —É–¥–∞–ª–æ—Å—å ‚Äî –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –±–æ—Ç–∞ –≤ –∫–ª–∞–Ω-—á–∞—Ç–µ.")
    else:
        try:
            await bot.send_message(
                target_id,
                f"–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞!\n–§—Ä–∞–∫—Ü–∏—è: {faction}\n–°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ —á–∞—Ç –∫–ª–∞–Ω–∞: {link.invite_link}"
            )
        except Exception:
            pass

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∫–∞–∫ –ø—Ä–∏ –∫–Ω–æ–ø–∫–µ ¬´–û–¥–æ–±—Ä–∏—Ç—å¬ª
        try:
            await bot.send_message(
                target_id,
                "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Ç–µ–≥ –≤ –∏–≥—Ä–µ: [BBr]\n"
                "–¢–≤–æ–π –∫–æ–º–∞–Ω–¥–∏—Ä: Gocha(@Bagman7)\n\n"
                "–ù–∞–∑–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –ø–∞—Ä–æ–ª–∏ –æ—Ç –Ω–∏—Ö:\n"
                "Blackberry | Training - Blackberries #1 0106\n"
                "Blackberry | Training- Strawberries #2 7848\n"
                "Blackberry | Training- Blueberries #3 9723\n"
                "Blackberry | Training- Cranberries #4 8831\n\n"
                "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è:\n"
                "–ò–ù–§–û Blackberry: https://t.me/+sL9VacfwkxYyYmUy\n"
                "–î–Ω–µ–≤–Ω–∏–∫ Blackberry: https://t.me/+QZJOj-3aiXowYjEy\n"
            )
        except Exception:
            pass

    try:
        await notify_review_outcome(target_id, "approved")
    except Exception:
        pass

    await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_id} –æ–¥–æ–±—Ä–µ–Ω (—Å—Ç–∞—Ç—É—Å APPROVED).")

@dp.message(Command("reject"))
async def cmd_reject(message: Message):
    # Only admins/moderators
    try:
        allowed = set(ADMIN_IDS) | set(MODERATOR_IDS)
    except Exception:
        allowed = set(ADMIN_IDS)
    if message.from_user.id not in allowed:
        await message.answer("‚õî –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.")
        return

    parts = (message.text or "").strip().split()
    if len(parts) < 2 or not parts[1].isdigit():
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /reject <tg_id>")
        return

    target_id = int(parts[1])
    user = await get_user(target_id)
    if not user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –±–æ—Ç–∞.")
        return

    st = user.get("status")
    if st in (Status.APPROVED.value, Status.JOINED.value):
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ–¥–æ–±—Ä–µ–Ω/–≤—Å—Ç—É–ø–∏–ª.")
        return
    if st == Status.REJECTED.value:
        await message.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ —Ä–∞–Ω–µ–µ.")
        return

    await upsert_user(target_id, status=Status.REJECTED.value)

    try:
        await bot.send_message(target_id, "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")
    except Exception:
        pass

    try:
        await notify_review_outcome(target_id, "rejected")
    except Exception:
        pass

    await message.answer(f"–ó–∞—è–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.")



# === Admin-only broadcast: /seed (excludes faction "–†–µ–∑–µ—Ä–≤") ===
@dp.message(Command("seed"))
async def cmd_seed(message: Message):
    # Only administrators
    try:
        allowed = set(ADMIN_IDS)
    except Exception:
        allowed = set()
    if message.from_user.id not in allowed:
        await message.answer("‚õî –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return

    seed_text = (
        "–ü—Ä–∏–≤–µ—Ç! –£ –Ω–∞—Å –≤—Å–µ –µ—â–µ –Ω–µ –ø–æ–ª–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –∏ –Ω–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ, —á—Ç–æ–±—ã —Ç—ã –∑–∞—à–µ–ª –Ω–∞ –Ω–∞—à —Å–µ—Ä–≤–µ—Ä [RU] –§—Ä—É–∫—Ç–æ–≤—ã–π —Å–∞–¥. "
        "–¢—ã –º–æ–∂–µ—à—å –ø—Ä–æ—Å—Ç–æ –∑–∞–π—Ç–∏, –≤—ã—Å—Ç–∞–≤–∏—Ç—å –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ FPS –∏ –∑–∞–Ω–∏–º–∞—Ç—å—Å—è —Å–≤–æ–∏–º–∏ –¥–µ–ª–∞–º–∏. "
        "–ò–ª–∏ —Ç—ã –º–æ–∂–µ—à—å –∑–∞–π—Ç–∏ –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π —Å–∫–∏–ª–ª. "
        "–í –ª—é–±–æ–º —Å–ª—É—á–∞–µ, —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞—à–µ–º—É –∫–ª–∞–Ω—É –Ω—É–∂–µ–Ω –ø–æ–ª–Ω—ã–π —Å–µ—Ä–≤–µ—Ä, –≥–¥–µ –º—ã –Ω–∞–±–∏—Ä–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ –Ω–∞—à–∏ —Ä—è–¥—ã. "
        "–ë—É–¥—å —Å –∫–ª–∞–Ω–æ–º, –Ω–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–π —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ. –°–ø–∞—Å–∏–±–æ, –¥—Ä—É–≥!"
    )

    await message.answer("–ó–∞–ø—É—Å–∫–∞—é —Ä–∞—Å—Å—ã–ª–∫—É —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º (–∫—Ä–æ–º–µ —Ñ—Ä–∞–∫—Ü–∏–∏ '–†–µ–∑–µ—Ä–≤')...")

    sent = 0
    failed = 0
    ids = []

    # –≤—ã–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫—Ä–æ–º–µ —Ñ—Ä–∞–∫—Ü–∏–∏ "–†–µ–∑–µ—Ä–≤"
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cur = await db.execute(
                "SELECT DISTINCT user_id FROM users WHERE faction IS NULL OR faction != '–†–µ–∑–µ—Ä–≤'"
            )
            rows = await cur.fetchall()
            ids = [int(r[0]) for r in rows if r and r[0]]
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return

    # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º DM
    for uid in ids:
        try:
            await bot.send_message(uid, seed_text)
            sent += 1
            # –ª—ë–≥–∫–∏–π —Ç—Ä–æ—Ç—Ç–ª–∏–Ω–≥
            import asyncio
            await asyncio.sleep(0.05)
        except Exception:
            failed += 1

    await message.answer(f"–ì–æ—Ç–æ–≤–æ. –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {sent} | –ù–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {failed}.")




# ======= MENU (joined-only) =======
def clan_menu_kb() -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="‚ôª –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ—Å–µ—â–µ–Ω–∏—è", callback_data="menu:change_attendance")
    kb.row()
    kb.button(text="üìû –ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–Ω—Ç–∞–∫—Ç—ã", callback_data="menu:contacts")
    kb.button(text="üìÜ –ü—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –∏–≤–µ–Ω—Ç—ã", callback_data="menu:events")
    kb.row()
    kb.button(text="‚öî –ö–ª–∞–Ω–æ–≤—ã–µ –≤–æ–π–Ω—ã", callback_data="menu:cw")
    kb.row()
    kb.button(text="üèÜ –¢–û–ü-20 –∏–≥—Ä–æ–∫–æ–≤ –∫–ª–∞–Ω–∞", callback_data="menu:top10")
    kb.row()
    kb.button(text="üí§ –ü–µ—Ä–µ–π—Ç–∏ –≤ —Ä–µ–∑–µ—Ä–≤", callback_data="menu:reserve")
    kb.row()
    kb.button(text="‚ñ∂ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ [RU] –§—Ä—É–∫—Ç–æ–≤—ã–π —Å–∞–¥", url="https://squadbrowser.org/#snprwyx")
    kb.button(text="‚ñ∂ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –¢—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä ‚Ññ1", url="https://squadbrowser.org/#siqxxg3")
    return kb.adjust(1).as_markup()


@dp.callback_query(F.data == "menu:cw")
async def CW_menu_list(call: CallbackQuery):
    wars = await CW_list_active()
    if not wars:
        await call.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ö–í.", show_alert=True)
        return
    kb = InlineKeyboardBuilder()
    for w in wars:
        kb.button(text=f"{w['opponents']} ‚Äî {format_cw_datetime(w['starts_at'])}", callback_data=f"cw:view:{w['id']}")
    await call.message.answer("<b>–ê–∫—Ç–∏–≤–Ω—ã–µ –ö–í</b>", reply_markup=kb.adjust(1).as_markup())
    await call.answer()

@dp.callback_query(F.data == "menu:top10")
async def show_top10(call: CallbackQuery):
    # –ë–µ—Ä—ë–º –¢–û–ü-20 –ø–æ —Ç–µ–∫—É—â–µ–º—É ELO + –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞ –∏–∑ rating_changes
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT
                u.user_id,
                COALESCE(u.nickname, '') AS nickname,
                COALESCE(u.elo_rating, 1000) AS elo,
                COALESCE((
                    SELECT rc.delta
                    FROM rating_changes AS rc
                    WHERE rc.user_id = u.user_id
                    ORDER BY rc.id DESC
                    LIMIT 1
                ), 0) AS last_delta
            FROM users AS u
            ORDER BY elo DESC
            LIMIT 20
            """
        )
        rows = await cur.fetchall()

    if not rows:
        await call.answer("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)
        return

    # –ì–æ—Ç–æ–≤–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã: (–º–µ—Å—Ç–æ, –Ω–∏–∫, —Ç–µ–∫—É—â–∏–π ELO, –∏–∑–º–µ–Ω–µ–Ω–∏–µ ELO)
    entries: list[tuple[int, str, int, int, str]] = []
    for idx, (user_id, nickname, elo, last_delta) in enumerate(rows, start=1):
        display_nick = nickname or f"ID {user_id}"
        rank_name, _ = get_rank(int(elo or 0))
        entries.append((idx, display_nick, int(elo or 0), int(last_delta or 0), rank_name))

    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –¢–û–ü-20
    image_path = generate_top_leaderboard_image(entries)

    await call.message.answer_photo(
        photo=FSInputFile(image_path),
        caption="<b>üèÜ –¢–û–ü-20 –∏–≥—Ä–æ–∫–æ–≤ –∫–ª–∞–Ω–∞</b>",
    )
    await call.answer()

@dp.callback_query(F.data.startswith("cw:view:"))
async def CW_menu_view(call: CallbackQuery):
    war_id = int(call.data.split(":")[2])
    w = await CW_get_war(war_id)
    if not w:
        await call.answer("–ö–í –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True); return
    regs = await CW_registrations(war_id)
    free = max(0, int(w['team_size']) - len(regs))
    info = (
        f"‚öî<b>{w['opponents']}</b>\n"
        f"‚è∞<b>–ö–æ–≥–¥–∞:</b> {format_cw_datetime(w['starts_at'])}\nüó∫<b>–ö–∞—Ä—Ç–∞:</b> {w.get('map') or '-'}\n‚ò†<b>–ö–æ–º–∞–Ω–¥–∞:</b> {w['team_size']} —á–µ–ª–æ–≤–µ–∫\n"
        f"üì¢<b>–ü—Ä–∞–≤–∏–ª–∞:</b> {w.get('rules') or '-'}\nüîå<b>–°–µ—Ä–≤–µ—Ä:</b> {w.get('server') or '-'}\n"
        f"üìú<b>–ó–∞–ø–∏—Å–∞–ª–∏—Å—å:</b> {len(regs)} / {w['team_size']} (—Å–≤–æ–±–æ–¥–Ω–æ: {free})"
    )
    kb = InlineKeyboardBuilder()
    if call.from_user.id not in regs and free > 0:
        kb.button(text=f"–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ –ö–í \"{w['opponents']}\"", callback_data=f"cw:ask:{war_id}")
    await call.message.answer(info, reply_markup=kb.adjust(1).as_markup() if kb.buttons else None)
    await call.answer()

@dp.callback_query(F.data.startswith("cw:ask:"))
async def CW_menu_ask(call: CallbackQuery):
    war_id = int(call.data.split(":")[2])
    w = await CW_get_war(war_id)
    if not w:
        await call.answer("–ö–í –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."); return
    kb = InlineKeyboardBuilder()
    kb.button(text="–î–∞", callback_data=f"cw:confirm:{war_id}")
    kb.button(text="–ù–µ—Ç", callback_data="cw:cancel")
    await call.message.answer(f"–í—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –Ω–∞ –ö–í? –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –æ—Ç–º–µ–Ω—ã –Ω–µ—Ç.\n–ö–í: {w['opponents']}", reply_markup=kb.adjust(2).as_markup())
    await call.answer()

@dp.callback_query(F.data.startswith("cw:confirm:"))
async def CW_menu_confirm(call: CallbackQuery):
    war_id = int(call.data.split(":")[2])
    ok, msg = await CW_register(war_id, call.from_user.id)
    await call.answer(msg, show_alert=not ok)

@dp.callback_query(F.data == "cw:cancel")
async def CW_menu_cancel(call: CallbackQuery):
    await call.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.")
def _is_joined_status(user: dict | None) -> bool:
    try:
        st = (user or {}).get("status")
        return bool(st == (Status.JOINED.value if isinstance(Status.JOINED, Enum) else "joined") or st == "joined")
    except Exception:
        return False



# ======= ADMIN TEXT COMMANDS =======
def _is_admin(user_id: int) -> bool:
    try:
        return int(user_id) in ADMIN_IDS
    except Exception:
        return False

@dp.message(Command("ivent"))
async def cmd_set_events_text(message: Message):
    if not _is_admin(message.from_user.id):
        await message.answer("–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return
    # get text after command
    arg = message.text.split(maxsplit=1)
    if len(arg) == 1 or not arg[1].strip():
        current = await get_setting("events_text", "–°–∫–æ—Ä–æ –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ")
        await message.answer(f"–¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç –¥–ª—è ¬´–ü—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –∏–≤–µ–Ω—Ç—ã¬ª:\n\n{current}\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ: <code>/ivent –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç</code>")
        return
    await set_setting("events_text", arg[1].strip())
    await log_mod_action(message.from_user.id, "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–≤–µ–Ω—Ç–æ–≤")
    await message.answer("–¢–µ–∫—Å—Ç –¥–ª—è ¬´–ü—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –∏–≤–µ–Ω—Ç—ã¬ª –æ–±–Ω–æ–≤–ª—ë–Ω.")

@dp.message(Command("contacts"))
async def cmd_set_contacts_text(message: Message):
    if not _is_admin(message.from_user.id):
        await message.answer("–ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return
    arg = message.text.split(maxsplit=1)
    if len(arg) == 1 or not arg[1].strip():
        current = await get_setting("contacts_text", "–°–∫–æ—Ä–æ –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ")
        await message.answer(f"–¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç –¥–ª—è ¬´–ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–Ω—Ç–∞–∫—Ç—ã¬ª:\n\n{current}\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ: <code>/contacts –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç</code>")
        return
    await set_setting("contacts_text", arg[1].strip())
    await log_mod_action(message.from_user.id, "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤")
    await message.answer("–¢–µ–∫—Å—Ç –¥–ª—è ¬´–ü–æ–ª–µ–∑–Ω—ã–µ –∫–æ–Ω—Ç–∞–∫—Ç—ã¬ª –æ–±–Ω–æ–≤–ª—ë–Ω.")
@dp.message(Command("menu"), F.chat.type == "private")
async def cmd_menu(message: Message):
    if message.chat.type != "private":
        return
    user = await get_user(message.from_user.id)
    if not user or not _is_joined_status(user):
        await message.answer("–î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–≥—Ä–æ–∫–æ–≤, –≤—Å—Ç—É–ø–∏–≤—à–∏—Ö –≤ –∫–ª–∞–Ω (—Å—Ç–∞—Ç—É—Å: joined).")
        return
    await message.answer("<b>–ú–µ–Ω—é</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=clan_menu_kb())

@dp.callback_query(F.data == "menu:contacts")
async def on_menu_contacts(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not _is_joined_status(user):
        await call.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –≤—Å—Ç—É–ø–∏–≤—à–∏—Ö –∏–≥—Ä–æ–∫–æ–≤.", show_alert=True)
        return
    # –æ—Ç–≤–µ—Ç –≤ —Ç–æ–º –∂–µ —á–∞—Ç–µ
    try:
        txt = await get_setting("contacts_text", "–°–∫–æ—Ä–æ –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ")
        await call.message.answer(txt)
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data == "menu:events")
async def on_menu_events(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not _is_joined_status(user):
        await call.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –≤—Å—Ç—É–ø–∏–≤—à–∏—Ö –∏–≥—Ä–æ–∫–æ–≤.", show_alert=True)
        return
    try:
        txt = await get_setting("events_text", "–°–∫–æ—Ä–æ –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ")
        await call.message.answer(txt)
    except Exception:
        pass
    await call.answer()

@dp.callback_query(F.data == "menu:change_attendance")
async def on_menu_change_attendance(call: CallbackQuery):
    uid = call.from_user.id
    user = await get_user(uid)
    if not _is_joined_status(user):
        await call.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –≤—Å—Ç—É–ø–∏–≤—à–∏—Ö –∏–≥—Ä–æ–∫–æ–≤.", show_alert=True)
        return
    # –ü–æ–∫–∞–∂–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –æ–ø—Ä–æ—Å–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è—à–Ω—é—é –¥–∞—Ç—É –ø–æ –ú–æ—Å–∫–≤–µ ‚Äî –∑–∞–ø–∏—Å—å –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç—Å—è, –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å
    try:
        await call.answer()
    except Exception:
        pass
    try:
        msk = ZoneInfo("Europe/Moscow")
        today = datetime.now(msk).date().isoformat()
    except Exception:
        today = datetime.utcnow().date().isoformat()
    kb = training_kb(today)
    text = f"–ò–∑–º–µ–Ω–∏—Ç—å –≤–∞—à –æ—Ç–≤–µ—Ç –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É —Å–µ–≥–æ–¥–Ω—è?\n–î–∞—Ç–∞: <b>{today}</b>"
    try:
        await call.message.answer(text, reply_markup=kb)
    except Exception:
        pass

@dp.callback_query(F.data == "menu:reserve")
async def on_menu_reserve(call: CallbackQuery, state: FSMContext):
    uid = call.from_user.id
    user = await get_user(uid)
    if not _is_joined_status(user):
        await call.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –≤—Å—Ç—É–ø–∏–≤—à–∏—Ö –∏–≥—Ä–æ–∫–æ–≤.", show_alert=True)
        return
    try:
        await call.answer()
    except Exception:
        pass
    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ —Ä–µ–∑–µ—Ä–≤:")
    await state.update_data(reserve_request_user_id=uid)
    await state.set_state(ReserveRequestState.waiting_reason)

@dp.message(ReserveRequestState.waiting_reason)
async def on_reserve_request_reason(message: Message, state: FSMContext):
    reason = (message.text or "").strip()
    if not reason:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤ —Ä–µ–∑–µ—Ä–≤ —Ç–µ–∫—Å—Ç–æ–º.")
        return
    await state.update_data(reserve_request_reason=reason)
    await message.answer('–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—É—é –¥–∞—Ç—É –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 15.03.2025 –∏–ª–∏ "–º–∞—Ä—Ç 2025"):')
    await state.set_state(ReserveRequestState.waiting_date)

@dp.message(ReserveRequestState.waiting_date)
async def on_reserve_request_date(message: Message, state: FSMContext):
    date_text = (message.text or "").strip()
    if not date_text:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—É—é –¥–∞—Ç—É –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞.")
        return
    data = await state.get_data()
    reason = data.get("reserve_request_reason") or "‚Äî"
    user_id = data.get("reserve_request_user_id") or message.from_user.id
    user = await get_user(user_id)
    try:
        disp = display_name(user) if user else None
    except Exception:
        disp = None
    if not disp:
        disp = message.from_user.full_name or (("@" + message.from_user.username) if message.from_user.username else str(user_id))
    text = f'–ò–≥—Ä–æ–∫ "{disp}" —Ö–æ—á–µ—Ç –ø–µ—Ä–µ–π—Ç–∏ –≤ —Ä–µ–∑–µ—Ä–≤. –ü—Ä–∏—á–∏–Ω–∞: "{reason}" –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –¥–∞—Ç–∞ –≤—ã—Ö–æ–¥–∞: "{date_text}"'
    try:
        await notify_staff(text)
    except Exception:
        for rid in reviewer_ids():
            try:
                await bot.send_message(rid, text)
            except Exception:
                pass
    await message.answer("–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ HR. –û–∂–∏–¥–∞–π—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
    await state.clear()


@dp.message(ReserveUntilState.waiting_date)
async def on_reserve_until_input(message: Message, state: FSMContext):
    raw = (message.text or "").strip()
    try:
        dt = datetime.strptime(raw, "%d.%m.%Y").date()
    except Exception:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∫–∞–∫ –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 25.12.2025).")
        return
    data = await state.get_data()
    target_id = data.get("reserve_user_id")
    if not target_id:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–≥—Ä–æ–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
        await state.clear()
        return
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ—Ä–∞–∫—Ü–∏—é –∏ –¥–∞—Ç—É –≤ ISO
    await upsert_user(target_id, faction="–†–µ–∑–µ—Ä–≤", reserve_until=dt.isoformat())
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–≥—Ä–æ–∫—É —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –¥–∞—Ç–æ–π
    try:
        await bot.send_message(target_id, f"–¢—ã –ø–µ—Ä–µ–≤–µ–¥—ë–Ω –≤ —Ä–µ–∑–µ—Ä–≤ –∫–ª–∞–Ω–∞ –¥–æ {raw}. –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ! –î–ª—è —ç—Ç–æ–≥–æ —Ç—ã –º–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å –ª—é–±–æ–º—É –∏–∑ HR.")
    except Exception:
        pass
    # –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞—Ä—Ç–æ—á–∫—É
    user = await get_user(target_id)
    panel_chat_id = data.get("panel_chat_id")
    panel_msg_id = data.get("panel_msg_id")
    try:
        if panel_chat_id and panel_msg_id:
            await bot.edit_message_text(chat_id=panel_chat_id, message_id=panel_msg_id, text=format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id))
        else:
            await message.answer(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id))
    except Exception:
        try:
            await message.answer(format_profile(user, history=await get_tournament_history(int(user.get("user_id")))), reply_markup=profile_admin_kb(target_id, actor_id=message.from_user.id))
        except Exception:
            pass
    await message.answer("‚úÖ –ü–µ—Ä–µ–≤–æ–¥ –≤ —Ä–µ–∑–µ—Ä–≤ —Å–æ—Ö—Ä–∞–Ω—ë–Ω.")
    await state.clear()

async def check_reserve_expired():
    """–ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ —Ä–µ–∑–µ—Ä–≤–µ —Å –Ω–∞—Å—Ç—É–ø–∏–≤—à–µ–π –¥–∞—Ç–æ–π –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤/–∞–¥–º–∏–Ω–æ–≤."""
    try:
        tz = ZoneInfo("Europe/Moscow")
    except Exception:
        tz = None
    today = (datetime.now(tz).date() if tz else datetime.utcnow().date()).isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, nickname, tg_link FROM users WHERE faction='–†–µ–∑–µ—Ä–≤' AND reserve_until IS NOT NULL AND date(reserve_until) = date(?)",
            (today,)
        )
        rows = await cur.fetchall()
    for uid, nickname, tg_link in rows:
        user = {"user_id": uid, "nickname": nickname, "tg_link": tg_link}
        text = f"–ò–≥—Ä–æ–∫ \"{display_name(user)}\" –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å—Å—è –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞. –°–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∏–º."
        try:
            await notify_staff(text)
        except Exception:
            for rid in reviewer_ids():
                try:
                    await bot.send_message(rid, text)
                except Exception:
                    pass

async def main():
    await init_db()
    await ensure_training_tables()
    logging.info("DB initialized at %s", DB_PATH)
    # Scheduler for training polls and inactivity checks
    try:
        scheduler = AsyncIOScheduler(timezone=ZoneInfo("Europe/Moscow"))
        global CW_SCHEDULER
        CW_SCHEDULER = scheduler
        scheduler.add_job(send_daily_training_poll, CronTrigger(hour=15, minute=30))
        scheduler.add_job(send_evening_training_poll, CronTrigger(hour=18, minute=0))
        scheduler.add_job(apply_training_noresponse_penalties, CronTrigger(hour=20, minute=0))
        scheduler.add_job(check_training_inactive_3days, CronTrigger(hour=18, minute=5))
        scheduler.add_job(check_reserve_expired, CronTrigger(hour=10, minute=15))
        
    # Daily checks: recruits 14d & birthdays (MSK)
# Daily checks: recruits 14d & birthdays (MSK)# 
        # scheduler.add_job(check_recruit_promotion_candidates, CronTrigger(hour=10, minute=0, timezone=ZoneInfo("Europe/Moscow")))
        scheduler.add_job(check_birthdays_today, CronTrigger(hour=9, minute=0, timezone=ZoneInfo("Europe/Moscow")))
        scheduler.start()
    except Exception:
        pass

    try:
        await bot.set_my_commands([
            BotCommand(command="start", description="–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"),
            BotCommand(command="profile", description="–ü—Ä–æ—Ñ–∏–ª—å"),
            BotCommand(command="menu", description="–ú–µ–Ω—é –∫–ª–∞–Ω–∞"),
])
    except Exception:
        pass

    try:
        # –ö–æ–º–∞–Ω–¥—ã –¥–ª—è –∞–¥–º–∏–Ω–æ–≤/–º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ (–¥–æ–±–∞–≤–ª—è–µ–º /amenu)
        admin_cmds = [
            BotCommand(command="start", description="–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"),
            BotCommand(command="profile", description="–ü—Ä–æ—Ñ–∏–ª—å"),
            BotCommand(command="menu", description="–ú–µ–Ω—é –∫–ª–∞–Ω–∞"),
            BotCommand(command="amenu", description="–ê–¥–º–∏–Ω-–º–µ–Ω—é"),
]
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –≤ –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö —á–∞—Ç–∞—Ö –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞/–º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞
        for _uid in (set(ADMIN_IDS) | set(MODERATOR_IDS)):
            try:
                await bot.set_my_commands(admin_cmds, scope=BotCommandScopeChat(chat_id=_uid))
            except Exception:
                continue
    except Exception:
        pass


    await dp.start_polling(bot)




class CWCreateState(StatesGroup):
    opponents = State()
    starts = State()
    map = State()
    team = State()
    rules = State()
    server = State()

@dp.message(Command("cw_create"))
async def CW_cmd_create(message: Message, state: FSMContext):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã."); return
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤ (–ø—Ä–∏–º–µ—Ä: BB vs CL):")
    await state.set_state(CWCreateState.opponents)

@dp.message(CWCreateState.opponents)
async def CW_create_opponents(message: Message, state: FSMContext):
    await state.update_data(opponents=message.text.strip())
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì –ß–ß:–ú–ú:")
    await state.set_state(CWCreateState.starts)

@dp.message(CWCreateState.starts)
async def CW_create_starts(message: Message, state: FSMContext):
    raw = message.text.strip()
    try:
        dt = datetime.strptime(raw, "%d.%m.%y %H:%M")
        starts_iso = dt.isoformat()
    except Exception:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ: –î–î.–ú–ú.–ì–ì –ß–ß:–ú–ú"); return
    await state.update_data(starts_at=starts_iso)
    await message.answer("–ö–∞—Ä—Ç–∞:")
    await state.set_state(CWCreateState.map)

@dp.message(CWCreateState.map)
async def CW_create_map(message: Message, state: FSMContext):
    await state.update_data(map=message.text.strip())
    await message.answer("–†–∞–∑–º–µ—Ä –∫–æ–º–∞–Ω–¥—ã (—á–∏—Å–ª–æ):")
    await state.set_state(CWCreateState.team)

@dp.message(CWCreateState.team)
async def CW_create_team(message: Message, state: FSMContext):
    try:
        team = int(message.text.strip())
        if team <= 0: raise ValueError
    except Exception:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ."); return
    await state.update_data(team_size=team)
    await message.answer("–ü—Ä–∞–≤–∏–ª–∞:")
    await state.set_state(CWCreateState.rules)

@dp.message(CWCreateState.rules)
async def CW_create_rules(message: Message, state: FSMContext):
    await state.update_data(rules=message.text.strip())
    await message.answer("–°–µ—Ä–≤–µ—Ä –∏–≥—Ä—ã:")
    await state.set_state(CWCreateState.server)

@dp.message(CWCreateState.server)
async def CW_create_finish(message: Message, state: FSMContext):
    data = await state.get_data()
    war_id = await CW_create_war(
        opponents=data.get("opponents"),
        starts_at_iso=data.get("starts_at"),
        map_=data.get("map"),
        team_size=int(data.get("team_size")),
        rules=data.get("rules"),
        server=message.text.strip(),
    )
    await state.clear()
    await message.answer(f"‚úÖ –ö–í —Å–æ–∑–¥–∞–Ω–æ (ID: {war_id}). –û—Ç–∫—Ä–æ–π—Ç–µ –ø–∞–Ω–µ–ª—å: /cw_admin")
    await log_mod_action(message.from_user.id, "–°–æ–∑–¥–∞–Ω–∏–µ –ö–í", target_id=war_id)
    # schedule reminders (24h, 12h, 6h)
    try:
        if CW_SCHEDULER:
            run_dt = datetime.fromisoformat(data.get("starts_at"))
            for hours in (24, 12, 6):
                trig_dt = run_dt - timedelta(hours=hours)
                if trig_dt > datetime.utcnow():
                    CW_SCHEDULER.add_job(CW_send_reminder_job, trigger="date", run_date=trig_dt, args=[war_id, hours])
    except Exception:
        pass

    # —É–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ (–∫—Ä–æ–º–µ —Ñ—Ä–∞–∫—Ü–∏–∏ ¬´–†–µ–∑–µ—Ä–≤¬ª) –æ –Ω–æ–≤–æ–º –ö–í
    try:
        await CW_notify_new_war_all_players(war_id)
    except Exception:
        pass

async def CW_send_reminder_job(war_id: int, hours_before: int):
    w = await CW_get_war(war_id)
    if not w or w.get("status") != "scheduled":
        return
    regs = await CW_registrations(war_id)
    if not regs:
        return
    text = (
        f"<b>–í–Ω–∏–º–∞–Ω–∏–µ!</b> –û—Ç–∫—Ä—ã—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞ –ö–í!\n"
        f"‚öî{w['opponents']}\n‚è∞–í—Ä–µ–º—è: {format_cw_datetime(w['starts_at'])}\nüó∫–ö–∞—Ä—Ç–∞: {w.get('map') or '-'}"
    )
    for uid in regs:
        try:
            await bot.send_message(uid, text)
        except Exception:
            pass

async def CW_notify_new_war_all_players(war_id: int):
    """–†–∞—Å—Å—ã–ª–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–æ–≤–æ–º –ö–í –≤—Å–µ–º –∏–≥—Ä–æ–∫–∞–º, –∫—Ä–æ–º–µ —Ñ—Ä–∞–∫—Ü–∏–∏ ¬´–†–µ–∑–µ—Ä–≤¬ª."""
    w = await CW_get_war(war_id)
    if not w or w.get("status") != "scheduled":
        return
    # –≤—ã–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ –∏–∑ –±–∞–∑—ã
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT user_id, faction FROM users") as cur:
            rows = await cur.fetchall()
    if not rows:
        return
    starts_str = format_cw_datetime(w["starts_at"])
    text = (
        "<b> –ù–∞–∑–Ω–∞—á–µ–Ω–æ –Ω–æ–≤–æ–µ –ö–í!</b>\n\n"
        f"‚öî<b>{w['opponents']}</b>\n"
        f"üìÜ –ö–æ–≥–¥–∞: {starts_str}\n"
        f"üó∫ –ö–∞—Ä—Ç–∞: {w.get('map') or '-'}\n"
        f"‚ò† –ö–æ–º–∞–Ω–¥–∞: {w['team_size']}\n"
        f"üìú –ü—Ä–∞–≤–∏–ª–∞: {w.get('rules') or '-'}\n"
        f"üîå –°–µ—Ä–≤–µ—Ä: {w.get('server') or '-'}\n\n"
        "‚úè –ß—Ç–æ–±—ã –∑–∞–ø–∏—Å–∞—Ç—å—Å—è, –æ—Ç–∫—Ä–æ–π—Ç–µ –º–µ–Ω—é –±–æ—Ç–∞ /menu –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –ø—É–Ω–∫—Ç ¬´–ö–ª–∞–Ω–æ–≤—ã–µ –≤–æ–π–Ω—ã¬ª."
    )
    for uid, faction in rows:
        try:
            if (faction or "").strip() == "–†–µ–∑–µ—Ä–≤":
                continue
            await bot.send_message(uid, text)
        except Exception:
            pass




@dp.message(Command("cw_admin"))
async def CW_cmd_admin(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã."); return
    wars = await CW_list_active()
    if not wars:
        await message.answer("–ê–∫—Ç–∏–≤–Ω—ã—Ö –ö–í –Ω–µ—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /cw_create."); return
    kb = InlineKeyboardBuilder()
    for w in wars:
        kb.button(text=f"{w['opponents']} ‚Äî {format_cw_datetime(w['starts_at'])}", callback_data=f"cw:panel:{w['id']}")
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –ö–í:", reply_markup=kb.adjust(1).as_markup())

@dp.callback_query(F.data.startswith("cw:panel:"))
async def CW_admin_panel(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True); return
    war_id = int(call.data.split(":")[2])
    w = await CW_get_war(war_id)
    if not w:
        await call.answer("–ö–í –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True); return
    regs = await CW_registrations(war_id)
    names = []
    for uid in regs:
        u = await get_user(uid)
        names.append(display_name(u, fallback_fullname=str(uid)))
    info = (
        f"<b>{w['opponents']}</b>\n"
        f"–í—Ä–µ–º—è: {format_cw_datetime(w['starts_at'])}\n–ö–∞—Ä—Ç–∞: {w.get('map') or '-'}\n–ö–æ–º–∞–Ω–¥–∞: {w['team_size']}\n"
        f"–ü—Ä–∞–≤–∏–ª–∞: {w.get('rules') or '-'}\n–°–µ—Ä–≤–µ—Ä: {w.get('server') or '-'}\n\n"
        f"<b>–£—á–∞—Å—Ç–Ω–∏–∫–∏ ({len(regs)}/{w['team_size']}):</b>\n" + ("\n".join(names) if names else "‚Äî –ø–æ–∫–∞ –Ω–µ—Ç ‚Äî")
    )
    kb = InlineKeyboardBuilder()
    for uid in regs:
        kb.button(text=f"‚ùå –£–¥–∞–ª–∏—Ç—å {uid}", callback_data=f"cw:del:{war_id}:{uid}")
    kb.row()
    kb.button(text="üèÅ –ó–∞–≤–µ—Ä—à–∏—Ç—å –ö–í", callback_data=f"cw:finish:{war_id}")
    kb.button(text="üóë –£–¥–∞–ª–∏—Ç—å –ö–í", callback_data=f"cw:delete:{war_id}")
    await call.message.answer(info, reply_markup=kb.adjust(1).as_markup())
    await call.answer()

@dp.callback_query(F.data.startswith("cw:del:"))
async def CW_admin_remove_player(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True); return
    _, _, war_id_s, uid_s = call.data.split(":")
    await CW_unregister(int(war_id_s), int(uid_s))
    await log_mod_action(call.from_user.id, "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ö–í", target_id=int(uid_s), extra=f"–£–¥–∞–ª—ë–Ω –∏–∑ –ö–í {war_id_s}")
    await call.answer("–£–¥–∞–ª—ë–Ω. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å–Ω–æ–≤–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –º–µ—Å—Ç.")


@dp.callback_query(F.data.startswith("cw:delete:"))
async def CW_admin_delete_war(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True); return
    _, _, war_id_s = call.data.split(":")
    ok = await CW_delete_war(int(war_id_s))
    await call.answer("–ö–í —É–¥–∞–ª–µ–Ω–æ." if ok else "–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å.", show_alert=not ok)
@dp.callback_query(F.data.startswith("cw:finish:"))
async def CW_admin_finish_ask(call: CallbackQuery):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True); return
    war_id = int(call.data.split(":")[2])
    kb = InlineKeyboardBuilder()
    kb.button(text="Blackberry –ø–æ–±–µ–¥–∏–ª", callback_data=f"cw:finishset:{war_id}:bb")
    kb.button(text="–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ–±–µ–¥–∏–ª", callback_data=f"cw:finishset:{war_id}:opp")
    await call.message.answer("–£–∫–∞–∂–∏—Ç–µ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è:", reply_markup=kb.adjust(1).as_markup())
    await call.answer()

@dp.callback_query(F.data == "cw_results")
async def cw_results_request(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ ID –º–∞—Ç—á–∞ (ID –ö–í), —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å:")
    await state.set_state(CWViewStatsState.waiting_war_id)
    await call.answer()

@dp.message(CWViewStatsState.waiting_war_id)
async def cw_show_match_stats(message: Message, state: FSMContext):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        await state.clear()
        return

    raw = (message.text or "").strip()
    if not raw.isdigit():
        await message.answer("ID –ö–í –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º. –í–≤–µ–¥–∏—Ç–µ ID –µ—â—ë —Ä–∞–∑:")
        return

    war_id = int(raw)
    war = await CW_get_war(war_id)
    if not war:
        await message.answer("–ö–í —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        await state.clear()
        return

    if war.get("status") != "finished":
        await message.answer("–≠—Ç–æ –ö–í –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ, –ø–æ–¥—Ä–æ–±–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –Ω–µ—Ç.")
        await state.clear()
        return

    stats_rows = await CW_player_stats_for_war(war_id)
    if not stats_rows:
        await message.answer(
            "–ü–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —ç—Ç–æ–º—É –ö–í –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.\n"
            "–í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–æ –±—ã–ª–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –¥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞."
        )
        await state.clear()
        return

    # –õ—É—á—à–∏–π –∏–≥—Ä–æ–∫ ‚Äî –ø–µ—Ä–≤—ã–π –≤ —Å–ø–∏—Å–∫–µ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π +BBP / elo_delta)
    best = stats_rows[0]
    best_user = await get_user(best["user_id"])
    best_name = display_name(
        best_user,
        fallback_fullname=best.get("nickname") or str(best["user_id"]),
    )

    lines: list[str] = []
    lines.append(f"<b>–ö–í #{war_id}</b>")
    lines.append(f"‚öî –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫: {war['opponents']}")
    bb_score = war.get("bb_score")
    opp_score = war.get("opp_score")
    if bb_score is not None and opp_score is not None:
        lines.append(f"üìä –°—á—ë—Ç –ö–í: <b>{bb_score}:{opp_score}</b> (BB:–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫)")
    lines.append(f"‚è∞ –í—Ä–µ–º—è: {format_cw_datetime(war['starts_at'])}")
    lines.append(f"üó∫ –ö–∞—Ä—Ç–∞: {war.get('map') or '-'}")
    lines.append(f"‚ò† –ö–æ–º–∞–Ω–¥–∞: {war.get('team_size')}")
    lines.append(f"üì¢ –ü—Ä–∞–≤–∏–ª–∞: {war.get('rules') or '-'}")
    lines.append(f"üîå –°–µ—Ä–≤–µ—Ä: {war.get('server') or '-'}")
    lines.append(f"üèÅ –†–µ–∑—É–ª—å—Ç–∞—Ç: –ø–æ–±–µ–¥–∏—Ç–µ–ª—å {war.get('winner') or '‚Äî'}")
    lines.append("")
    lines.append(f"<b>–õ—É—á—à–∏–π –∏–≥—Ä–æ–∫</b> ‚Äî {best_name}")
    lines.append("")
    lines.append("<b>–¢–∞–±–ª–∏—Ü–∞ –∏–≥—Ä–æ–∫–æ–≤</b>")
    lines.append("<code>")
    lines.append(f"{'–ù–∏–∫':20} {'Raising':7} {'Kill':4} {'Death':5} {'Points':6} {'+BBP':7}")

    for row in stats_rows:
        u = await get_user(row["user_id"])
        name = display_name(
            u,
            fallback_fullname=row.get("nickname") or str(row["user_id"]),
        )
        name_cut = name[:20]
        revives = row["revives"]
        kills = row["kills"]
        deaths = row["deaths"]
        caps = row["caps"]
        elo_delta = row["elo_delta"]

        lines.append(
            f"{name_cut:20} "
            f"{revives:7} "
            f"{kills:4} "
            f"{deaths:5} "
            f"{caps:6} "
            f"{elo_delta:+7.1f}"
        )

    lines.append("</code>")

    await message.answer("\n".join(lines))
    # --- –∫–∞—Ä—Ç–∏–Ω–∫–∞ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ö–í (—Ç–æ—Ç –∂–µ —Å—Ç–∏–ª—å, —á—Ç–æ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏) ---
    try:
        # –æ–±—â–∏–π —Å—á—ë—Ç –ö–í –±–µ—Ä—ë–º –∏–∑ –ø–æ–ª–µ–π war (–µ—Å–ª–∏ —Ç—ã –∏—Ö —É–∂–µ –¥–æ–±–∞–≤–∏–ª –≤ —Ç–∞–±–ª–∏—Ü—É cw_wars)
        bb_total = int(war.get("bb_score") or 0)
        opp_total = int(war.get("opp_score") or 0)

        # best_name —É —Ç–µ–±—è —É–∂–µ –ø–æ—Å—á–∏—Ç–∞–Ω –≤—ã—à–µ –∫–∞–∫ –Ω–∏–∫ MVP
        img_path = generate_cw_result_image(
            war,
            bb_score=bb_total,
            opp_score=opp_total,
            mvp_name=best_name,
        )

        await message.answer_photo(
            photo=FSInputFile(img_path),
            caption="üìä –ö–∞—Ä—Ç–æ—á–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ö–í",
        )
    except Exception as e:
        import logging
        logging.exception("Failed to generate/send CW result image: %s", e)

    await state.clear()

@dp.callback_query(F.data.startswith("cw:finishset:"))
async def CW_admin_finish_set(call: CallbackQuery, state: FSMContext):
    if call.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    _, _, war_id_s, who = call.data.split(":")
    war_id = int(war_id_s)
    label = "Blackberry" if who == "bb" else "–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫"

    regs = await CW_registrations(war_id)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è FSM (–¥–∞–∂–µ –µ—Å–ª–∏ regs –ø—É—Å—Ç–æ–π ‚Äî —Ç–æ–≥–¥–∞ –ø—Ä–æ—Å—Ç–æ –Ω–µ –±—É–¥–µ–º —Å–æ–±–∏—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∏–≥—Ä–æ–∫–∞–º)
    await state.update_data(
        cw_war_id=war_id,
        cw_winner_label=label,
        cw_player_ids=regs,          # —Å–ø–∏—Å–æ–∫ user_id –∏–≥—Ä–æ–∫–æ–≤
        cw_index=0,                  # –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞ –≤ —Å–ø–∏—Å–∫–µ
        cw_stats={},                 # ‚Üê –ü–£–°–¢–û–ô —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Å—Ç–∞—Ç
        cw_moderator_id=call.from_user.id,
    )

    # –°–Ω–∞—á–∞–ª–∞ —Å–ø—Ä–∞—à–∏–≤–∞–µ–º –æ–±—â–∏–π —Å—á—ë—Ç –ö–í
    await call.message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –æ–±—â–∏–π —Å—á—ë—Ç –ö–í –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>BB:–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>2:1</code>).\n"
        "–ü–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤ Blackberry, –≤—Ç–æ—Ä–æ–µ ‚Äî —Ä–∞—É–Ω–¥–æ–≤ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞."
    )
    await state.set_state(CWStatsState.waiting_score)
    await call.answer()

    regs = await CW_registrations(war_id)
    # –ï—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–æ–≤ ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º –∫–∞–∫ —Ä–∞–Ω—å—à–µ
    if not regs:
        ok = await CW_finish(war_id, label)
        if ok:
            await log_mod_action(call.from_user.id, "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ö–í", target_id=war_id, extra=label)
        await call.answer("–ó–∞–≤–µ—Ä—à–µ–Ω–æ." if ok else "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å.")
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è FSM
    await state.update_data(
        cw_war_id=war_id,
        cw_winner_label=label,
        cw_player_ids=regs,
        cw_index=0,
        cw_stats={},  # user_id(str) -> {revives, kills, deaths, caps}
        cw_moderator_id=call.from_user.id,
    )

@dp.message(CWStatsState.waiting_score)
async def cw_stats_score(message: Message, state: FSMContext):
    raw = (message.text or "").strip()
    # –¥–æ–ø—É—Å–∫–∞–µ–º —Ñ–æ—Ä–º–∞—Ç—ã –≤–∏–¥–∞ 2:1, 2-1, 2x1
    m = re.match(r"^\s*(\d+)\s*[:xX\-]\s*(\d+)\s*$", raw)
    if not m:
        await message.answer(
            "–í–≤–µ–¥–∏—Ç–µ —Å—á—ë—Ç –ö–í –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>BB:–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫</b>, –Ω–∞–ø—Ä–∏–º–µ—Ä <code>2:1</code>."
        )
        return

    bb_score = int(m.group(1))
    opp_score = int(m.group(2))

    data = await state.get_data()
    war_id = data.get("cw_war_id")
    winner_label = data.get("cw_winner_label")
    player_ids: list[int] = data.get("cw_player_ids") or []

    if war_id is None or winner_label is None:
        await message.answer("–î–∞–Ω–Ω—ã–µ –ö–í –ø–æ—Ç–µ—Ä—è–Ω—ã, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ö–í –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        return

    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—á—ë—Ç –≤ FSM, –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è –ø—Ä–∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
    await state.update_data(cw_bb_score=bb_score, cw_opp_score=opp_score)

    # –ï—Å–ª–∏ –∏–≥—Ä–æ–∫–æ–≤ –Ω–µ—Ç –≤–æ–æ–±—â–µ ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º –ö–í —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –≤–≤–æ–¥–∞ —Å—á—ë—Ç–∞
    if not player_ids:
        ok = await CW_finish(
            war_id,
            winner_label,
            per_player_stats=None,
            bb_score=bb_score,
            opp_score=opp_score,
        )

        mod_id = data.get("cw_moderator_id")
        if ok and mod_id:
            await log_mod_action(mod_id, "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ö–í", target_id=war_id, extra=winner_label)

        if ok:
            # –ø—Ä–æ–±—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            try:
                war = await CW_get_war(war_id)
                stats_rows = await CW_player_stats_for_war(war_id)

                mvp_name = None
                if stats_rows:
                    best = stats_rows[0]
                    best_user = await get_user(best["user_id"])
                    mvp_name = display_name(
                        best_user,
                        fallback_fullname=best.get("nickname") or str(best["user_id"]),
                    )

                img_path = generate_cw_result_image(
                    war,
                    bb_score=int(bb_score) if bb_score is not None else 0,
                    opp_score=int(opp_score) if opp_score is not None else 0,
                    mvp_name=mvp_name,
                )
                await message.answer_photo(
                    photo=FSInputFile(img_path),
                    caption="–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ö–í",
                )
            except Exception:
                pass

        await state.clear()
        await message.answer("–ö–í –∑–∞–≤–µ—Ä—à–µ–Ω–æ, —Å—á—ë—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω.")
        return

    # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–≥—Ä–æ–∫–∏ ‚Äî –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–±–æ—Ä—É –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    first_uid = player_ids[0]
    user = await get_user(first_uid)
    name = display_name(user, fallback_fullname=str(first_uid))

    await message.answer(
        f"–ö–í #{war_id}\n–ü–æ–±–µ–¥–∏—Ç–µ–ª—å: {winner_label}\n"
        f"–°—á—ë—Ç: {bb_score}:{opp_score} (BB:–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫)\n\n"
        f"–ò–≥—Ä–æ–∫: {name}\n"
        f"–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª-–≤–æ –ø–æ–¥–Ω—è—Ç–∏–π —Å–æ—é–∑–Ω–∏–∫–æ–≤ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):"
    )
    await state.set_state(CWStatsState.waiting_revives)
    await call.answer()

@dp.message(CWStatsState.waiting_revives)
async def cw_stats_revives(message: Message, state: FSMContext):
    raw = (message.text or "").strip()
    try:
        revives = int(raw)
    except ValueError:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (0, 1, 2 ...). –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥ –∫–æ–ª-–≤–∞ –ø–æ–¥–Ω—è—Ç–∏–π —Å–æ—é–∑–Ω–∏–∫–æ–≤:")
        return

    data = await state.get_data()
    data["current_revives"] = revives
    await state.update_data(current_revives=revives)

    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª-–≤–æ —É–±–∏–π—Å—Ç–≤ –≤ –ö–í (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(CWStatsState.waiting_kills)


@dp.message(CWStatsState.waiting_kills)
async def cw_stats_kills(message: Message, state: FSMContext):
    raw = (message.text or "").strip()
    try:
        kills = int(raw)
    except ValueError:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥ –∫–æ–ª-–≤–∞ —É–±–∏–π—Å—Ç–≤:")
        return

    await state.update_data(current_kills=kills)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª-–≤–æ —Å–º–µ—Ä—Ç–µ–π –≤ –ö–í (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(CWStatsState.waiting_deaths)


@dp.message(CWStatsState.waiting_deaths)
async def cw_stats_deaths(message: Message, state: FSMContext):
    raw = (message.text or "").strip()
    try:
        deaths = int(raw)
    except ValueError:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥ –∫–æ–ª-–≤–∞ —Å–º–µ—Ä—Ç–µ–π:")
        return

    await state.update_data(current_deaths=deaths)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª-–≤–æ –æ—á–∫–æ–≤ –∑–∞—Ö–≤–∞—Ç–∞ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")
    await state.set_state(CWStatsState.waiting_caps)


@dp.message(CWStatsState.waiting_caps)
async def cw_stats_caps(message: Message, state: FSMContext):
    raw = (message.text or "").strip()
    try:
        caps = int(raw)
    except ValueError:
        await message.answer(
            "–í–≤–µ–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ. "
            "–ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥ –∫–æ–ª-–≤–∞ –æ—á–∫–æ–≤ –∑–∞—Ö–≤–∞—Ç–∞:"
        )
        return

    data = await state.get_data()
    war_id = data.get("cw_war_id")
    winner_label = data.get("cw_winner_label")
    player_ids: list[int] = data.get("cw_player_ids") or []
    idx = int(data.get("cw_index") or 0)

    # –í–ê–ñ–ù–û: –±–µ—Ä—ë–º —É–∂–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å, –∞ –Ω–µ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π
    stats: dict = data.get("cw_stats") or {}

    if war_id is None or winner_label is None or not player_ids:
        await message.answer("–î–∞–Ω–Ω—ã–µ –ö–í –ø–æ—Ç–µ—Ä—è–Ω—ã, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ö–í –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        return

    uid = player_ids[idx]

    # –¢–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ –∏–≥—Ä–æ–∫—É, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –Ω–∞–±—Ä–∞–ª–∏ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —à–∞–≥–∞—Ö
    revives = int(data.get("current_revives") or 0)
    kills = int(data.get("current_kills") or 0)
    deaths = int(data.get("current_deaths") or 0)

    # ‚¨á‚¨á‚¨á –í–û–¢ –≠–¢–ê –°–¢–†–û–ö–ê –î–û–õ–ñ–ù–ê –ë–´–¢–¨ –ò–ú–ï–ù–ù–û –¢–ê–ö ‚¨á‚¨á‚¨á
    # –¥–æ–±–∞–≤–ª—è–µ–º/–æ–±–Ω–æ–≤–ª—è–µ–º –ó–ê–ü–ò–°–¨ –î–õ–Ø –≠–¢–û–ì–û –∏–≥—Ä–æ–∫–∞ –≤ –æ–±—â–µ–º —Å–ª–æ–≤–∞—Ä–µ,
    # –∞ –Ω–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º –≤–µ—Å—å —Å–ª–æ–≤–∞—Ä—å
    stats[str(uid)] = {
        "revives": revives,
        "kills": kills,
        "deaths": deaths,
        "caps": caps,
    }

    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ FSM –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –∏–≥—Ä–æ–∫—É
    idx += 1
    await state.update_data(
        cw_index=idx,
        cw_stats=stats,          # ‚Üê —Å–æ—Ö—Ä–∞–Ω—è–µ–º –û–ë–ù–û–í–õ–Å–ù–ù–´–ô —Å–ª–æ–≤–∞—Ä—å
        current_revives=None,
        current_kills=None,
        current_deaths=None,
    )

    # –ï—Å–ª–∏ –µ—Å—Ç—å –µ—â—ë –∏–≥—Ä–æ–∫–∏ ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—Ç–∞—Ç—ã —Å–ª–µ–¥—É—é—â–µ–≥–æ
    if idx < len(player_ids):
        next_uid = player_ids[idx]
        user = await get_user(next_uid)
        name = display_name(user, fallback_fullname=str(next_uid))

        await message.answer(
            f"–°–ª–µ–¥—É—é—â–∏–π –∏–≥—Ä–æ–∫: {name}\n"
            f"–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª-–≤–æ –ø–æ–¥–Ω—è—Ç–∏–π —Å–æ—é–∑–Ω–∏–∫–æ–≤ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):"
        )
        await state.set_state(CWStatsState.waiting_revives)
        return

    # –í—Å–µ –∏–≥—Ä–æ–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã ‚Äî –∑–∞–≤–µ—Ä—à–∞–µ–º –ö–í
    bb_score = data.get("cw_bb_score")
    opp_score = data.get("cw_opp_score")

    ok = await CW_finish(
        war_id,
        winner_label,
        per_player_stats=stats,   # ‚Üê –∑–¥–µ—Å—å —É–∂–µ –≤—Å–µ –∏–≥—Ä–æ–∫–∏
        bb_score=int(bb_score) if bb_score is not None else None,
        opp_score=int(opp_score) if opp_score is not None else None,
    )

    mod_id = data.get("cw_moderator_id")
    if ok and mod_id:
        await log_mod_action(
            mod_id,
            "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ö–í",
            target_id=war_id,
            extra=winner_label,
        )

    if ok:
        # –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∏, –∫–∞–∫ —É —Ç–µ–±—è

        try:
            war = await CW_get_war(war_id)
            stats_rows = await CW_player_stats_for_war(war_id)
            img_path = generate_cw_result_image(
                war,
                stats_rows,
                int(bb_score) if bb_score is not None else 0,
                int(opp_score) if opp_score is not None else 0,
            )
            await message.answer_photo(
                photo=FSInputFile(img_path),
                caption="–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ö–í",
            )
        except Exception:
            pass

    await state.clear()
    await message.answer(
        "–ö–í –∑–∞–≤–µ—Ä—à–µ–Ω–æ, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∏–≥—Ä–æ–∫–∞–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∏ ELO –æ–±–Ω–æ–≤–ª—ë–Ω."
    )
@dp.message(Command("cw_stats"))
async def CW_cmd_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    rows = await CW_list_finished(limit=50)
    if not rows:
        await message.answer("–ü—Ä–æ—à–µ–¥—à–∏—Ö –ö–í –ø–æ–∫–∞ –Ω–µ—Ç.")
        return

    lines = ["<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ö–í ‚Äî –ø—Ä–æ—à–µ–¥—à–∏–µ</b>"]
    kb = InlineKeyboardBuilder()

    for w in rows:
        res = w.get("winner") or "‚Äî"
        bb_score = w.get("bb_score")
        opp_score = w.get("opp_score")
        score_part = ""
        if bb_score is not None and opp_score is not None:
            score_part = f" (—Å—á—ë—Ç {bb_score}:{opp_score})"

        lines.append(
            f"‚Ä¢ ID <b>{w['id']}</b>: {format_cw_datetime(w['starts_at'])} ‚Äî {w['opponents']} ‚Äî —Ä–µ–∑—É–ª—å—Ç–∞—Ç: –ø–æ–±–µ–¥–∏—Ç–µ–ª—å {res}{score_part}"
        )
        kb.button(
            text=f"üóë –£–¥–∞–ª–∏—Ç—å {w['id']}",
            callback_data=f"cw:delete:{w['id']}",
        )

    # –û—Ç–¥–µ–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–∞—Ç—á–µ–π" —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º callback_data
    kb.row()
    kb.button(text="üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–∞—Ç—á–µ–π", callback_data="cw_results")
    await message.answer("\n".join(lines), reply_markup=kb.adjust(1).as_markup())

# ======= Admin Menu (/amenu) & Find Player flow =======
class FindPlayerState(StatesGroup):
    waiting_query = State()

def admin_menu_kb(is_admin: bool) -> ReplyKeyboardMarkup:
    keyboard = [
        [KeyboardButton(text="–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤"), KeyboardButton(text="–°—Ç–∞—Ç—É—Å –ø–æ—Å–µ—â–µ–Ω–∏—è")],
        [KeyboardButton(text="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–ª–∞–Ω–∞"), KeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç—ã")],
        [KeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å –∏–≤–µ–Ω—Ç—ã"), KeyboardButton(text="–ù–∞–π—Ç–∏ –∏–≥—Ä–æ–∫–∞")],
        [KeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –ö–í"), KeyboardButton(text="–ö–í (–∞–¥–º–∏–Ω)")],
        [KeyboardButton(text="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ö–í")],
    ]
    if is_admin:
        keyboard.append([KeyboardButton(text="–î–µ–π—Å—Ç–≤–∏—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤")])
        keyboard.append([KeyboardButton(text="–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞")])
    keyboard.append([KeyboardButton(text="–ó–∞–∫—Ä—ã—Ç—å –º–µ–Ω—é")])
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True,
        one_time_keyboard=False,
        input_field_placeholder="–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ"
    )

@dp.message(Command("amenu"))
async def cmd_admin_menu(message: Message):
    uid = message.from_user.id
    if uid not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    await message.answer("–ê–¥–º–∏–Ω-–º–µ–Ω—é:", reply_markup=admin_menu_kb(uid in ADMIN_IDS))

@dp.message(F.text == "–ó–∞–∫—Ä—ã—Ç—å –º–µ–Ω—é")
async def close_admin_menu(message: Message):
    await message.answer("–ú–µ–Ω—é —Å–∫—Ä—ã—Ç–æ.", reply_markup=ReplyKeyboardRemove())



@dp.message(F.text == "–î–µ–π—Å—Ç–≤–∏—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤")
async def on_label_mod_actions(message: Message):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    # –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞ –ø–æ –ú–æ—Å–∫–≤–µ
    msk = ZoneInfo("Europe/Moscow")
    today = datetime.now(msk).date().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute(
            "SELECT actor_id, actor_role, action, target_id, extra, created_at FROM mod_actions WHERE date(created_at)=date(?) ORDER BY datetime(created_at)",
            (today,)
        ) as cur:
            today_rows = await cur.fetchall()
        async with db.execute(
            "SELECT actor_id, actor_role, action, target_id, extra, created_at FROM mod_actions WHERE date(created_at)<>date(?) ORDER BY datetime(created_at)",
            (today,)
        ) as cur:
            other_rows = await cur.fetchall()

    # –°–æ–æ–±—â–µ–Ω–∏–µ –∑–∞ —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É
    if today_rows:
        lines: list[str] = [f"<b>–î–µ–π—Å—Ç–≤–∏—è –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∑–∞ {today}</b>"]
        for actor_id, actor_role, action, target_id, extra, created_at in today_rows:
            try:
                dt = datetime.fromisoformat(created_at)
                time_str = dt.strftime("%H:%M")
            except Exception:
                time_str = created_at
            # –ò–º–µ–Ω–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞ –∏ —Ü–µ–ª–∏
            actor_user = await get_user(actor_id)
            actor_name = display_name(actor_user, fallback_fullname=f"ID {actor_id}")
            target_name = None
            if target_id is not None:
                target_user = await get_user(target_id)
                if target_user:
                    target_name = display_name(target_user, fallback_fullname=f"ID {target_id}")
                else:
                    target_name = f"ID {target_id}"
            target_part = f", —Ü–µ–ª—å: {target_name}" if target_name else ""
            extra_part = f" ‚Äî {extra}" if extra else ""
            lines.append(f"{time_str} ‚Äî {action} (–º–æ–¥–µ—Ä–∞—Ç–æ—Ä: {actor_name}{target_part}){extra_part}")
        await message.answer("\n".join(lines))
    else:
        await message.answer(f"–ó–∞ {today} –¥–µ–π—Å—Ç–≤–∏–π –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –Ω–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ.")

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –¥–∞—Ç—ã ‚Äî CSV
    if other_rows:
        fname = f"bb_mod_actions_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
        with open(fname, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["actor_id", "actor_role", "action", "target_id", "extra", "created_at"])
            writer.writerows(other_rows)
        await message.answer_document(FSInputFile(fname), caption="CSV —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –¥–µ–π—Å—Ç–≤–∏—è–º–∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤.")


# --- Label -> command dispatchers ---
@dp.message(F.text == "–°–æ–∑–¥–∞—Ç—å –ö–í")
async def on_label_cw_create(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/cw_create")
    try:
        await CW_cmd_create(fake)  # type: ignore
    except Exception:
        await message.answer("/cw_create")

@dp.message(F.text == "–ö–í (–∞–¥–º–∏–Ω)")
async def on_label_cw_admin(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/cw_admin")
    try:
        await CW_cmd_admin(fake)  # type: ignore
    except Exception:
        await message.answer("/cw_admin")

@dp.message(F.text == "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ö–í")
async def on_label_cw_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/cw_stats")
    try:
        await CW_cmd_stats(fake)  # type: ignore
    except Exception:
        await message.answer("/cw_stats")

def _as_command(message: Message, text: str) -> Message:
    try:
        # aiogram v3 models support model_copy
        return message.model_copy(update={"text": text})
    except Exception:
        # fallback: return original (handlers below also guard)
        return message

@dp.message(F.text == "–°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤")
async def on_label_players(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/players")
    try:
        await cmd_players(fake)
    except Exception:
        # –µ—Å–ª–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å, –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤–∏–º –∫–æ–º–∞–Ω–¥—É –≤ —á–∞—Ç –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
        await message.answer("/players")

@dp.message(F.text == "–°—Ç–∞—Ç—É—Å –ø–æ—Å–µ—â–µ–Ω–∏—è")
async def on_label_train_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/train_stats")
    try:
        await cmd_train_stats(fake)  # /train_stats [period]
    except Exception:
        await message.answer("/train_stats")

@dp.message(F.text == "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–ª–∞–Ω–∞")
async def on_label_stats(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/stats")
    try:
        await cmd_stats(fake)
    except Exception:
        await message.answer("/stats")

@dp.message(F.text == "–ò–∑–º–µ–Ω–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç—ã")
async def on_label_contacts(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/contacts")
    try:
        await cmd_set_contacts_text(fake)
    except Exception:
        await message.answer("/contacts")

@dp.message(F.text == "–ò–∑–º–µ–Ω–∏—Ç—å –∏–≤–µ–Ω—Ç—ã")
async def on_label_ivent(message: Message):
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    fake = _as_command(message, "/ivent")
    try:
        await cmd_set_events_text(fake)
    except Exception:
        await message.answer("/ivent")

@dp.message(F.text == "–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞")
async def on_label_rating_changes(message: Message):
    # –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—ã
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("–¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return

    # –ë–µ—Ä—ë–º ¬´—Å–µ–≥–æ–¥–Ω—è¬ª –ø–æ –ú–æ—Å–∫–≤–µ
    try:
        tz = ZoneInfo("Europe/Moscow")
    except Exception:
        tz = None
    today = (datetime.now(tz).date() if tz else datetime.utcnow().date()).isoformat()

    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            """
            SELECT rc.user_id,
                   rc.delta,
                   u.nickname,
                   u.tg_link
            FROM rating_changes rc
            LEFT JOIN users u ON u.user_id = rc.user_id
            WHERE date(rc.created_at) = date(?)
            ORDER BY rc.id ASC
            """,
            (today,),
        )
        rows = await cur.fetchall()

    if not rows:
        await message.answer(f"–ó–∞ —Å–µ–≥–æ–¥–Ω—è ({today}) –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ä–µ–π—Ç–∏–Ω–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return

    # –ì–æ—Ç–æ–≤–∏–º CSV
    filename = f"rating_changes_{today}.csv"
    import csv

    with open(filename, "w", encoding="utf-8", newline="") as f:
        writer = csv.writer(f, delimiter=";")
        writer.writerow(["–ò–º—è(–ù–∏–∫ –¢–ì)", "–°–∫–æ–ª—å–∫–æ —Ä–µ–π—Ç–∏–Ω–≥–∞"])
        for user_id, delta, nickname, tg_link in rows:
            # –∏–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –ù–∏–∫ (tg_link) –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ user_id
            if nickname and tg_link:
                name = f"{nickname} ({tg_link})"
            elif nickname:
                name = nickname
            elif tg_link:
                name = tg_link
            else:
                name = str(user_id)
            writer.writerow([name, delta])

    await message.answer_document(
        FSInputFile(filename, filename=filename),
        caption=f"–ò–∑–º–µ–Ω–µ–Ω–∏—è —Ä–µ–π—Ç–∏–Ω–≥–∞ –∑–∞ {today}",
    )

@dp.message(F.text == "–ù–∞–π—Ç–∏ –∏–≥—Ä–æ–∫–∞")
async def find_player_start(message: Message, state: FSMContext):
    uid = message.from_user.id
    if uid not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        return
    await message.answer("–í–≤–µ–¥–∏—Ç–µ ID, @username –∏–ª–∏ —á–∞—Å—Ç—å –Ω–∏–∫–∞ –∏–≥—Ä–æ–∫–∞:")
    await state.set_state(FindPlayerState.waiting_query)

@dp.message(FindPlayerState.waiting_query)
async def find_player_query(message: Message, state: FSMContext):
    # –õ–æ–≥–∏–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç /player
    if message.from_user.id not in (ADMIN_IDS | MODERATOR_IDS):
        await message.answer("–¢–æ–ª—å–∫–æ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã.")
        await state.clear()
        return
    query = (message.text or "").strip()
    if not query:
        await message.answer("–ü—É—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å. –í–≤–µ–¥–∏—Ç–µ ID, @username –∏–ª–∏ —á–∞—Å—Ç—å –Ω–∏–∫–∞.")
        return

    target_user: Optional[dict] = None
    if query.isdigit():
        target_user = await get_user(int(query))
    if not target_user and query.startswith("@"):
        target_user = await get_user_by_username(query)
    if not target_user:
        matches = await search_users_by_nickname(query, limit=10)
        if isinstance(matches, list) and len(matches) == 1:
            target_user = matches[0]
        elif isinstance(matches, list) and len(matches) > 1:
            lines = ["–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:"]
            for u in matches:
                lines.append(
                    f"‚Ä¢ {u.get('nickname') or '-'} ‚Äî ClanID: {pad_clan_id(u.get('clan_id'))} ‚Äî ID: <code>{u['user_id']}</code> ‚Äî —Ñ—Ä–∞–∫—Ü–∏—è: {u.get('faction') or '-'}"
                )
            lines.append("\n–£—Ç–æ—á–Ω–∏—Ç–µ: –≤–≤–µ–¥–∏—Ç–µ —Ç–æ—á–Ω—ã–π ID –∏–ª–∏ @username.")
            await message.answer("\\n".join(lines))
            return

    if not target_user:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        await state.clear()
        return

    # –ò—Å—Ç–æ—Ä–∏—è —Ç—É—Ä–Ω–∏—Ä–æ–≤ –∏ –ø–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞
    user_id_int = int(target_user.get("user_id"))
    history = await get_tournament_history(user_id_int)
    pos = await get_player_position(user_id_int)

    # –ö–∞—Ä—Ç–∏–Ω–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è (–∫–∞–∫ —É /profile)
    image_path = generate_profile_card_image(target_user, history=history, pos=pos)
    await message.answer_photo(
        photo=FSInputFile(image_path)
    )

    # –û–¥–∏–Ω —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ—Ñ–∏–ª—å —Å –∫–Ω–æ–ø–∫–∞–º–∏ (–±–µ–∑ –¥—É–±–ª–µ–π)
    await message.answer(
        format_profile(target_user, history=history, pos=pos),
        reply_markup=profile_admin_kb(target_user["user_id"], actor_id=message.from_user.id),
    )

    await state.clear()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("Bot stopped.")


async def fetch_new_users(limit: int = 100):
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "SELECT user_id, clan_id, nickname, created_at FROM users WHERE status = ? ORDER BY created_at DESC LIMIT ?",
            ("new", limit)
        )
        return await cur.fetchall()

def format_new_users(rows) -> str:
    lines = ["<b>–ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (status=new)</b>"]
    if not rows:
        lines.append("‚Äî —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç ‚Äî")
    else:
        for uid, clan_id, nickname, created_at in rows:
            cid = f"{int(clan_id):04d}" if clan_id else "‚Äî"
            name = nickname or "-"
            lines.append(f"ClanID: {cid} ‚Ä¢ ID: <code>{uid}</code> ‚Ä¢ –ù–∏–∫: {name} ‚Ä¢ –°–æ–∑–¥–∞–Ω: {created_at or '-'}")
        lines.append("\n–ß—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å: –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É –∫–∞—Ä—Ç–æ—á–∫–∏.")
    return "\n".join(lines)

def new_users_kb(rows) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for uid, clan_id, nickname, created_at in rows:
        kb.button(text=f"üóë –£–¥–∞–ª–∏—Ç—å {nickname or uid}", callback_data=f"newdel:{uid}")
    return kb.adjust(1).as_markup()
